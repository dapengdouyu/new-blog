---
title: 3ã€Kratosè¿›é˜¶ï¼šæ•°æ®è®¿é—®å±‚
date: 2026-01-06
description: æ·±å…¥ç†è§£Kratosæ¡†æ¶ä¸­GORMçš„é›†æˆå’Œæ•°æ®è®¿é—®å±‚è®¾è®¡
---

# 3ã€Kratosè¿›é˜¶ï¼šæ•°æ®è®¿é—®å±‚

æœ¬æ–‡æ¡£æ·±å…¥è®²è§£Kratosæ¡†æ¶ä¸­GORMçš„é›†æˆï¼Œä»¥åŠæ•°æ®è®¿é—®å±‚çš„è®¾è®¡æ¨¡å¼ã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡GORMåœ¨Kratosä¸­çš„é…ç½®å’Œåˆå§‹åŒ–
- âœ… ç†è§£æ•°æ®åº“æ¨¡å‹çš„è®¾è®¡åŸåˆ™
- âœ… å®ç°Repositoryæ¨¡å¼çš„æ•°æ®åº“è®¿é—®
- âœ… æŒæ¡å…³è”æŸ¥è¯¢å’Œé¢„åŠ è½½
- âœ… ç†è§£äº‹åŠ¡ç®¡ç†å’Œå¹¶å‘å®‰å…¨
- âœ… æŒæ¡æ•°æ®åº“è¿ç§»å’Œè¿æ¥æ± é…ç½®

---

## ä¸€ã€GORMé›†æˆé…ç½®

### 1.1 å®‰è£…ä¾èµ–

```bash
# å®‰è£…GORM
go get -u gorm.io/gorm

# å®‰è£…æ•°æ®åº“é©±åŠ¨
go get -u gorm.io/driver/mysql    # MySQL
go get -u gorm.io/driver/postgres # PostgreSQL
go get -u gorm.io/driver/sqlite   # SQLite

# å¯é€‰ï¼šå®‰è£…å…¶ä»–é©±åŠ¨
go get -u gorm.io/driver/sqlserver # SQL Server
go get -u gorm.io/driver/clickhouse # ClickHouse
```

### 1.2 æ•°æ®åº“é…ç½®

**configs/config.yaml**:

```yaml
data:
  database:
    driver: mysql
    dsn: "root:password@tcp(localhost:3306)/kratos_db?charset=utf8mb4&parseTime=True&loc=Local"
    max_idle_conns: 10
    max_open_conns: 100
    conn_max_lifetime: 3600s
    enable_log: true
    log_level: info
    auto_migrate: true
```

**internal/conf/conf.go**:

```go
package conf

type Data struct {
    Database *Database `json:"database"`
}

type Database struct {
    Driver          string `json:"driver"`
    DSN             string `json:"dsn"`
    MaxIdleConns    int    `json:"max_idle_conns"`
    MaxOpenConns    int    `json:"max_open_conns"`
    ConnMaxLifetime string `json:"conn_max_lifetime"`
    EnableLog       bool   `json:"enable_log"`
    LogLevel        string `json:"log_level"`
    AutoMigrate     bool   `json:"auto_migrate"`
}
```

### 1.3 æ•°æ®åº“è¿æ¥åˆå§‹åŒ–

**internal/data/data.go**:

```go
package data

import (
    "database/sql"
    "time"

    "github.com/go-kratos/kratos/v2/log"
    "github.com/google/wire"
    "gorm.io/driver/mysql"
    "gorm.io/driver/postgres"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"

    "github.com/go-kratos/kratos-layout/internal/conf"
)

var ProviderSet = wire.NewSet(NewData, NewDB)

type Data struct {
    db *gorm.DB
}

func NewData(c *conf.Data) (*Data, func(), error) {
    db, cleanup, err := NewDB(c.Database)
    if err != nil {
        return nil, nil, err
    }

    d := &Data{
        db: db,
    }

    cleanupFunc := func() {
        log.Info("closing the data resources")
        cleanup()
    }

    return d, cleanupFunc, nil
}

func NewDB(c *conf.Database) (*gorm.DB, func(), error) {
    var dialector gorm.Dialector

    switch c.Driver {
    case "mysql":
        dialector = mysql.Open(c.DSN)
    case "postgres":
        dialector = postgres.Open(c.DSN)
    case "sqlite":
        dialector = sqlite.Open(c.DSN)
    default:
        return nil, nil, fmt.Errorf("unsupported database driver: %s", c.Driver)
    }

    // é…ç½®GORMæ—¥å¿—
    var logLevel logger.LogLevel
    switch c.LogLevel {
    case "silent":
        logLevel = logger.Silent
    case "error":
        logLevel = logger.Error
    case "warn":
        logLevel = logger.Warn
    case "info":
        logLevel = logger.Info
    default:
        logLevel = logger.Info
    }

    gormLogger := logger.Default
    if c.EnableLog {
        gormLogger = logger.New(
            log.NewHelper(log.DefaultLogger),
            logger.Config{
                SlowThreshold:             time.Second,
                LogLevel:                  logLevel,
                IgnoreRecordNotFoundError: true,
                Colorful:                  true,
            },
        )
    }

    // è¿æ¥æ•°æ®åº“
    db, err := gorm.Open(dialector, &gorm.Config{
        Logger: gormLogger,
        NowFunc: func() time.Time {
            return time.Now().Local()
        },
    })
    if err != nil {
        return nil, nil, err
    }

    // è·å–åº•å±‚çš„sql.DBè¿›è¡Œè¿æ¥æ± é…ç½®
    sqlDB, err := db.DB()
    if err != nil {
        return nil, nil, err
    }

    // è§£æè¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´
    connMaxLifetime, err := time.ParseDuration(c.ConnMaxLifetime)
    if err != nil {
        connMaxLifetime = time.Hour
    }

    // é…ç½®è¿æ¥æ± 
    sqlDB.SetMaxIdleConns(c.MaxIdleConns)       // æœ€å¤§ç©ºé—²è¿æ¥æ•°
    sqlDB.SetMaxOpenConns(c.MaxOpenConns)       // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    sqlDB.SetConnMaxLifetime(connMaxLifetime)   // è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´

    // æµ‹è¯•è¿æ¥
    if err := sqlDB.Ping(); err != nil {
        return nil, nil, err
    }

    cleanup := func() {
        sqlDB.Close()
    }

    return db, cleanup, nil
}
```

---

## äºŒã€æ•°æ®åº“æ¨¡å‹è®¾è®¡

### 2.1 åŸºç¡€æ¨¡å‹

**internal/model/user.go**:

```go
package model

import (
    "time"
    "gorm.io/gorm"
)

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`

    // ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
    Username string `gorm:"type:varchar(50);uniqueIndex;not null" json:"username"`
    Email    string `gorm:"type:varchar(100);uniqueIndex;not null" json:"email"`
    Password string `gorm:"type:varchar(255);not null" json:"-"` // ä¸åºåˆ—åŒ–å¯†ç 

    // ç”¨æˆ·è¯¦ç»†ä¿¡æ¯
    FirstName string `gorm:"type:varchar(50)" json:"first_name"`
    LastName  string `gorm:"type:varchar(50)" json:"last_name"`
    Age       int    `gorm:"type:int;default:0" json:"age"`
    Gender    string `gorm:"type:enum('male','female','other');default:'other'" json:"gender"`

    // çŠ¶æ€ä¿¡æ¯
    Status    string    `gorm:"type:varchar(20);default:'active'" json:"status"`
    LastLogin *time.Time `json:"last_login"`

    // å…³è”å…³ç³»
    Profile   *UserProfile `gorm:"foreignKey:UserID" json:"profile,omitempty"`
    Posts     []Post       `gorm:"foreignKey:UserID" json:"posts,omitempty"`
    Roles     []Role       `gorm:"many2many:user_roles;" json:"roles,omitempty"`
}

// TableName æŒ‡å®šè¡¨å
func (User) TableName() string {
    return "users"
}

// UserProfile ç”¨æˆ·è¯¦ç»†ä¿¡æ¯
type UserProfile struct {
    ID          uint   `gorm:"primarykey" json:"id"`
    UserID      uint   `gorm:"not null" json:"user_id"`
    Bio         string `gorm:"type:text" json:"bio"`
    Avatar      string `gorm:"type:varchar(500)" json:"avatar"`
    Website     string `gorm:"type:varchar(200)" json:"website"`
    Location    string `gorm:"type:varchar(100)" json:"location"`
    Company     string `gorm:"type:varchar(100)" json:"company"`
    PhoneNumber string `gorm:"type:varchar(20)" json:"phone_number"`
}

// TableName æŒ‡å®šè¡¨å
func (UserProfile) TableName() string {
    return "user_profiles"
}

// Post æ–‡ç« æ¨¡å‹
type Post struct {
    ID          uint           `gorm:"primarykey" json:"id"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"-"`

    Title       string `gorm:"type:varchar(200);not null" json:"title"`
    Content     string `gorm:"type:text;not null" json:"content"`
    Summary     string `gorm:"type:varchar(500)" json:"summary"`
    Status      string `gorm:"type:enum('draft','published','archived');default:'draft'" json:"status"`

    UserID      uint   `gorm:"not null" json:"user_id"`
    User        User   `gorm:"foreignKey:UserID" json:"user,omitempty"`

    CategoryID  uint     `json:"category_id"`
    Category    Category `gorm:"foreignKey:CategoryID" json:"category,omitempty"`

    Tags        []Tag    `gorm:"many2many:post_tags;" json:"tags,omitempty"`
    Comments    []Comment `gorm:"foreignKey:PostID" json:"comments,omitempty"`
}

// TableName æŒ‡å®šè¡¨å
func (Post) TableName() string {
    return "posts"
}

// Category åˆ†ç±»æ¨¡å‹
type Category struct {
    ID          uint   `gorm:"primarykey" json:"id"`
    Name        string `gorm:"type:varchar(100);unique;not null" json:"name"`
    Description string `gorm:"type:varchar(500)" json:"description"`
    Posts       []Post `gorm:"foreignKey:CategoryID" json:"posts,omitempty"`
}

// Tag æ ‡ç­¾æ¨¡å‹
type Tag struct {
    ID   uint   `gorm:"primarykey" json:"id"`
    Name string `gorm:"type:varchar(50);unique;not null" json:"name"`
    Posts []Post `gorm:"many2many:post_tags;" json:"posts,omitempty"`
}

// Comment è¯„è®ºæ¨¡å‹
type Comment struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`

    Content   string `gorm:"type:text;not null" json:"content"`
    PostID    uint   `gorm:"not null" json:"post_id"`
    Post      Post   `gorm:"foreignKey:PostID" json:"post,omitempty"`
    UserID    uint   `gorm:"not null" json:"user_id"`
    User      User   `gorm:"foreignKey:UserID" json:"user,omitempty"`
}

// Role è§’è‰²æ¨¡å‹
type Role struct {
    ID          uint   `gorm:"primarykey" json:"id"`
    Name        string `gorm:"type:varchar(50);unique;not null" json:"name"`
    Description string `gorm:"type:varchar(200)" json:"description"`
    Users       []User `gorm:"many2many:user_roles;" json:"users,omitempty"`
}
```

### 2.2 é’©å­å‡½æ•°

```go
package model

import (
    "crypto/md5"
    "fmt"
    "gorm.io/gorm"
)

// BeforeCreate åˆ›å»ºå‰çš„é’©å­
func (u *User) BeforeCreate(tx *gorm.DB) error {
    // å¯†ç åŠ å¯†
    if u.Password != "" {
        u.Password = hashPassword(u.Password)
    }

    // è®¾ç½®é»˜è®¤å€¼
    if u.Status == "" {
        u.Status = "active"
    }

    return nil
}

// BeforeUpdate æ›´æ–°å‰çš„é’©å­
func (u *User) BeforeUpdate(tx *gorm.DB) error {
    // å¯†ç åŠ å¯†ï¼ˆå¦‚æœæœ‰æ›´æ–°ï¼‰
    if tx.Statement.Changed("Password") && u.Password != "" {
        u.Password = hashPassword(u.Password)
    }

    return nil
}

// AfterFind æŸ¥è¯¢åçš„é’©å­
func (u *User) AfterFind(tx *gorm.DB) error {
    // å¯ä»¥åœ¨è¿™é‡Œå¤„ç†æŸ¥è¯¢ç»“æœ
    return nil
}

// å¯†ç åŠ å¯†å‡½æ•°
func hashPassword(password string) string {
    hash := md5.Sum([]byte(password))
    return fmt.Sprintf("%x", hash)
}
```

### 2.3 è‡ªå®šä¹‰æ•°æ®ç±»å‹

```go
package model

import (
    "database/sql/driver"
    "encoding/json"
    "errors"
)

// JSONMap è‡ªå®šä¹‰JSONå­—æ®µç±»å‹
type JSONMap map[string]interface{}

func (j JSONMap) Value() (driver.Value, error) {
    return json.Marshal(j)
}

func (j *JSONMap) Scan(value interface{}) error {
    bytes, ok := value.([]byte)
    if !ok {
        return errors.New("type assertion to []byte failed")
    }
    return json.Unmarshal(bytes, j)
}

// StringSlice å­—ç¬¦ä¸²åˆ‡ç‰‡å­—æ®µ
type StringSlice []string

func (s StringSlice) Value() (driver.Value, error) {
    return json.Marshal(s)
}

func (s *StringSlice) Scan(value interface{}) error {
    bytes, ok := value.([]byte)
    if !ok {
        return errors.New("type assertion to []byte failed")
    }
    return json.Unmarshal(bytes, s)
}

// ä½¿ç”¨ç¤ºä¾‹
type Article struct {
    ID          uint      `gorm:"primarykey"`
    Title       string    `gorm:"type:varchar(200)"`
    Content     string    `gorm:"type:text"`
    Tags        StringSlice `gorm:"type:json"` // JSONå­—æ®µå­˜å‚¨æ ‡ç­¾
    Metadata    JSONMap     `gorm:"type:json"` // JSONå­—æ®µå­˜å‚¨å…ƒæ•°æ®
    PublishedAt *time.Time `gorm:"type:datetime"`
}
```

---

## ä¸‰ã€Repositoryå±‚å®ç°

### 3.1 Repositoryæ¥å£å®šä¹‰

**internal/biz/repo.go**:

```go
package biz

import (
    "context"
    "github.com/go-kratos/kratos-layout/internal/model"
)

// UserRepo ç”¨æˆ·ä»“åº“æ¥å£
type UserRepo interface {
    Create(ctx context.Context, user *model.User) (*model.User, error)
    Update(ctx context.Context, user *model.User) (*model.User, error)
    Delete(ctx context.Context, id uint) error
    FindByID(ctx context.Context, id uint) (*model.User, error)
    FindByEmail(ctx context.Context, email string) (*model.User, error)
    FindByUsername(ctx context.Context, username string) (*model.User, error)
    List(ctx context.Context, offset, limit int) ([]*model.User, int64, error)
    Count(ctx context.Context) (int64, error)
}

// PostRepo æ–‡ç« ä»“åº“æ¥å£
type PostRepo interface {
    Create(ctx context.Context, post *model.Post) (*model.Post, error)
    Update(ctx context.Context, post *model.Post) (*model.Post, error)
    Delete(ctx context.Context, id uint) error
    FindByID(ctx context.Context, id uint) (*model.Post, error)
    ListByUserID(ctx context.Context, userID uint, offset, limit int) ([]*model.Post, int64, error)
    ListPublished(ctx context.Context, offset, limit int) ([]*model.Post, int64, error)
    Count(ctx context.Context) (int64, error)
}
```

### 3.2 Repositoryå®ç°

**internal/data/user_repo.go**:

```go
package data

import (
    "context"
    "errors"

    "github.com/go-kratos/kratos/v2/log"
    "gorm.io/gorm"

    "github.com/go-kratos/kratos-layout/internal/model"
)

type userRepo struct {
    data *Data
    log  *log.Helper
}

func NewUserRepo(data *Data, logger log.Logger) biz.UserRepo {
    return &userRepo{
        data: data,
        log:  log.NewHelper(logger),
    }
}

func (r *userRepo) Create(ctx context.Context, user *model.User) (*model.User, error) {
    if err := r.data.db.WithContext(ctx).Create(user).Error; err != nil {
        r.log.Errorf("create user failed: %v", err)
        return nil, err
    }
    r.log.Infof("user created: %d", user.ID)
    return user, nil
}

func (r *userRepo) Update(ctx context.Context, user *model.User) (*model.User, error) {
    if err := r.data.db.WithContext(ctx).Save(user).Error; err != nil {
        r.log.Errorf("update user failed: %v", err)
        return nil, err
    }
    r.log.Infof("user updated: %d", user.ID)
    return user, nil
}

func (r *userRepo) Delete(ctx context.Context, id uint) error {
    if err := r.data.db.WithContext(ctx).Delete(&model.User{}, id).Error; err != nil {
        r.log.Errorf("delete user failed: %v", err)
        return err
    }
    r.log.Infof("user deleted: %d", id)
    return nil
}

func (r *userRepo) FindByID(ctx context.Context, id uint) (*model.User, error) {
    var user model.User
    if err := r.data.db.WithContext(ctx).First(&user, id).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        r.log.Errorf("find user by id failed: %v", err)
        return nil, err
    }
    return &user, nil
}

func (r *userRepo) FindByEmail(ctx context.Context, email string) (*model.User, error) {
    var user model.User
    if err := r.data.db.WithContext(ctx).Where("email = ?", email).First(&user).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, nil // è¿”å›nilè¡¨ç¤ºæœªæ‰¾åˆ°ï¼Œä½†ä¸æŠ¥é”™
        }
        r.log.Errorf("find user by email failed: %v", err)
        return nil, err
    }
    return &user, nil
}

func (r *userRepo) FindByUsername(ctx context.Context, username string) (*model.User, error) {
    var user model.User
    if err := r.data.db.WithContext(ctx).Where("username = ?", username).First(&user).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, nil
        }
        r.log.Errorf("find user by username failed: %v", err)
        return nil, err
    }
    return &user, nil
}

func (r *userRepo) List(ctx context.Context, offset, limit int) ([]*model.User, int64, error) {
    var users []*model.User
    var total int64

    // è·å–æ€»æ•°
    if err := r.data.db.WithContext(ctx).Model(&model.User{}).Count(&total).Error; err != nil {
        r.log.Errorf("count users failed: %v", err)
        return nil, 0, err
    }

    // åˆ†é¡µæŸ¥è¯¢
    if err := r.data.db.WithContext(ctx).Offset(offset).Limit(limit).Find(&users).Error; err != nil {
        r.log.Errorf("list users failed: %v", err)
        return nil, 0, err
    }

    return users, total, nil
}

func (r *userRepo) Count(ctx context.Context) (int64, error) {
    var count int64
    if err := r.data.db.WithContext(ctx).Model(&model.User{}).Count(&count).Error; err != nil {
        r.log.Errorf("count users failed: %v", err)
        return 0, err
    }
    return count, nil
}
```

### 3.3 å…³è”æŸ¥è¯¢å’Œé¢„åŠ è½½

```go
func (r *userRepo) FindByIDWithPosts(ctx context.Context, id uint) (*model.User, error) {
    var user model.User
    if err := r.data.db.WithContext(ctx).
        Preload("Posts").
        Preload("Profile").
        First(&user, id).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        r.log.Errorf("find user with posts failed: %v", err)
        return nil, err
    }
    return &user, nil
}

func (r *userRepo) FindByIDWithRoles(ctx context.Context, id uint) (*model.User, error) {
    var user model.User
    if err := r.data.db.WithContext(ctx).
        Preload("Roles").
        First(&user, id).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        r.log.Errorf("find user with roles failed: %v", err)
        return nil, err
    }
    return &user, nil
}
```

### 3.4 å¤æ‚æŸ¥è¯¢

```go
func (r *userRepo) Search(ctx context.Context, query string, status string, offset, limit int) ([]*model.User, int64, error) {
    var users []*model.User
    var total int64

    db := r.data.db.WithContext(ctx).Model(&model.User{})

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    if query != "" {
        db = db.Where("username LIKE ? OR email LIKE ? OR first_name LIKE ? OR last_name LIKE ?",
            "%"+query+"%", "%"+query+"%", "%"+query+"%", "%"+query+"%")
    }

    if status != "" {
        db = db.Where("status = ?", status)
    }

    // è·å–æ€»æ•°
    if err := db.Count(&total).Error; err != nil {
        r.log.Errorf("count users failed: %v", err)
        return nil, 0, err
    }

    // åˆ†é¡µæŸ¥è¯¢
    if err := db.Offset(offset).Limit(limit).Find(&users).Error; err != nil {
        r.log.Errorf("search users failed: %v", err)
        return nil, 0, err
    }

    return users, total, nil
}
```

---

## å››ã€äº‹åŠ¡ç®¡ç†

### 4.1 äº‹åŠ¡åŸºæœ¬ä½¿ç”¨

```go
func (r *userRepo) CreateUserWithProfile(ctx context.Context, user *model.User, profile *model.UserProfile) error {
    return r.data.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // åˆ›å»ºç”¨æˆ·
        if err := tx.Create(user).Error; err != nil {
            return err
        }

        // åˆ›å»ºç”¨æˆ·èµ„æ–™
        profile.UserID = user.ID
        if err := tx.Create(profile).Error; err != nil {
            return err
        }

        return nil
    })
}
```

### 4.2 åµŒå¥—äº‹åŠ¡

```go
func (r *userRepo) TransferPoints(ctx context.Context, fromUserID, toUserID uint, points int) error {
    return r.data.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // æ‰£é™¤å‘é€è€…ç§¯åˆ†
        if err := tx.Model(&model.User{}).Where("id = ?", fromUserID).
            Where("points >= ?", points).
            UpdateColumn("points", gorm.Expr("points - ?", points)).Error; err != nil {
            return errors.New("insufficient points")
        }

        // å¢åŠ æ¥æ”¶è€…ç§¯åˆ†
        if err := tx.Model(&model.User{}).Where("id = ?", toUserID).
            UpdateColumn("points", gorm.Expr("points + ?", points)).Error; err != nil {
            return err
        }

        return nil
    })
}
```

### 4.3 æ‰‹åŠ¨äº‹åŠ¡æ§åˆ¶

```go
func (r *userRepo) ComplexOperation(ctx context.Context) error {
    tx := r.data.db.WithContext(ctx).Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œ
    if err := tx.Create(&model.User{Name: "Alice"}).Error; err != nil {
        tx.Rollback()
        return err
    }

    if err := tx.Create(&model.Post{Title: "Hello"}).Error; err != nil {
        tx.Rollback()
        return err
    }

    // æäº¤äº‹åŠ¡
    return tx.Commit().Error
}
```

---

## äº”ã€æ•°æ®åº“è¿ç§»

### 5.1 è‡ªåŠ¨è¿ç§»

**internal/data/migrate.go**:

```go
package data

import (
    "github.com/go-kratos/kratos/v2/log"
    "github.com/go-kratos/kratos-layout/internal/model"
)

func AutoMigrate(db *gorm.DB) error {
    models := []interface{}{
        &model.User{},
        &model.UserProfile{},
        &model.Post{},
        &model.Category{},
        &model.Tag{},
        &model.Comment{},
        &model.Role{},
    }

    for _, model := range models {
        if err := db.AutoMigrate(model); err != nil {
            log.Errorf("auto migrate failed for %T: %v", model, err)
            return err
        }
    }

    log.Info("database migration completed")
    return nil
}
```

### 5.2 æ‰‹åŠ¨è¿ç§»è„šæœ¬

```go
package main

import (
    "log"
    "github.com/go-kratos/kratos-layout/internal/conf"
    "github.com/go-kratos/kratos-layout/internal/data"
)

func main() {
    // åŠ è½½é…ç½®
    c, err := conf.LoadConfig("configs/config.yaml")
    if err != nil {
        log.Fatal(err)
    }

    // åˆå§‹åŒ–æ•°æ®åº“
    db, _, err := data.NewDB(c.Data.Database)
    if err != nil {
        log.Fatal(err)
    }

    // æ‰§è¡Œè¿ç§»
    if err := data.AutoMigrate(db); err != nil {
        log.Fatal(err)
    }

    log.Println("Migration completed successfully")
}
```

### 5.3 æ•°æ®ç§å­

```go
package data

import (
    "github.com/go-kratos/kratos-layout/internal/model"
    "gorm.io/gorm"
)

func SeedDatabase(db *gorm.DB) error {
    // åˆ›å»ºé»˜è®¤è§’è‰²
    roles := []model.Role{
        {Name: "admin", Description: "Administrator"},
        {Name: "user", Description: "Regular User"},
        {Name: "moderator", Description: "Moderator"},
    }

    for _, role := range roles {
        if err := db.FirstOrCreate(&role, model.Role{Name: role.Name}).Error; err != nil {
            return err
        }
    }

    // åˆ›å»ºé»˜è®¤åˆ†ç±»
    categories := []model.Category{
        {Name: "Technology", Description: "Technology related posts"},
        {Name: "Lifestyle", Description: "Lifestyle related posts"},
        {Name: "Travel", Description: "Travel related posts"},
    }

    for _, category := range categories {
        if err := db.FirstOrCreate(&category, model.Category{Name: category.Name}).Error; err != nil {
            return err
        }
    }

    return nil
}
```

---

## å…­ã€æ€§èƒ½ä¼˜åŒ–

### 6.1 è¿æ¥æ± ä¼˜åŒ–

```go
func NewDB(c *conf.Database) (*gorm.DB, func(), error) {
    // ... è¿æ¥åˆå§‹åŒ–ä»£ç  ...

    sqlDB, err := db.DB()
    if err != nil {
        return nil, nil, err
    }

    // ç”Ÿäº§ç¯å¢ƒæ¨èé…ç½®
    sqlDB.SetMaxIdleConns(10)                  // æœ€å¤§ç©ºé—²è¿æ¥æ•°
    sqlDB.SetMaxOpenConns(100)                 // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    sqlDB.SetConnMaxLifetime(time.Hour)        // è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´
    sqlDB.SetConnMaxIdleTime(time.Hour * 2)    // ç©ºé—²è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´

    return db, func() { sqlDB.Close() }, nil
}
```

### 6.2 æŸ¥è¯¢ä¼˜åŒ–

```go
// 1. ä½¿ç”¨ç´¢å¼•
// ä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µæ·»åŠ ç´¢å¼•
type User struct {
    Email    string `gorm:"uniqueIndex"`  // å”¯ä¸€ç´¢å¼•
    Username string `gorm:"index"`        // æ™®é€šç´¢å¼•
    Status   string `gorm:"index"`        // æ™®é€šç´¢å¼•
}

// 2. é€‰æ‹©æ€§æŸ¥è¯¢
func (r *userRepo) FindByIDSelect(ctx context.Context, id uint) (*model.User, error) {
    var user model.User
    // åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
    if err := r.data.db.WithContext(ctx).
        Select("id", "username", "email", "status").
        First(&user, id).Error; err != nil {
        return nil, err
    }
    return &user, nil
}

// 3. åˆ†é¡µä¼˜åŒ–
func (r *userRepo) ListOptimized(ctx context.Context, offset, limit int) ([]*model.User, error) {
    var users []*model.User
    if err := r.data.db.WithContext(ctx).
        Select("id", "username", "email", "created_at"). // åªé€‰æ‹©éœ€è¦çš„å­—æ®µ
        Order("created_at DESC").                       // ä½¿ç”¨ç´¢å¼•å­—æ®µæ’åº
        Offset(offset).
        Limit(limit).
        Find(&users).Error; err != nil {
        return nil, err
    }
    return users, nil
}

// 4. æ‰¹é‡æ“ä½œ
func (r *userRepo) BatchCreate(ctx context.Context, users []*model.User) error {
    return r.data.db.WithContext(ctx).CreateInBatches(users, 100).Error
}
```

### 6.3 ç¼“å­˜ç­–ç•¥

```go
type CacheUserRepo struct {
    repo  biz.UserRepo
    cache *redis.Client
}

func (r *CacheUserRepo) FindByID(ctx context.Context, id uint) (*model.User, error) {
    // å…ˆä»ç¼“å­˜æŸ¥è¯¢
    cacheKey := fmt.Sprintf("user:%d", id)
    if cached, err := r.cache.Get(cacheKey).Result(); err == nil {
        var user model.User
        if err := json.Unmarshal([]byte(cached), &user); err == nil {
            return &user, nil
        }
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“æŸ¥è¯¢
    user, err := r.repo.FindByID(ctx, id)
    if err != nil {
        return nil, err
    }

    // è®¾ç½®ç¼“å­˜
    if data, err := json.Marshal(user); err == nil {
        r.cache.Set(cacheKey, data, time.Hour)
    }

    return user, nil
}
```

---

## ä¸ƒã€ç»¼åˆç¤ºä¾‹

**å®Œæ•´çš„æ•°æ®è®¿é—®å±‚ç¤ºä¾‹**:

**internal/data/post_repo.go**:

```go
package data

import (
    "context"
    "errors"

    "github.com/go-kratos/kratos/v2/log"
    "gorm.io/gorm"

    "github.com/go-kratos/kratos-layout/internal/model"
)

type postRepo struct {
    data *Data
    log  *log.Helper
}

func NewPostRepo(data *Data, logger log.Logger) biz.PostRepo {
    return &postRepo{
        data: data,
        log:  log.NewHelper(logger),
    }
}

func (r *postRepo) Create(ctx context.Context, post *model.Post) (*model.Post, error) {
    if err := r.data.db.WithContext(ctx).Create(post).Error; err != nil {
        r.log.Errorf("create post failed: %v", err)
        return nil, err
    }
    r.log.Infof("post created: %d", post.ID)
    return post, nil
}

func (r *postRepo) Update(ctx context.Context, post *model.Post) (*model.Post, error) {
    if err := r.data.db.WithContext(ctx).Save(post).Error; err != nil {
        r.log.Errorf("update post failed: %v", err)
        return nil, err
    }
    r.log.Infof("post updated: %d", post.ID)
    return post, nil
}

func (r *postRepo) Delete(ctx context.Context, id uint) error {
    if err := r.data.db.WithContext(ctx).Delete(&model.Post{}, id).Error; err != nil {
        r.log.Errorf("delete post failed: %v", err)
        return err
    }
    r.log.Infof("post deleted: %d", id)
    return nil
}

func (r *postRepo) FindByID(ctx context.Context, id uint) (*model.Post, error) {
    var post model.Post
    if err := r.data.db.WithContext(ctx).
        Preload("User").
        Preload("Category").
        Preload("Tags").
        First(&post, id).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("post not found")
        }
        r.log.Errorf("find post by id failed: %v", err)
        return nil, err
    }
    return &post, nil
}

func (r *postRepo) ListByUserID(ctx context.Context, userID uint, offset, limit int) ([]*model.Post, int64, error) {
    var posts []*model.Post
    var total int64

    query := r.data.db.WithContext(ctx).Where("user_id = ?", userID)

    if err := query.Model(&model.Post{}).Count(&total).Error; err != nil {
        r.log.Errorf("count posts failed: %v", err)
        return nil, 0, err
    }

    if err := query.Preload("Category").Preload("Tags").
        Order("created_at DESC").
        Offset(offset).Limit(limit).
        Find(&posts).Error; err != nil {
        r.log.Errorf("list posts by user failed: %v", err)
        return nil, 0, err
    }

    return posts, total, nil
}

func (r *postRepo) ListPublished(ctx context.Context, offset, limit int) ([]*model.Post, int64, error) {
    var posts []*model.Post
    var total int64

    query := r.data.db.WithContext(ctx).Where("status = ?", "published")

    if err := query.Model(&model.Post{}).Count(&total).Error; err != nil {
        r.log.Errorf("count published posts failed: %v", err)
        return nil, 0, err
    }

    if err := query.Preload("User").Preload("Category").Preload("Tags").
        Order("created_at DESC").
        Offset(offset).Limit(limit).
        Find(&posts).Error; err != nil {
        r.log.Errorf("list published posts failed: %v", err)
        return nil, 0, err
    }

    return posts, total, nil
}

func (r *postRepo) Count(ctx context.Context) (int64, error) {
    var count int64
    if err := r.data.db.WithContext(ctx).Model(&model.Post{}).Count(&count).Error; err != nil {
        r.log.Errorf("count posts failed: %v", err)
        return 0, err
    }
    return count, nil
}
```

---

## æ€»ç»“

1. **GORMé›†æˆ**ï¼šé…ç½®è¿æ¥æ± ã€æ—¥å¿—ã€è¿ç§»ç­‰
2. **æ¨¡å‹è®¾è®¡**ï¼šå®šä¹‰è¡¨ç»“æ„ã€å…³è”å…³ç³»ã€é’©å­å‡½æ•°
3. **Repositoryæ¨¡å¼**ï¼šæ¥å£å®šä¹‰å’Œå®ç°ï¼Œæ•°æ®è®¿é—®æŠ½è±¡
4. **å…³è”æŸ¥è¯¢**ï¼šé¢„åŠ è½½ã€æ¡ä»¶æŸ¥è¯¢ã€å¤æ‚æŸ¥è¯¢
5. **äº‹åŠ¡ç®¡ç†**ï¼šä¿è¯æ•°æ®ä¸€è‡´æ€§å’Œå¹¶å‘å®‰å…¨
6. **æ€§èƒ½ä¼˜åŒ–**ï¼šè¿æ¥æ± ã€æŸ¥è¯¢ä¼˜åŒ–ã€ç¼“å­˜ç­–ç•¥

**ä¸‹ä¸€æ­¥**ï¼šå­¦ä¹ [ç¬¬4è¯¾ï¼šä¸šåŠ¡é€»è¾‘å±‚](./4.Kratoså®è·µï¼šä¸šåŠ¡é€»è¾‘å±‚.md)ï¼Œäº†è§£å¦‚ä½•åœ¨Kratosä¸­ç»„ç»‡ä¸šåŠ¡é€»è¾‘ã€‚
