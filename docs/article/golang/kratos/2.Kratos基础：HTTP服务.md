---
title: 2ã€KratosåŸºç¡€ï¼šHTTPæœåŠ¡
date: 2026-01-06
description: æ·±å…¥ç†è§£Kratosæ¡†æ¶çš„HTTPæœåŠ¡å¼€å‘å’Œé…ç½®
---

# 2ã€KratosåŸºç¡€ï¼šHTTPæœåŠ¡

æœ¬æ–‡æ¡£æ·±å…¥è®²è§£Kratosæ¡†æ¶çš„HTTPæœåŠ¡å¼€å‘å’Œé…ç½®ã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡Kratosçš„HTTPæœåŠ¡åˆ›å»º
- âœ… ç†è§£è·¯ç”±é…ç½®å’Œä¸­é—´ä»¶ä½¿ç”¨
- âœ… å­¦ä¼šè¯·æ±‚å’Œå“åº”å¤„ç†
- âœ… æŒæ¡é”™è¯¯å¤„ç†æœºåˆ¶
- âœ… ç†è§£é…ç½®ç®¡ç†ç³»ç»Ÿ

---

## ä¸€ã€HTTPæœåŠ¡åˆ›å»º

### 1.1 åŸºæœ¬HTTPæœåŠ¡å™¨

```go
package server

import (
    "github.com/go-kratos/kratos/v2/transport/http"
)

func NewHttpServer(c *conf.Server) *http.Server {
    var opts = []http.ServerOption{
        http.Middleware(
            recovery.Recovery(),
            logging.Server(),
        ),
    }

    if c.Http.Addr != "" {
        opts = append(opts, http.Address(c.Http.Addr))
    }

    srv := http.NewServer(opts...)
    return srv
}
```

### 1.2 æœåŠ¡æ³¨å†Œ

```go
func (s *Server) RegisterHttpServer() {
    // æ³¨å†Œè·¯ç”±
    v1.RegisterGreeterHTTPServer(s.httpSrv, greeterService)

    // æˆ–è€…æ‰‹åŠ¨æ³¨å†Œ
    s.httpSrv.HandleFunc("/health", s.healthHandler)
}

func (s *Server) healthHandler(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("OK"))
}
```

---

## äºŒã€è·¯ç”±é…ç½®

### 2.1 Protobufè·¯ç”±å®šä¹‰

åœ¨Protobufæ–‡ä»¶ä¸­å®šä¹‰HTTPè·¯ç”±ï¼š

```protobuf
syntax = "proto3";

package api.user.v1;

import "google/api/annotations.proto";

service UserService {
  rpc CreateUser (CreateUserRequest) returns (CreateUserReply) {
    option (google.api.http) = {
      post: "/api/v1/users",
      body: "*"
    };
  }

  rpc GetUser (GetUserRequest) returns (GetUserReply) {
    option (google.api.http) = {
      get: "/api/v1/users/{id}",
    };
  }

  rpc ListUsers (ListUsersRequest) returns (ListUsersReply) {
    option (google.api.http) = {
      get: "/api/v1/users",
    };
  }

  rpc UpdateUser (UpdateUserRequest) returns (UpdateUserReply) {
    option (google.api.http) = {
      put: "/api/v1/users/{id}",
      body: "*"
    };
  }

  rpc DeleteUser (DeleteUserRequest) returns (DeleteUserReply) {
    option (google.api.http) = {
      delete: "/api/v1/users/{id}",
    };
  }
}
```

### 2.2 è·¯ç”±å‚æ•°

```protobuf
message GetUserRequest {
  string id = 1 [(google.api.field_behavior) = REQUIRED];
}

message ListUsersRequest {
  int32 page = 1;
  int32 page_size = 2;
  string keyword = 3;
}
```

### 2.3 è‡ªå®šä¹‰è·¯ç”±

```go
func RegisterCustomRoutes(s *http.Server) {
    // é™æ€æ–‡ä»¶æœåŠ¡
    s.HandlePrefix("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("./static/"))))

    // è‡ªå®šä¹‰å¤„ç†å™¨
    s.HandleFunc("/health", healthHandler)
    s.HandleFunc("/metrics", metricsHandler)
    s.HandleFunc("/debug/pprof/", pprof.Index)
}

func healthHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    w.Write([]byte(`{"status":"ok"}`))
}

func metricsHandler(w http.ResponseWriter, r *http.Request) {
    // æš´éœ²PrometheusæŒ‡æ ‡
    promhttp.Handler().ServeHTTP(w, r)
}
```

---

## ä¸‰ã€ä¸­é—´ä»¶ä½¿ç”¨

### 3.1 å†…ç½®ä¸­é—´ä»¶

```go
package server

import (
    "github.com/go-kratos/kratos/v2/middleware/logging"
    "github.com/go-kratos/kratos/v2/middleware/metrics"
    "github.com/go-kratos/kratos/v2/middleware/recovery"
    "github.com/go-kratos/kratos/v2/middleware/tracing"
    "github.com/go-kratos/kratos/v2/middleware/validate"
    "github.com/go-kratos/kratos/v2/transport/http"
)

func NewHttpServer(c *conf.Server) *http.Server {
    var opts = []http.ServerOption{
        http.Middleware(
            recovery.Recovery(),
            logging.Server(),
            metrics.Server(),
            tracing.Server(),
            validate.Validator(),
        ),
    }

    if c.Http.Addr != "" {
        opts = append(opts, http.Address(c.Http.Addr))
    }

    srv := http.NewServer(opts...)
    return srv
}
```

### 3.2 è‡ªå®šä¹‰ä¸­é—´ä»¶

#### è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶

```go
package middleware

import (
    "time"
    "github.com/go-kratos/kratos/v2/log"
    "github.com/go-kratos/kratos/v2/transport/http"
)

func LoggingMiddleware() http.ServerOption {
    return http.Middleware(func(handler http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()

            // è®°å½•è¯·æ±‚å¼€å§‹
            log.Infof("Started %s %s", r.Method, r.URL.Path)

            // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
            handler(w, r)

            // è®°å½•è¯·æ±‚ç»“æŸ
            latency := time.Since(start)
            log.Infof("Completed %s %s in %v", r.Method, r.URL.Path, latency)
        }
    })
}
```

#### CORSä¸­é—´ä»¶

```go
package middleware

import (
    "net/http"
    "strings"
    "github.com/go-kratos/kratos/v2/transport/http"
)

func CORSMiddleware() http.ServerOption {
    return http.Middleware(func(handler http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            // è®¾ç½®CORSå¤´
            w.Header().Set("Access-Control-Allow-Origin", "*")
            w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
            w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With")

            // å¤„ç†é¢„æ£€è¯·æ±‚
            if r.Method == "OPTIONS" {
                w.WriteHeader(http.StatusOK)
                return
            }

            // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
            handler(w, r)
        }
    })
}
```

#### è®¤è¯ä¸­é—´ä»¶

```go
package middleware

import (
    "context"
    "net/http"
    "strings"
    "github.com/go-kratos/kratos/v2/errors"
    "github.com/go-kratos/kratos/v2/transport/http"
)

func AuthMiddleware() http.ServerOption {
    return http.Middleware(func(handler http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            // è·å–Authorizationå¤´
            auth := r.Header.Get("Authorization")
            if auth == "" {
                http.Error(w, "Authorization header required", http.StatusUnauthorized)
                return
            }

            // è§£æBearer token
            parts := strings.SplitN(auth, " ", 2)
            if len(parts) != 2 || parts[0] != "Bearer" {
                http.Error(w, "Invalid authorization format", http.StatusUnauthorized)
                return
            }

            token := parts[1]

            // éªŒè¯tokenï¼ˆè¿™é‡Œåº”è¯¥è°ƒç”¨è®¤è¯æœåŠ¡ï¼‰
            userID, err := validateToken(token)
            if err != nil {
                http.Error(w, "Invalid token", http.StatusUnauthorized)
                return
            }

            // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚ä¸Šä¸‹æ–‡
            ctx := context.WithValue(r.Context(), "userID", userID)
            r = r.WithContext(ctx)

            // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
            handler(w, r)
        }
    })
}

func validateToken(token string) (string, error) {
    // è¿™é‡Œåº”è¯¥å®ç°çœŸæ­£çš„tokenéªŒè¯é€»è¾‘
    if token == "valid-token" {
        return "user123", nil
    }
    return "", errors.Unauthorized("auth", "invalid token")
}
```

#### é™æµä¸­é—´ä»¶

```go
package middleware

import (
    "net/http"
    "sync"
    "time"
    "github.com/go-kratos/kratos/v2/transport/http"
)

type RateLimiter struct {
    mu      sync.Mutex
    clients map[string][]time.Time
    limit   int           // æœ€å¤§è¯·æ±‚æ•°
    window  time.Duration // æ—¶é—´çª—å£
}

func NewRateLimiter(limit int, window time.Duration) *RateLimiter {
    return &RateLimiter{
        clients: make(map[string][]time.Time),
        limit:   limit,
        window:  window,
    }
}

func (rl *RateLimiter) Middleware() http.ServerOption {
    return http.Middleware(func(handler http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            // è·å–å®¢æˆ·ç«¯æ ‡è¯†ï¼ˆè¿™é‡Œä½¿ç”¨IPï¼‰
            clientIP := r.RemoteAddr

            rl.mu.Lock()
            defer rl.mu.Unlock()

            now := time.Now()

            // æ¸…ç†è¿‡æœŸè¯·æ±‚
            if requests, exists := rl.clients[clientIP]; exists {
                var valid []time.Time
                for _, reqTime := range requests {
                    if now.Sub(reqTime) < rl.window {
                        valid = append(valid, reqTime)
                    }
                }
                rl.clients[clientIP] = valid
            }

            // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
            if len(rl.clients[clientIP]) >= rl.limit {
                http.Error(w, "Too many requests", http.StatusTooManyRequests)
                return
            }

            // è®°å½•è¯·æ±‚
            rl.clients[clientIP] = append(rl.clients[clientIP], now)

            // è°ƒç”¨ä¸‹ä¸€ä¸ªå¤„ç†å™¨
            handler(w, r)
        }
    })
}
```

### 3.3 ä¸­é—´ä»¶é¡ºåº

ä¸­é—´ä»¶çš„æ‰§è¡Œé¡ºåºå¾ˆé‡è¦ï¼š

```go
srv := http.NewServer(
    http.Middleware(
        logging.Server(),     // 1. æœ€å¤–å±‚ï¼šè®°å½•è¯·æ±‚
        recovery.Recovery(),  // 2. æ¢å¤panic
        corsMiddleware(),     // 3. å¤„ç†CORS
        authMiddleware(),     // 4. è®¤è¯
        rateLimitMiddleware(), // 5. é™æµ
        validate.Validator(),  // 6. å‚æ•°éªŒè¯
    ),
)
```

---

## å››ã€è¯·æ±‚å¤„ç†

### 4.1 è·å–è¯·æ±‚æ•°æ®

```go
func (s *userService) CreateUser(ctx context.Context, req *v1.CreateUserRequest) (*v1.CreateUserReply, error) {
    // ä»contextè·å–HTTPè¯·æ±‚ä¿¡æ¯
    if httpCtx, ok := transport.FromServerContext(ctx); ok {
        // è·å–è¯·æ±‚å¤´
        userAgent := httpCtx.RequestHeader().Get("User-Agent")
        contentType := httpCtx.RequestHeader().Get("Content-Type")

        // è·å–æŸ¥è¯¢å‚æ•°
        page := httpCtx.RequestForm().Get("page")

        // è·å–å®¢æˆ·ç«¯IP
        clientIP := httpCtx.RequestHeader().Get("X-Forwarded-For")
        if clientIP == "" {
            clientIP = httpCtx.RequestHeader().Get("X-Real-IP")
        }
    }

    // å¤„ç†ä¸šåŠ¡é€»è¾‘
    user := &biz.User{
        Name:  req.Name,
        Email: req.Email,
        Age:   int(req.Age),
    }

    return s.uc.CreateUser(ctx, user)
}
```

### 4.2 è®¾ç½®å“åº”å¤´

```go
func (s *userService) GetUser(ctx context.Context, req *v1.GetUserRequest) (*v1.GetUserReply, error) {
    user, err := s.uc.GetUser(ctx, req.Id)
    if err != nil {
        return nil, err
    }

    // è®¾ç½®å“åº”å¤´
    if header, ok := transport.FromServerContext(ctx); ok {
        header.ReplyHeader().Set("X-Custom-Header", "custom-value")
        header.ReplyHeader().Set("Cache-Control", "no-cache")
    }

    return &v1.GetUserReply{
        User: &v1.User{
            Id:    user.ID,
            Name:  user.Name,
            Email: user.Email,
            Age:   int32(user.Age),
        },
    }, nil
}
```

---

## äº”ã€é”™è¯¯å¤„ç†

### 5.1 Kratosé”™è¯¯ç±»å‹

```go
import "github.com/go-kratos/kratos/v2/errors"

var (
    ErrUserNotFound    = errors.NotFound("USER_NOT_FOUND", "user not found")
    ErrInvalidArgument = errors.BadRequest("INVALID_ARGUMENT", "invalid argument")
    ErrInternalError   = errors.InternalServer("INTERNAL_ERROR", "internal server error")
    ErrUnauthorized    = errors.Unauthorized("UNAUTHORIZED", "unauthorized")
    ErrForbidden       = errors.Forbidden("FORBIDDEN", "forbidden")
)
```

### 5.2 é”™è¯¯å¤„ç†

```go
func (s *userService) GetUser(ctx context.Context, req *v1.GetUserRequest) (*v1.GetUserReply, error) {
    user, err := s.uc.GetUser(ctx, req.Id)
    if err != nil {
        // å¤„ç†ä¸åŒçš„é”™è¯¯ç±»å‹
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, ErrUserNotFound
        }
        return nil, ErrInternalError
    }

    return &v1.GetUserReply{
        User: &v1.User{
            Id:    user.ID,
            Name:  user.Name,
            Email: user.Email,
            Age:   int32(user.Age),
        },
    }, nil
}
```

### 5.3 è‡ªå®šä¹‰é”™è¯¯

```go
package errors

import "github.com/go-kratos/kratos/v2/errors"

type CustomError struct {
    *errors.Error
}

func NewCustomError(reason, message string, code int) *CustomError {
    return &CustomError{
        Error: errors.New(code, reason, message),
    }
}

func (e *CustomError) WithMetadata(key, value string) *CustomError {
    e.Error = e.Error.WithMetadata(map[string]string{key: value})
    return e
}

// é¢„å®šä¹‰é”™è¯¯
var (
    ErrEmailExists = NewCustomError("EMAIL_EXISTS", "email already exists", 409)
    ErrWeakPassword = NewCustomError("WEAK_PASSWORD", "password is too weak", 400)
)
```

### 5.4 é”™è¯¯ä¸­é—´ä»¶

```go
package middleware

import (
    "github.com/go-kratos/kratos/v2/errors"
    "github.com/go-kratos/kratos/v2/transport/http"
)

func ErrorMiddleware() http.ServerOption {
    return http.Middleware(func(handler http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
            handler(w, r)
        }
    })
}

// å…¨å±€é”™è¯¯å¤„ç†
func init() {
    // è®¾ç½®å…¨å±€é”™è¯¯ç¼–ç å™¨
    http.DefaultErrorEncoder = func(w http.ResponseWriter, r *http.Request, err error) {
        se := errors.FromError(err)
        codec, _ := http.CodecForRequest(r, "Accept")
        body, err := codec.Marshal(se)
        if err != nil {
            w.WriteHeader(500)
            return
        }
        w.Header().Set("Content-Type", codec.Name())
        w.WriteHeader(int(se.Code))
        w.Write(body)
    }
}
```

---

## å…­ã€é…ç½®ç®¡ç†

### 6.1 é…ç½®æº

Kratosæ”¯æŒå¤šç§é…ç½®æºï¼š

```go
import (
    "github.com/go-kratos/kratos/v2/config"
    "github.com/go-kratos/kratos/v2/config/env"
    "github.com/go-kratos/kratos/v2/config/file"
)

func LoadConfig() (*Config, error) {
    c := config.New(
        config.WithSource(
            // æ–‡ä»¶é…ç½®
            file.NewSource("configs/config.yaml"),
            // ç¯å¢ƒå˜é‡é…ç½®
            env.NewSource("KRATOS_"),
            // å…¶ä»–é…ç½®æº...
        ),
        // æ”¯æŒé…ç½®çƒ­é‡è½½
        config.WithDecoder(codec),
    )
    defer c.Close()

    if err := c.Load(); err != nil {
        return nil, err
    }

    var bc Config
    if err := c.Scan(&bc); err != nil {
        return nil, err
    }

    return &bc, nil
}
```

### 6.2 é…ç½®çƒ­é‡è½½

```go
func WatchConfig(c config.Config) {
    // ç›‘å¬é…ç½®å˜åŒ–
    if err := c.Watch("server.http", func(key string, value config.Value) {
        log.Infof("config changed: %s = %v", key, value)
        // é‡æ–°åŠ è½½é…ç½®
    }); err != nil {
        log.Error(err)
    }
}
```

---

## ä¸ƒã€ç»¼åˆç¤ºä¾‹

åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„ç”¨æˆ·ç®¡ç†APIï¼š

**api/user/v1/user.proto**:

```protobuf
syntax = "proto3";

package api.user.v1;

import "google/api/annotations.proto";

service UserService {
  rpc CreateUser (CreateUserRequest) returns (CreateUserReply) {
    option (google.api.http) = {
      post: "/api/v1/users",
      body: "*"
    };
  }

  rpc GetUser (GetUserRequest) returns (GetUserReply) {
    option (google.api.http) = {
      get: "/api/v1/users/{id}",
    };
  }

  rpc ListUsers (ListUsersRequest) returns (ListUsersReply) {
    option (google.api.http) = {
      get: "/api/v1/users",
    };
  }

  rpc UpdateUser (UpdateUserRequest) returns (UpdateUserReply) {
    option (google.api.http) = {
      put: "/api/v1/users/{id}",
      body: "*"
    };
  }

  rpc DeleteUser (DeleteUserRequest) returns (DeleteUserReply) {
    option (google.api.http) = {
      delete: "/api/v1/users/{id}",
    };
  }
}

message CreateUserRequest {
  string name = 1;
  string email = 2;
  int32 age = 3;
}

message CreateUserReply {
  User user = 1;
}

message GetUserRequest {
  string id = 1;
}

message GetUserReply {
  User user = 1;
}

message ListUsersRequest {
  int32 page = 1;
  int32 page_size = 2;
}

message ListUsersReply {
  repeated User users = 1;
  int32 total = 2;
}

message UpdateUserRequest {
  string id = 1;
  string name = 2;
  string email = 3;
  int32 age = 4;
}

message UpdateUserReply {
  User user = 1;
}

message DeleteUserRequest {
  string id = 1;
}

message DeleteUserReply {
  bool success = 1;
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
  int32 age = 4;
  string created_at = 5;
  string updated_at = 6;
}
```

**internal/service/user.go**:

```go
package service

import (
    "context"
    v1 "github.com/go-kratos/kratos-layout/api/user/v1"
    "github.com/go-kratos/kratos-layout/internal/biz"
)

type UserService struct {
    v1.UnimplementedUserServiceServer

    uc *biz.UserUsecase
}

func NewUserService(uc *biz.UserUsecase) *UserService {
    return &UserService{uc: uc}
}

func (s *UserService) CreateUser(ctx context.Context, req *v1.CreateUserRequest) (*v1.CreateUserReply, error) {
    user, err := s.uc.CreateUser(ctx, &biz.User{
        Name:  req.Name,
        Email: req.Email,
        Age:   int(req.Age),
    })
    if err != nil {
        return nil, err
    }

    return &v1.CreateUserReply{
        User: &v1.User{
            Id:    user.ID,
            Name:  user.Name,
            Email: user.Email,
            Age:   int32(user.Age),
        },
    }, nil
}

func (s *UserService) GetUser(ctx context.Context, req *v1.GetUserRequest) (*v1.GetUserReply, error) {
    user, err := s.uc.GetUser(ctx, req.Id)
    if err != nil {
        return nil, err
    }

    return &v1.GetUserReply{
        User: &v1.User{
            Id:    user.ID,
            Name:  user.Name,
            Email: user.Email,
            Age:   int32(user.Age),
        },
    }, nil
}

func (s *UserService) ListUsers(ctx context.Context, req *v1.ListUsersRequest) (*v1.ListUsersReply, error) {
    users, total, err := s.uc.ListUsers(ctx, int(req.Page), int(req.PageSize))
    if err != nil {
        return nil, err
    }

    var userList []*v1.User
    for _, user := range users {
        userList = append(userList, &v1.User{
            Id:    user.ID,
            Name:  user.Name,
            Email: user.Email,
            Age:   int32(user.Age),
        })
    }

    return &v1.ListUsersReply{
        Users: userList,
        Total: int32(total),
    }, nil
}

func (s *UserService) UpdateUser(ctx context.Context, req *v1.UpdateUserRequest) (*v1.UpdateUserReply, error) {
    user, err := s.uc.UpdateUser(ctx, req.Id, &biz.User{
        Name:  req.Name,
        Email: req.Email,
        Age:   int(req.Age),
    })
    if err != nil {
        return nil, err
    }

    return &v1.UpdateUserReply{
        User: &v1.User{
            Id:    user.ID,
            Name:  user.Name,
            Email: user.Email,
            Age:   int32(user.Age),
        },
    }, nil
}

func (s *UserService) DeleteUser(ctx context.Context, req *v1.DeleteUserRequest) (*v1.DeleteUserReply, error) {
    success, err := s.uc.DeleteUser(ctx, req.Id)
    if err != nil {
        return nil, err
    }

    return &v1.DeleteUserReply{Success: success}, nil
}
```

---

## æ€»ç»“

1. **HTTPæœåŠ¡**ï¼šä½¿ç”¨`http.NewServer()`åˆ›å»ºï¼Œæ”¯æŒå¤šç§é…ç½®
2. **è·¯ç”±é…ç½®**ï¼šé€šè¿‡Protobufæ³¨è§£å®šä¹‰HTTPè·¯ç”±
3. **ä¸­é—´ä»¶**ï¼šæ”¯æŒå†…ç½®å’Œè‡ªå®šä¹‰ä¸­é—´ä»¶ï¼Œæ§åˆ¶æ‰§è¡Œé¡ºåº
4. **è¯·æ±‚å¤„ç†**ï¼šä»contextè·å–è¯·æ±‚ä¿¡æ¯ï¼Œè®¾ç½®å“åº”å¤´
5. **é”™è¯¯å¤„ç†**ï¼šä½¿ç”¨Kratosé”™è¯¯ç±»å‹ï¼Œç»Ÿä¸€çš„é”™è¯¯å“åº”
6. **é…ç½®ç®¡ç†**ï¼šæ”¯æŒå¤šç§é…ç½®æºå’Œçƒ­é‡è½½

**ä¸‹ä¸€æ­¥**ï¼šå­¦ä¹ [ç¬¬3è¯¾ï¼šæ•°æ®è®¿é—®å±‚](./3.Kratosè¿›é˜¶ï¼šæ•°æ®è®¿é—®å±‚.md)ï¼Œæ·±å…¥äº†è§£GORMåœ¨Kratosä¸­çš„é›†æˆã€‚
