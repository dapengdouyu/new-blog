---
title: 4ã€Kratoså®è·µï¼šä¸šåŠ¡é€»è¾‘å±‚
date: 2026-01-06
description: æŒæ¡Kratosæ¡†æ¶çš„ä¸šåŠ¡é€»è¾‘å±‚è®¾è®¡å’Œå®ç°
---

# 4ã€Kratoså®è·µï¼šä¸šåŠ¡é€»è¾‘å±‚

æœ¬æ–‡æ¡£æ·±å…¥è®²è§£Kratosæ¡†æ¶ä¸­ä¸šåŠ¡é€»è¾‘å±‚çš„ç»„ç»‡å’Œå®ç°æ¨¡å¼ã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… ç†è§£Use Caseæ¨¡å¼åœ¨Kratosä¸­çš„åº”ç”¨
- âœ… æŒæ¡ä¸šåŠ¡é€»è¾‘çš„å°è£…å’Œç»„ç»‡
- âœ… å®ç°ä¾èµ–æ³¨å…¥å’Œæ¥å£è®¾è®¡
- âœ… æŒæ¡æ•°æ®éªŒè¯å’Œä¸šåŠ¡è§„åˆ™
- âœ… ç†è§£é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- âœ… å®ç°ä¸šåŠ¡äº‹åŠ¡ç®¡ç†

---

## ä¸€ã€ä¸šåŠ¡é€»è¾‘å±‚æ¶æ„

### 1.1 æ¸…æ™°æ¶æ„ï¼ˆClean Architectureï¼‰

Kratosæ¨èä½¿ç”¨æ¸…æ™°æ¶æ„ï¼ˆClean Architectureï¼‰æ¥ç»„ç»‡ä¸šåŠ¡é€»è¾‘ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Delivery Layer              â”‚  â† Controllers
â”‚  â”œâ”€ HTTP Handlers                   â”‚
â”‚  â”œâ”€ gRPC Handlers                   â”‚
â”‚  â””â”€ Message Queue Handlers          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Use Case Layer              â”‚  â† Business Logic
â”‚  â”œâ”€ Use Cases (Business Rules)      â”‚
â”‚  â”œâ”€ Application Services            â”‚
â”‚  â””â”€ Domain Services                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Repository Layer            â”‚  â† Data Access
â”‚  â”œâ”€ Repository Interfaces           â”‚
â”‚  â”œâ”€ Repository Implementations      â”‚
â”‚  â””â”€ Data Models                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Infrastructure Layer        â”‚  â† External Services
â”‚  â”œâ”€ Database                        â”‚
â”‚  â”œâ”€ Cache                           â”‚
â”‚  â”œâ”€ Message Queue                   â”‚
â”‚  â””â”€ External APIs                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Use Caseæ¨¡å¼

Use Caseä»£è¡¨å…·ä½“çš„ä¸šåŠ¡ç”¨ä¾‹ï¼Œæ¯ä¸ªUse Caseå°è£…äº†ä¸€ä¸ªå®Œæ•´çš„ä¸šåŠ¡æµç¨‹ï¼š

```go
// internal/biz/user.go
package biz

import (
    "context"
    "crypto/rand"
    "encoding/hex"
    "errors"
    "time"

    "github.com/go-kratos/kratos/v2/log"
    "github.com/go-kratos/kratos-layout/internal/model"
    v1 "github.com/go-kratos/kratos-layout/api/user/v1"
)

type UserUsecase struct {
    userRepo UserRepo
    log      *log.Helper
}

func NewUserUsecase(repo UserRepo, logger log.Logger) *UserUsecase {
    return &UserUsecase{
        userRepo: repo,
        log:      log.NewHelper(logger),
    }
}

// RegisterUser ç”¨æˆ·æ³¨å†Œ
func (uc *UserUsecase) RegisterUser(ctx context.Context, req *v1.RegisterUserRequest) (*v1.RegisterUserReply, error) {
    // 1. éªŒè¯è¾“å…¥
    if err := uc.validateRegisterRequest(req); err != nil {
        return nil, err
    }

    // 2. æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    if existing, _ := uc.userRepo.FindByUsername(ctx, req.Username); existing != nil {
        return nil, NewError(ErrUserExists, "username already exists")
    }

    // 3. æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    if existing, _ := uc.userRepo.FindByEmail(ctx, req.Email); existing != nil {
        return nil, NewError(ErrEmailExists, "email already exists")
    }

    // 4. åˆ›å»ºç”¨æˆ·
    user := &model.User{
        Username: req.Username,
        Email:    req.Email,
        Password: req.Password, // å¯†ç ä¼šåœ¨Repositoryå±‚åŠ å¯†
        Status:   "active",
    }

    createdUser, err := uc.userRepo.Create(ctx, user)
    if err != nil {
        uc.log.Errorf("create user failed: %v", err)
        return nil, NewError(ErrInternalError, "failed to create user")
    }

    // 5. åˆ›å»ºç”¨æˆ·èµ„æ–™
    profile := &model.UserProfile{
        UserID: createdUser.ID,
        Bio:    req.Bio,
    }

    if _, err := uc.userRepo.CreateProfile(ctx, profile); err != nil {
        uc.log.Errorf("create user profile failed: %v", err)
        // æ³¨æ„ï¼šè¿™é‡Œå¯ä»¥é€‰æ‹©å›æ»šç”¨æˆ·åˆ›å»ºï¼Œæˆ–è€…ç»§ç»­
    }

    uc.log.Infof("user registered successfully: %s", createdUser.Username)

    return &v1.RegisterUserReply{
        User: &v1.User{
            Id:       uint64(createdUser.ID),
            Username: createdUser.Username,
            Email:    createdUser.Email,
            Status:   createdUser.Status,
        },
    }, nil
}

// LoginUser ç”¨æˆ·ç™»å½•
func (uc *UserUsecase) LoginUser(ctx context.Context, req *v1.LoginUserRequest) (*v1.LoginUserReply, error) {
    // 1. æŸ¥æ‰¾ç”¨æˆ·
    user, err := uc.userRepo.FindByUsername(ctx, req.Username)
    if err != nil {
        return nil, NewError(ErrUserNotFound, "user not found")
    }
    if user == nil {
        return nil, NewError(ErrInvalidCredentials, "invalid credentials")
    }

    // 2. éªŒè¯å¯†ç 
    if !uc.verifyPassword(user.Password, req.Password) {
        return nil, NewError(ErrInvalidCredentials, "invalid credentials")
    }

    // 3. æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    if user.Status != "active" {
        return nil, NewError(ErrUserInactive, "user account is not active")
    }

    // 4. ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
    token, err := uc.generateAccessToken(user.ID)
    if err != nil {
        uc.log.Errorf("generate access token failed: %v", err)
        return nil, NewError(ErrInternalError, "failed to generate token")
    }

    // 5. æ›´æ–°æœ€åç™»å½•æ—¶é—´
    now := time.Now()
    user.LastLogin = &now
    if _, err := uc.userRepo.Update(ctx, user); err != nil {
        uc.log.Warnf("update last login failed: %v", err)
        // ä¸å½±å“ç™»å½•æˆåŠŸ
    }

    uc.log.Infof("user logged in: %s", user.Username)

    return &v1.LoginUserReply{
        Token: token,
        User: &v1.User{
            Id:       uint64(user.ID),
            Username: user.Username,
            Email:    user.Email,
            Status:   user.Status,
        },
    }, nil
}

// GetUserProfile è·å–ç”¨æˆ·èµ„æ–™
func (uc *UserUsecase) GetUserProfile(ctx context.Context, userID uint) (*v1.GetUserProfileReply, error) {
    // 1. è·å–ç”¨æˆ·ä¿¡æ¯ï¼ˆåŒ…å«èµ„æ–™ï¼‰
    user, err := uc.userRepo.FindByIDWithProfile(ctx, userID)
    if err != nil {
        return nil, NewError(ErrUserNotFound, "user not found")
    }

    // 2. æ£€æŸ¥æƒé™ï¼ˆç”¨æˆ·åªèƒ½æŸ¥çœ‹è‡ªå·±çš„èµ„æ–™æˆ–ç®¡ç†å‘˜ï¼‰
    currentUserID := getCurrentUserID(ctx) // ä»ä¸Šä¸‹æ–‡è·å–å½“å‰ç”¨æˆ·ID
    if currentUserID != userID && !isAdmin(ctx) {
        return nil, NewError(ErrForbidden, "access denied")
    }

    return &v1.GetUserProfileReply{
        Profile: &v1.UserProfile{
            UserId:      uint64(user.ID),
            Username:    user.Username,
            Email:       user.Email,
            FirstName:   user.FirstName,
            LastName:    user.LastName,
            Bio:         user.Profile.Bio,
            Avatar:      user.Profile.Avatar,
            Website:     user.Profile.Website,
            Location:    user.Profile.Location,
            Company:     user.Profile.Company,
            PhoneNumber: user.Profile.PhoneNumber,
        },
    }, nil
}

// UpdateUserProfile æ›´æ–°ç”¨æˆ·èµ„æ–™
func (uc *UserUsecase) UpdateUserProfile(ctx context.Context, userID uint, req *v1.UpdateUserProfileRequest) (*v1.UpdateUserProfileReply, error) {
    // 1. æ£€æŸ¥æƒé™
    currentUserID := getCurrentUserID(ctx)
    if currentUserID != userID && !isAdmin(ctx) {
        return nil, NewError(ErrForbidden, "access denied")
    }

    // 2. è·å–ç°æœ‰ç”¨æˆ·èµ„æ–™
    user, err := uc.userRepo.FindByIDWithProfile(ctx, userID)
    if err != nil {
        return nil, NewError(ErrUserNotFound, "user not found")
    }

    // 3. æ›´æ–°ç”¨æˆ·ä¿¡æ¯
    if req.FirstName != "" {
        user.FirstName = req.FirstName
    }
    if req.LastName != "" {
        user.LastName = req.LastName
    }

    // 4. æ›´æ–°æˆ–åˆ›å»ºèµ„æ–™
    if user.Profile == nil {
        user.Profile = &model.UserProfile{UserID: userID}
    }

    profile := user.Profile
    if req.Bio != "" {
        profile.Bio = req.Bio
    }
    if req.Avatar != "" {
        profile.Avatar = req.Avatar
    }
    if req.Website != "" {
        profile.Website = req.Website
    }
    if req.Location != "" {
        profile.Location = req.Location
    }
    if req.Company != "" {
        profile.Company = req.Company
    }
    if req.PhoneNumber != "" {
        profile.PhoneNumber = req.PhoneNumber
    }

    // 5. ä¿å­˜æ›´æ”¹
    if err := uc.userRepo.UpdateWithProfile(ctx, user, profile); err != nil {
        uc.log.Errorf("update user profile failed: %v", err)
        return nil, NewError(ErrInternalError, "failed to update profile")
    }

    uc.log.Infof("user profile updated: %d", userID)

    return &v1.UpdateUserProfileReply{
        Success: true,
    }, nil
}
```

### 1.3 ä¸šåŠ¡è§„åˆ™éªŒè¯

```go
// internal/biz/user_validation.go
package biz

import (
    "errors"
    "regexp"
    "strings"
    v1 "github.com/go-kratos/kratos-layout/api/user/v1"
)

var (
    usernameRegex = regexp.MustCompile(`^[a-zA-Z0-9_]{3,20}$`)
    emailRegex    = regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    passwordRegex = regexp.MustCompile(`^.{8,}$`)
)

func (uc *UserUsecase) validateRegisterRequest(req *v1.RegisterUserRequest) error {
    // éªŒè¯ç”¨æˆ·å
    if req.Username == "" {
        return errors.New("username is required")
    }
    if !usernameRegex.MatchString(req.Username) {
        return errors.New("username must be 3-20 characters, containing only letters, numbers, and underscores")
    }

    // éªŒè¯é‚®ç®±
    if req.Email == "" {
        return errors.New("email is required")
    }
    req.Email = strings.ToLower(strings.TrimSpace(req.Email))
    if !emailRegex.MatchString(req.Email) {
        return errors.New("invalid email format")
    }

    // éªŒè¯å¯†ç 
    if req.Password == "" {
        return errors.New("password is required")
    }
    if !passwordRegex.MatchString(req.Password) {
        return errors.New("password must be at least 8 characters")
    }

    // éªŒè¯å¯†ç å¼ºåº¦
    if !uc.isPasswordStrong(req.Password) {
        return errors.New("password must contain at least one uppercase letter, one lowercase letter, and one number")
    }

    return nil
}

func (uc *UserUsecase) isPasswordStrong(password string) bool {
    hasUpper := strings.ContainsAny(password, "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    hasLower := strings.ContainsAny(password, "abcdefghijklmnopqrstuvwxyz")
    hasNumber := strings.ContainsAny(password, "0123456789")
    return hasUpper && hasLower && hasNumber
}

func (uc *UserUsecase) validateLoginRequest(req *v1.LoginUserRequest) error {
    if req.Username == "" {
        return errors.New("username is required")
    }
    if req.Password == "" {
        return errors.New("password is required")
    }
    return nil
}
```

---

## äºŒã€ä¾èµ–æ³¨å…¥å’Œæ¥å£è®¾è®¡

### 2.1 æ¥å£å®šä¹‰

```go
// internal/biz/biz.go
package biz

import (
    "context"
    "github.com/go-kratos/kratos-layout/internal/model"
    v1 "github.com/go-kratos/kratos-layout/api/user/v1"
)

// UserUsecaseInterface ç”¨æˆ·ä¸šåŠ¡é€»è¾‘æ¥å£
type UserUsecaseInterface interface {
    RegisterUser(ctx context.Context, req *v1.RegisterUserRequest) (*v1.RegisterUserReply, error)
    LoginUser(ctx context.Context, req *v1.LoginUserRequest) (*v1.LoginUserReply, error)
    GetUserProfile(ctx context.Context, userID uint) (*v1.GetUserProfileReply, error)
    UpdateUserProfile(ctx context.Context, userID uint, req *v1.UpdateUserProfileRequest) (*v1.UpdateUserProfileReply, error)
    ChangePassword(ctx context.Context, userID uint, req *v1.ChangePasswordRequest) (*v1.ChangePasswordReply, error)
    DeactivateUser(ctx context.Context, userID uint) error
}

// AuthUsecaseInterface è®¤è¯ä¸šåŠ¡é€»è¾‘æ¥å£
type AuthUsecaseInterface interface {
    ValidateToken(ctx context.Context, token string) (*model.User, error)
    RefreshToken(ctx context.Context, refreshToken string) (*v1.RefreshTokenReply, error)
    Logout(ctx context.Context, token string) error
}

// PostUsecaseInterface æ–‡ç« ä¸šåŠ¡é€»è¾‘æ¥å£
type PostUsecaseInterface interface {
    CreatePost(ctx context.Context, userID uint, req *v1.CreatePostRequest) (*v1.CreatePostReply, error)
    UpdatePost(ctx context.Context, userID uint, postID uint, req *v1.UpdatePostRequest) (*v1.UpdatePostReply, error)
    DeletePost(ctx context.Context, userID uint, postID uint) error
    GetPost(ctx context.Context, postID uint) (*v1.GetPostReply, error)
    ListPosts(ctx context.Context, req *v1.ListPostsRequest) (*v1.ListPostsReply, error)
    PublishPost(ctx context.Context, userID uint, postID uint) error
}
```

### 2.2 Wireä¾èµ–æ³¨å…¥

```go
// cmd/server/wire.go
//go:build wireinject
// +build wireinject

package main

import (
    "github.com/go-kratos/kratos/v2"
    "github.com/go-kratos/kratos/v2/log"
    "github.com/go-kratos/kratos-layout/internal/biz"
    "github.com/go-kratos/kratos-layout/internal/conf"
    "github.com/go-kratos/kratos-layout/internal/data"
    "github.com/go-kratos/kratos-layout/internal/server"
    "github.com/go-kratos/kratos-layout/internal/service"
    "github.com/google/wire"
)

func initApp(*conf.Server, *conf.Data, log.Logger) (*kratos.App, func(), error) {
    panic(wire.Build(server.ProviderSet, data.ProviderSet, biz.ProviderSet, service.ProviderSet, newApp))
}

// internal/biz/wire.go
var ProviderSet = wire.NewSet(
    NewUserUsecase,
    NewAuthUsecase,
    NewPostUsecase,
    // å…¶ä»–Use Case
)
```

### 2.3 Use Caseå·¥å‚æ¨¡å¼

```go
// internal/biz/factory.go
package biz

import (
    "sync"
    "github.com/go-kratos/kratos/v2/log"
)

// UsecaseFactory Use Caseå·¥å‚
type UsecaseFactory struct {
    mu sync.RWMutex

    userUsecase UserUsecaseInterface
    authUsecase AuthUsecaseInterface
    postUsecase PostUsecaseInterface
}

func NewUsecaseFactory(
    userRepo UserRepo,
    authRepo AuthRepo,
    postRepo PostRepo,
    logger log.Logger,
) *UsecaseFactory {
    return &UsecaseFactory{
        userUsecase: NewUserUsecase(userRepo, logger),
        authUsecase: NewAuthUsecase(authRepo, logger),
        postUsecase: NewPostUsecase(postRepo, logger),
    }
}

func (f *UsecaseFactory) UserUsecase() UserUsecaseInterface {
    f.mu.RLock()
    defer f.mu.RUnlock()
    return f.userUsecase
}

func (f *UsecaseFactory) AuthUsecase() AuthUsecaseInterface {
    f.mu.RLock()
    defer f.mu.RUnlock()
    return f.authUsecase
}

func (f *UsecaseFactory) PostUsecase() PostUsecaseInterface {
    f.mu.RLock()
    defer f.mu.RUnlock()
    return f.postUsecase
}
```

---

## ä¸‰ã€ä¸šåŠ¡äº‹åŠ¡ç®¡ç†

### 3.1 äº‹åŠ¡Use Case

```go
// internal/biz/user_transaction.go
package biz

import (
    "context"
    "database/sql"
    "github.com/go-kratos/kratos/v2/log"
)

type TransactionalUserUsecase struct {
    *UserUsecase
    txRepo TransactionRepo
}

func NewTransactionalUserUsecase(uc *UserUsecase, txRepo TransactionRepo) *TransactionalUserUsecase {
    return &TransactionalUserUsecase{
        UserUsecase: uc,
        txRepo:      txRepo,
    }
}

// TransactionalRegisterUser äº‹åŠ¡æ€§ç”¨æˆ·æ³¨å†Œ
func (uc *TransactionalUserUsecase) TransactionalRegisterUser(ctx context.Context, req *v1.RegisterUserRequest) (*v1.RegisterUserReply, error) {
    return uc.txRepo.WithTransaction(ctx, func(ctx context.Context) (*v1.RegisterUserReply, error) {
        // åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œæ³¨å†Œé€»è¾‘
        return uc.UserUsecase.RegisterUser(ctx, req)
    })
}

// TransferPoints ç§¯åˆ†è½¬è´¦ï¼ˆéœ€è¦äº‹åŠ¡ä¿è¯åŸå­æ€§ï¼‰
func (uc *TransactionalUserUsecase) TransferPoints(ctx context.Context, fromUserID, toUserID uint, points int) error {
    return uc.txRepo.WithTransaction(ctx, func(ctx context.Context) error {
        // 1. æ£€æŸ¥å‘é€è€…ç§¯åˆ†æ˜¯å¦è¶³å¤Ÿ
        fromUser, err := uc.userRepo.FindByID(ctx, fromUserID)
        if err != nil {
            return err
        }
        if fromUser.Points < points {
            return NewError(ErrInsufficientPoints, "insufficient points")
        }

        // 2. æ£€æŸ¥æ¥æ”¶è€…æ˜¯å¦å­˜åœ¨
        _, err = uc.userRepo.FindByID(ctx, toUserID)
        if err != nil {
            return NewError(ErrUserNotFound, "recipient not found")
        }

        // 3. æ‰§è¡Œè½¬è´¦
        if err := uc.txRepo.TransferPoints(ctx, fromUserID, toUserID, points); err != nil {
            uc.log.Errorf("transfer points failed: %v", err)
            return NewError(ErrInternalError, "transfer failed")
        }

        uc.log.Infof("points transferred: %d -> %d (%d points)", fromUserID, toUserID, points)
        return nil
    })
}
```

### 3.2 äº‹åŠ¡Repositoryæ¥å£

```go
// internal/biz/transaction.go
package biz

import "context"

// TransactionRepo äº‹åŠ¡Repositoryæ¥å£
type TransactionRepo interface {
    WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error
    WithTransactionResult(ctx context.Context, fn func(ctx context.Context) (interface{}, error)) (interface{}, error)
    TransferPoints(ctx context.Context, fromUserID, toUserID uint, points int) error
}
```

### 3.3 äº‹åŠ¡Repositoryå®ç°

```go
// internal/data/transaction.go
package data

import (
    "context"
    "github.com/go-kratos/kratos/v2/log"
    "gorm.io/gorm"
)

type transactionRepo struct {
    data *Data
    log  *log.Helper
}

func NewTransactionRepo(data *Data, logger log.Logger) biz.TransactionRepo {
    return &transactionRepo{
        data: data,
        log:  log.NewHelper(logger),
    }
}

func (r *transactionRepo) WithTransaction(ctx context.Context, fn func(ctx context.Context) error) error {
    return r.data.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        // åˆ›å»ºäº‹åŠ¡ä¸Šä¸‹æ–‡
        txCtx := context.WithValue(ctx, "tx", tx)
        return fn(txCtx)
    })
}

func (r *transactionRepo) WithTransactionResult(ctx context.Context, fn func(ctx context.Context) (interface{}, error)) (interface{}, error) {
    var result interface{}
    err := r.data.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        txCtx := context.WithValue(ctx, "tx", tx)
        var err error
        result, err = fn(txCtx)
        return err
    })
    return result, err
}

func (r *transactionRepo) TransferPoints(ctx context.Context, fromUserID, toUserID uint, points int) error {
    // è·å–äº‹åŠ¡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    tx, ok := ctx.Value("tx").(*gorm.DB)
    if !ok {
        tx = r.data.db.WithContext(ctx)
    }

    // æ‰£é™¤å‘é€è€…ç§¯åˆ†
    if err := tx.Model(&model.User{}).Where("id = ? AND points >= ?", fromUserID, points).
        UpdateColumn("points", gorm.Expr("points - ?", points)).Error; err != nil {
        if err == gorm.ErrRecordNotFound {
            return errors.New("insufficient points")
        }
        return err
    }

    // å¢åŠ æ¥æ”¶è€…ç§¯åˆ†
    if err := tx.Model(&model.User{}).Where("id = ?", toUserID).
        UpdateColumn("points", gorm.Expr("points + ?", points)).Error; err != nil {
        return err
    }

    return nil
}
```

---

## å››ã€é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•

### 4.1 ä¸šåŠ¡é”™è¯¯å®šä¹‰

```go
// internal/biz/errors.go
package biz

import "github.com/go-kratos/kratos/v2/errors"

// ä¸šåŠ¡é”™è¯¯ç 
var (
    // ç”¨æˆ·ç›¸å…³é”™è¯¯
    ErrUserNotFound       = errors.NotFound("USER_NOT_FOUND", "user not found")
    ErrUserExists         = errors.Conflict("USER_EXISTS", "user already exists")
    ErrEmailExists        = errors.Conflict("EMAIL_EXISTS", "email already exists")
    ErrUsernameExists     = errors.Conflict("USERNAME_EXISTS", "username already exists")
    ErrInvalidCredentials = errors.Unauthorized("INVALID_CREDENTIALS", "invalid credentials")
    ErrUserInactive       = errors.Forbidden("USER_INACTIVE", "user account is not active")

    // æƒé™ç›¸å…³é”™è¯¯
    ErrForbidden          = errors.Forbidden("FORBIDDEN", "access denied")
    ErrUnauthorized       = errors.Unauthorized("UNAUTHORIZED", "unauthorized")

    // èµ„æºç›¸å…³é”™è¯¯
    ErrPostNotFound       = errors.NotFound("POST_NOT_FOUND", "post not found")
    ErrCategoryNotFound   = errors.NotFound("CATEGORY_NOT_FOUND", "category not found")

    // ä¸šåŠ¡é€»è¾‘é”™è¯¯
    ErrInsufficientPoints = errors.BadRequest("INSUFFICIENT_POINTS", "insufficient points")
    ErrInvalidStatus      = errors.BadRequest("INVALID_STATUS", "invalid status")

    // ç³»ç»Ÿé”™è¯¯
    ErrInternalError      = errors.InternalServer("INTERNAL_ERROR", "internal server error")
)

// NewError åˆ›å»ºä¸šåŠ¡é”™è¯¯
func NewError(err *errors.Error, message string) error {
    return err
}
```

### 4.2 ç»“æ„åŒ–æ—¥å¿—è®°å½•

```go
// internal/biz/user_logging.go
package biz

import (
    "context"
    "github.com/go-kratos/kratos/v2/log"
)

func (uc *UserUsecase) logUserAction(ctx context.Context, action string, userID uint, details map[string]interface{}) {
    fields := []log.Field{
        log.String("action", action),
        log.Uint("user_id", userID),
    }

    for key, value := range details {
        switch v := value.(type) {
        case string:
            fields = append(fields, log.String(key, v))
        case int:
            fields = append(fields, log.Int(key, v))
        case bool:
            fields = append(fields, log.Bool(key, v))
        default:
            fields = append(fields, log.Any(key, v))
        }
    }

    uc.log.WithContext(ctx).Info("user action", fields...)
}

func (uc *UserUsecase) logBusinessError(ctx context.Context, operation string, err error, userID uint) {
    uc.log.WithContext(ctx).Errorw(
        "business error",
        "operation", operation,
        "user_id", userID,
        "error", err.Error(),
    )
}

func (uc *UserUsecase) logSecurityEvent(ctx context.Context, event string, userID uint, details map[string]interface{}) {
    fields := []log.Field{
        log.String("event", event),
        log.Uint("user_id", userID),
        log.String("level", "security"),
    }

    for key, value := range details {
        fields = append(fields, log.Any(key, value))
    }

    uc.log.WithContext(ctx).Warn("security event", fields...)
}
```

### 4.3 ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§

```go
// internal/biz/metrics.go
package biz

import (
    "time"
    "github.com/go-kratos/kratos/v2/metrics"
)

type UserMetrics struct {
    registerCounter    metrics.Counter
    loginCounter       metrics.Counter
    registerDuration   metrics.Histogram
    loginDuration      metrics.Histogram
    activeUsersGauge   metrics.Gauge
}

func NewUserMetrics() *UserMetrics {
    return &UserMetrics{
        registerCounter: metrics.NewCounter("user_register_total"),
        loginCounter:    metrics.NewCounter("user_login_total"),
        registerDuration: metrics.NewHistogram("user_register_duration_seconds"),
        loginDuration:   metrics.NewHistogram("user_login_duration_seconds"),
        activeUsersGauge: metrics.NewGauge("user_active_total"),
    }
}

func (m *UserMetrics) RecordRegister(duration time.Duration, success bool) {
    m.registerCounter.With("success", success).Inc()
    m.registerDuration.With("success", success).Observe(duration.Seconds())
}

func (m *UserMetrics) RecordLogin(duration time.Duration, success bool) {
    m.loginCounter.With("success", success).Inc()
    m.loginDuration.With("success", success).Observe(duration.Seconds())
}

func (m *UserMetrics) SetActiveUsers(count int64) {
    m.activeUsersGauge.Set(float64(count))
}
```

---

## äº”ã€æ•°æ®éªŒè¯

### 5.1 è¯·æ±‚éªŒè¯

```go
// internal/biz/validation.go
package biz

import (
    "github.com/go-playground/validator/v10"
    v1 "github.com/go-kratos/kratos-layout/api/user/v1"
)

var validate *validator.Validate

func init() {
    validate = validator.New()

    // æ³¨å†Œè‡ªå®šä¹‰éªŒè¯
    validate.RegisterValidation("strong_password", validateStrongPassword)
    validate.RegisterValidation("username", validateUsername)
}

func validateStrongPassword(fl validator.FieldLevel) bool {
    password := fl.Field().String()
    // è‡³å°‘8ä½ï¼ŒåŒ…å«å¤§å°å†™å­—æ¯å’Œæ•°å­—
    if len(password) < 8 {
        return false
    }

    hasUpper := false
    hasLower := false
    hasNumber := false

    for _, char := range password {
        switch {
        case char >= 'A' && char <= 'Z':
            hasUpper = true
        case char >= 'a' && char <= 'z':
            hasLower = true
        case char >= '0' && char <= '9':
            hasNumber = true
        }
    }

    return hasUpper && hasLower && hasNumber
}

func validateUsername(fl validator.FieldLevel) bool {
    username := fl.Field().String()
    // 3-20ä½å­—æ¯æ•°å­—ä¸‹åˆ’çº¿
    if len(username) < 3 || len(username) > 20 {
        return false
    }

    for _, char := range username {
        if !((char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') ||
             (char >= '0' && char <= '9') || char == '_') {
            return false
        }
    }

    return true
}

// ValidateRegisterRequest éªŒè¯æ³¨å†Œè¯·æ±‚
func ValidateRegisterRequest(req *v1.RegisterUserRequest) error {
    return validate.Struct(req)
}

// ValidateLoginRequest éªŒè¯ç™»å½•è¯·æ±‚
func ValidateLoginRequest(req *v1.LoginUserRequest) error {
    return validate.Struct(req)
}

// ValidateUpdateProfileRequest éªŒè¯æ›´æ–°èµ„æ–™è¯·æ±‚
func ValidateUpdateProfileRequest(req *v1.UpdateUserProfileRequest) error {
    return validate.Struct(req)
}
```

### 5.2 ä¸šåŠ¡è§„åˆ™éªŒè¯

```go
// internal/biz/business_validation.go
package biz

import (
    "context"
    "errors"
    "strings"
    v1 "github.com/go-kratos/kratos-layout/api/user/v1"
)

type BusinessValidator struct {
    userRepo UserRepo
}

func NewBusinessValidator(userRepo UserRepo) *BusinessValidator {
    return &BusinessValidator{userRepo: userRepo}
}

// ValidateUserRegistration éªŒè¯ç”¨æˆ·æ³¨å†Œä¸šåŠ¡è§„åˆ™
func (v *BusinessValidator) ValidateUserRegistration(ctx context.Context, req *v1.RegisterUserRequest) error {
    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²è¢«ä½¿ç”¨
    if existing, _ := v.userRepo.FindByUsername(ctx, req.Username); existing != nil {
        return NewError(ErrUsernameExists, "username already exists")
    }

    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²è¢«ä½¿ç”¨
    if existing, _ := v.userRepo.FindByEmail(ctx, req.Email); existing != nil {
        return NewError(ErrEmailExists, "email already exists")
    }

    // æ£€æŸ¥é‚®ç®±åŸŸåæ˜¯å¦è¢«ç¦æ­¢
    if v.isEmailDomainBlocked(req.Email) {
        return NewError(ErrInvalidArgument, "email domain is not allowed")
    }

    return nil
}

// ValidateUserUpdate éªŒè¯ç”¨æˆ·æ›´æ–°ä¸šåŠ¡è§„åˆ™
func (v *BusinessValidator) ValidateUserUpdate(ctx context.Context, userID uint, req *v1.UpdateUserRequest) error {
    // å¦‚æœæ›´æ–°é‚®ç®±ï¼Œæ£€æŸ¥æ˜¯å¦å·²è¢«å…¶ä»–ç”¨æˆ·ä½¿ç”¨
    if req.Email != "" {
        if existing, _ := v.userRepo.FindByEmail(ctx, req.Email); existing != nil && existing.ID != userID {
            return NewError(ErrEmailExists, "email already exists")
        }
    }

    // å¦‚æœæ›´æ–°ç”¨æˆ·åï¼Œæ£€æŸ¥æ˜¯å¦å·²è¢«å…¶ä»–ç”¨æˆ·ä½¿ç”¨
    if req.Username != "" {
        if existing, _ := v.userRepo.FindByUsername(ctx, req.Username); existing != nil && existing.ID != userID {
            return NewError(ErrUsernameExists, "username already exists")
        }
    }

    return nil
}

// ValidatePostCreation éªŒè¯æ–‡ç« åˆ›å»ºä¸šåŠ¡è§„åˆ™
func (v *BusinessValidator) ValidatePostCreation(ctx context.Context, req *v1.CreatePostRequest) error {
    // æ£€æŸ¥æ ‡é¢˜é•¿åº¦
    if len(strings.TrimSpace(req.Title)) < 5 {
        return NewError(ErrInvalidArgument, "title must be at least 5 characters")
    }

    // æ£€æŸ¥å†…å®¹é•¿åº¦
    if len(strings.TrimSpace(req.Content)) < 10 {
        return NewError(ErrInvalidArgument, "content must be at least 10 characters")
    }

    // æ£€æŸ¥åˆ†ç±»æ˜¯å¦å­˜åœ¨
    if req.CategoryId > 0 {
        // è¿™é‡Œåº”è¯¥æ£€æŸ¥åˆ†ç±»æ˜¯å¦å­˜åœ¨
        // category, err := v.categoryRepo.FindByID(ctx, req.CategoryId)
        // if err != nil {
        //     return NewError(ErrCategoryNotFound, "category not found")
        // }
    }

    return nil
}

func (v *BusinessValidator) isEmailDomainBlocked(email string) bool {
    // ç®€å•çš„é‚®ç®±åŸŸåé»‘åå•
    blockedDomains := []string{
        "10minutemail.com",
        "temp-mail.org",
        "guerrillamail.com",
    }

    parts := strings.Split(email, "@")
    if len(parts) != 2 {
        return false
    }

    domain := strings.ToLower(parts[1])
    for _, blocked := range blockedDomains {
        if domain == blocked {
            return true
        }
    }

    return false
}
```

---

## å…­ã€ç»¼åˆç¤ºä¾‹

**å®Œæ•´çš„ä¸šåŠ¡é€»è¾‘å±‚å®ç°**:

```go
// internal/biz/user_usecase.go
package biz

import (
    "context"
    "time"
    "github.com/go-kratos/kratos/v2/log"
    "github.com/go-kratos/kratos-layout/internal/model"
    v1 "github.com/go-kratos/kratos-layout/api/user/v1"
)

type UserUsecase struct {
    userRepo    UserRepo
    validator   *BusinessValidator
    metrics     *UserMetrics
    log         *log.Helper
}

func NewUserUsecase(
    userRepo UserRepo,
    validator *BusinessValidator,
    metrics *UserMetrics,
    logger log.Logger,
) *UserUsecase {
    return &UserUsecase{
        userRepo:  userRepo,
        validator: validator,
        metrics:   metrics,
        log:       log.NewHelper(logger),
    }
}

func (uc *UserUsecase) RegisterUser(ctx context.Context, req *v1.RegisterUserRequest) (*v1.RegisterUserReply, error) {
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        success := recover() == nil
        uc.metrics.RecordRegister(duration, success)
    }()

    // 1. åŸºç¡€éªŒè¯
    if err := ValidateRegisterRequest(req); err != nil {
        uc.logBusinessError(ctx, "register_validation", err, 0)
        return nil, NewError(ErrInvalidArgument, err.Error())
    }

    // 2. ä¸šåŠ¡éªŒè¯
    if err := uc.validator.ValidateUserRegistration(ctx, req); err != nil {
        uc.logBusinessError(ctx, "register_business_validation", err, 0)
        return nil, err
    }

    // 3. åˆ›å»ºç”¨æˆ·
    user := &model.User{
        Username: req.Username,
        Email:    req.Email,
        Password: req.Password,
        Status:   "active",
    }

    createdUser, err := uc.userRepo.Create(ctx, user)
    if err != nil {
        uc.logBusinessError(ctx, "register_create_user", err, 0)
        return nil, NewError(ErrInternalError, "failed to create user")
    }

    // 4. åˆ›å»ºç”¨æˆ·èµ„æ–™
    if req.Bio != "" || req.FirstName != "" || req.LastName != "" {
        profile := &model.UserProfile{
            UserID:    createdUser.ID,
            Bio:       req.Bio,
            FirstName: req.FirstName,
            LastName:  req.LastName,
        }

        if _, err := uc.userRepo.CreateProfile(ctx, profile); err != nil {
            uc.log.Errorf("create user profile failed: %v", err)
            // ä¸å½±å“æ³¨å†ŒæˆåŠŸ
        }
    }

    // 5. è®°å½•ç”¨æˆ·è¡Œä¸º
    uc.logUserAction(ctx, "register", createdUser.ID, map[string]interface{}{
        "username": createdUser.Username,
        "email":    createdUser.Email,
    })

    // 6. æ›´æ–°æ´»è·ƒç”¨æˆ·æ•°
    if count, err := uc.userRepo.Count(ctx); err == nil {
        uc.metrics.SetActiveUsers(count)
    }

    return &v1.RegisterUserReply{
        User: &v1.User{
            Id:       uint64(createdUser.ID),
            Username: createdUser.Username,
            Email:    createdUser.Email,
            Status:   createdUser.Status,
        },
    }, nil
}

func (uc *UserUsecase) LoginUser(ctx context.Context, req *v1.LoginUserRequest) (*v1.LoginUserReply, error) {
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        success := recover() == nil
        uc.metrics.RecordLogin(duration, success)
    }()

    // 1. éªŒè¯è¯·æ±‚
    if err := ValidateLoginRequest(req); err != nil {
        return nil, NewError(ErrInvalidArgument, err.Error())
    }

    // 2. æŸ¥æ‰¾ç”¨æˆ·
    user, err := uc.userRepo.FindByUsername(ctx, req.Username)
    if err != nil || user == nil {
        uc.logSecurityEvent(ctx, "login_failed", 0, map[string]interface{}{
            "username": req.Username,
            "reason":   "user_not_found",
        })
        return nil, NewError(ErrInvalidCredentials, "invalid credentials")
    }

    // 3. éªŒè¯å¯†ç 
    if !uc.verifyPassword(user.Password, req.Password) {
        uc.logSecurityEvent(ctx, "login_failed", user.ID, map[string]interface{}{
            "username": user.Username,
            "reason":   "wrong_password",
        })
        return nil, NewError(ErrInvalidCredentials, "invalid credentials")
    }

    // 4. æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    if user.Status != "active" {
        return nil, NewError(ErrUserInactive, "user account is not active")
    }

    // 5. ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
    token, err := uc.generateAccessToken(user.ID)
    if err != nil {
        uc.log.Errorf("generate access token failed: %v", err)
        return nil, NewError(ErrInternalError, "failed to generate token")
    }

    // 6. æ›´æ–°æœ€åç™»å½•æ—¶é—´
    now := time.Now()
    user.LastLogin = &now
    if _, err := uc.userRepo.Update(ctx, user); err != nil {
        uc.log.Warnf("update last login failed: %v", err)
    }

    // 7. è®°å½•ç™»å½•è¡Œä¸º
    uc.logUserAction(ctx, "login", user.ID, map[string]interface{}{
        "username": user.Username,
        "ip":       getClientIP(ctx),
    })

    return &v1.LoginUserReply{
        Token: token,
        User: &v1.User{
            Id:       uint64(user.ID),
            Username: user.Username,
            Email:    user.Email,
            Status:   user.Status,
        },
    }, nil
}

// è¾…åŠ©æ–¹æ³•
func (uc *UserUsecase) verifyPassword(hashedPassword, password string) bool {
    // è¿™é‡Œåº”è¯¥ä½¿ç”¨bcryptæˆ–å…¶ä»–å¯†ç å“ˆå¸Œç®—æ³•
    return hashedPassword == password // ç®€åŒ–ç¤ºä¾‹
}

func (uc *UserUsecase) generateAccessToken(userID uint) (string, error) {
    // è¿™é‡Œåº”è¯¥ä½¿ç”¨JWTæˆ–å…¶ä»–tokenç”Ÿæˆç®—æ³•
    return fmt.Sprintf("token_%d", userID), nil // ç®€åŒ–ç¤ºä¾‹
}

func getClientIP(ctx context.Context) string {
    // ä»ä¸Šä¸‹æ–‡è·å–å®¢æˆ·ç«¯IP
    return "127.0.0.1" // ç®€åŒ–ç¤ºä¾‹
}
```

---

## æ€»ç»“

1. **Use Caseæ¨¡å¼**ï¼šæ¯ä¸ªUse Caseå°è£…å®Œæ•´çš„ä¸šåŠ¡é€»è¾‘
2. **ä¾èµ–æ³¨å…¥**ï¼šä½¿ç”¨Wireè¿›è¡Œä¾èµ–ç®¡ç†
3. **æ¥å£è®¾è®¡**ï¼šæ¸…æ™°çš„æ¥å£å®šä¹‰å’Œå®ç°åˆ†ç¦»
4. **æ•°æ®éªŒè¯**ï¼šå¤šå±‚éªŒè¯ï¼ˆåŸºç¡€éªŒè¯ + ä¸šåŠ¡éªŒè¯ï¼‰
5. **é”™è¯¯å¤„ç†**ï¼šç»Ÿä¸€çš„ä¸šåŠ¡é”™è¯¯å®šä¹‰å’Œå¤„ç†
6. **æ—¥å¿—è®°å½•**ï¼šç»“æ„åŒ–æ—¥å¿—å’Œå®‰å…¨äº‹ä»¶è®°å½•
7. **ä¸šåŠ¡äº‹åŠ¡**ï¼šä¿è¯ä¸šåŠ¡æ“ä½œçš„åŸå­æ€§
8. **æŒ‡æ ‡ç›‘æ§**ï¼šä¸šåŠ¡æŒ‡æ ‡çš„æ”¶é›†å’Œç›‘æ§

**ä¸‹ä¸€æ­¥**ï¼šå­¦ä¹ [ç¬¬5è¯¾ï¼šå¾®æœåŠ¡æ¶æ„](./5.Kratosé«˜çº§ï¼šå¾®æœåŠ¡æ¶æ„.md)ï¼Œäº†è§£Kratosçš„å¾®æœåŠ¡æ²»ç†èƒ½åŠ›ã€‚
