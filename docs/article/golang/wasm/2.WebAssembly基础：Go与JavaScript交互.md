---
title: WebAssembly基础：Go与JavaScript交互
date: 2026-01-15
description: 深入学习Go与JavaScript之间的双向通信，包括函数调用、类型转换和回调处理
---

# WebAssembly基础：Go与JavaScript交互

Go WebAssembly的核心是`syscall/js`包，它提供了与JavaScript交互的完整API。本课将深入学习Go与JavaScript之间的双向通信。

## 一、syscall/js包概览

### 1.1 核心类型

```go
// js.Value 表示JavaScript值
type Value struct {
    // ...
}

// js.Func 表示JavaScript函数
type Func struct {
    // ...
}

// js.Type 表示JavaScript类型
type Type int
```

### 1.2 主要函数

- `js.Global()`：获取全局对象
- `js.ValueOf()`：将Go值转换为JavaScript值
- `js.New()`：创建JavaScript对象
- `js.CopyBytesToJS()`：复制字节到JavaScript

## 二、Go调用JavaScript函数

### 2.1 调用全局函数

```go
package main

import (
    "syscall/js"
)

func main() {
    // 调用alert
    js.Global().Call("alert", "Hello from Go!")
    
    // 调用console.log
    js.Global().Get("console").Call("log", "这是一条日志")
    
    // 调用console.error
    js.Global().Get("console").Call("error", "这是一条错误")
    
    // 调用console.warn
    js.Global().Get("console").Call("warn", "这是一条警告")
    
    select {}
}
```

### 2.2 调用对象方法

```go
func main() {
    // 获取document对象
    doc := js.Global().Get("document")
    
    // 调用getElementById
    element := doc.Call("getElementById", "myDiv")
    
    // 调用createElement
    newElement := doc.Call("createElement", "div")
    
    // 调用appendChild
    doc.Call("getElementsByTagName", "body").Index(0).Call("appendChild", newElement)
    
    select {}
}
```

### 2.3 传递参数

```go
func main() {
    // 传递字符串
    js.Global().Call("alert", "字符串参数")
    
    // 传递数字
    js.Global().Get("console").Call("log", 123)
    js.Global().Get("console").Call("log", 3.14)
    
    // 传递布尔值
    js.Global().Get("console").Call("log", true)
    
    // 传递多个参数
    js.Global().Get("console").Call("log", "参数1", "参数2", 123)
    
    select {}
}
```

### 2.4 获取返回值

```go
func main() {
    // 调用函数并获取返回值
    result := js.Global().Call("prompt", "请输入您的名字:")
    name := result.String()
    
    js.Global().Get("console").Call("log", "您输入的名字是:", name)
    
    // 调用parseInt
    numStr := "123"
    num := js.Global().Get("parseInt").Invoke(numStr, 10).Int()
    js.Global().Get("console").Call("log", "解析的数字:", num)
    
    select {}
}
```

### 2.5 调用带this的函数

```go
func main() {
    // 创建数组
    arr := js.Global().Get("Array").New(1, 2, 3, 4, 5)
    
    // 调用数组的forEach方法
    arr.Call("forEach", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        value := args[0]
        index := args[1]
        js.Global().Get("console").Call("log", "索引:", index.Int(), "值:", value.Int())
        return nil
    }))
    
    select {}
}
```

## 三、JavaScript调用Go函数

### 3.1 导出Go函数

```go
package main

import (
    "syscall/js"
)

// 导出一个简单的Go函数
func add(this js.Value, args []js.Value) interface{} {
    if len(args) != 2 {
        return js.ValueOf("参数数量错误")
    }
    
    a := args[0].Int()
    b := args[1].Int()
    result := a + b
    
    return js.ValueOf(result)
}

func main() {
    // 将Go函数导出到JavaScript全局对象
    js.Global().Set("goAdd", js.FuncOf(add))
    
    js.Global().Get("console").Call("log", "Go函数已导出")
    
    select {}
}
```

在JavaScript中调用：

```javascript
// 调用Go函数
const result = goAdd(10, 20);
console.log("结果:", result); // 输出: 30
```

### 3.2 处理不同类型的参数

```go
func processData(this js.Value, args []js.Value) interface{} {
    if len(args) == 0 {
        return js.ValueOf("没有参数")
    }
    
    // 检查参数类型
    arg := args[0]
    
    switch arg.Type() {
    case js.TypeString:
        return js.ValueOf("字符串: " + arg.String())
    case js.TypeNumber:
        return js.ValueOf("数字: " + arg.String())
    case js.TypeBoolean:
        return js.ValueOf("布尔值: " + arg.String())
    case js.TypeObject:
        return js.ValueOf("对象: " + arg.String())
    default:
        return js.ValueOf("未知类型")
    }
}

func main() {
    js.Global().Set("goProcessData", js.FuncOf(processData))
    select {}
}
```

### 3.3 返回复杂类型

```go
func getObject(this js.Value, args []js.Value) interface{} {
    // 创建JavaScript对象
    obj := js.Global().Get("Object").New()
    obj.Set("name", "Go WebAssembly")
    obj.Set("version", "1.0")
    obj.Set("language", "Go")
    
    return obj
}

func getArray(this js.Value, args []js.Value) interface{} {
    // 创建JavaScript数组
    arr := js.Global().Get("Array").New()
    arr.Call("push", "元素1")
    arr.Call("push", "元素2")
    arr.Call("push", "元素3")
    
    return arr
}

func main() {
    js.Global().Set("goGetObject", js.FuncOf(getObject))
    js.Global().Set("goGetArray", js.FuncOf(getArray))
    select {}
}
```

### 3.4 异步函数

```go
func asyncFunction(this js.Value, args []js.Value) interface{} {
    // 创建Promise
    promise := js.Global().Get("Promise").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        resolve := args[0]
        
        // 模拟异步操作
        go func() {
            time.Sleep(2 * time.Second)
            resolve.Invoke("异步操作完成")
        }()
        
        return nil
    }))
    
    return promise
}

func main() {
    js.Global().Set("goAsyncFunction", js.FuncOf(asyncFunction))
    select {}
}
```

在JavaScript中使用：

```javascript
goAsyncFunction().then(result => {
    console.log(result); // 2秒后输出: "异步操作完成"
});
```

## 四、类型转换

### 4.1 Go类型转JavaScript类型

```go
func main() {
    // 字符串
    js.Global().Set("goString", "Hello")
    
    // 数字
    js.Global().Set("goNumber", 123)
    js.Global().Set("goFloat", 3.14)
    
    // 布尔值
    js.Global().Set("goBool", true)
    
    // 使用js.ValueOf
    js.Global().Set("goValue", js.ValueOf("使用ValueOf"))
    
    select {}
}
```

### 4.2 JavaScript类型转Go类型

```go
func convertTypes(this js.Value, args []js.Value) interface{} {
    if len(args) == 0 {
        return nil
    }
    
    val := args[0]
    
    // 转换为Go类型
    switch val.Type() {
    case js.TypeString:
        goStr := val.String()
        js.Global().Get("console").Call("log", "Go字符串:", goStr)
        return goStr
        
    case js.TypeNumber:
        goNum := val.Int() // 或 val.Float()
        js.Global().Get("console").Call("log", "Go数字:", goNum)
        return goNum
        
    case js.TypeBoolean:
        goBool := val.Bool()
        js.Global().Get("console").Call("log", "Go布尔值:", goBool)
        return goBool
        
    case js.TypeObject:
        // 检查是否是数组
        if val.InstanceOf(js.Global().Get("Array")) {
            length := val.Get("length").Int()
            js.Global().Get("console").Call("log", "数组长度:", length)
        }
        return val.String()
        
    default:
        return "未知类型"
    }
}

func main() {
    js.Global().Set("goConvertTypes", js.FuncOf(convertTypes))
    select {}
}
```

### 4.3 处理对象属性

```go
func handleObject(this js.Value, args []js.Value) interface{} {
    if len(args) == 0 {
        return nil
    }
    
    obj := args[0]
    
    // 获取属性
    name := obj.Get("name").String()
    age := obj.Get("age").Int()
    
    // 设置属性
    obj.Set("greeting", "Hello, "+name)
    
    // 调用方法
    if obj.Get("sayHello").Type() == js.TypeFunction {
        obj.Call("sayHello")
    }
    
    return obj
}

func main() {
    js.Global().Set("goHandleObject", js.FuncOf(handleObject))
    select {}
}
```

## 五、回调函数

### 5.1 传递回调函数

```go
func processWithCallback(this js.Value, args []js.Value) interface{} {
    if len(args) < 2 {
        return js.ValueOf("参数不足")
    }
    
    data := args[0].String()
    callback := args[1]
    
    // 处理数据
    result := "处理后的数据: " + data
    
    // 调用回调函数
    callback.Invoke(result)
    
    return nil
}

func main() {
    js.Global().Set("goProcessWithCallback", js.FuncOf(processWithCallback))
    select {}
}
```

在JavaScript中使用：

```javascript
goProcessWithCallback("原始数据", (result) => {
    console.log(result); // 输出: "处理后的数据: 原始数据"
});
```

### 5.2 异步回调

```go
func asyncProcess(this js.Value, args []js.Value) interface{} {
    if len(args) < 1 {
        return nil
    }
    
    callback := args[0]
    
    // 在goroutine中异步处理
    go func() {
        time.Sleep(1 * time.Second)
        callback.Invoke("异步处理完成")
    }()
    
    return nil
}

func main() {
    js.Global().Set("goAsyncProcess", js.FuncOf(asyncProcess))
    select {}
}
```

### 5.3 事件监听器

```go
func setupEventListener(this js.Value, args []js.Value) interface{} {
    if len(args) < 2 {
        return nil
    }
    
    element := args[0]
    eventType := args[1].String()
    handler := args[2]
    
    // 添加事件监听器
    element.Call("addEventListener", eventType, handler)
    
    return nil
}

func main() {
    js.Global().Set("goSetupEventListener", js.FuncOf(setupEventListener))
    select {}
}
```

## 六、完整示例：计算器

### 6.1 Go代码

```go
package main

import (
    "fmt"
    "syscall/js"
    "strconv"
)

func calculate(this js.Value, args []js.Value) interface{} {
    if len(args) != 3 {
        return js.ValueOf("参数错误：需要3个参数（数字1, 操作符, 数字2）")
    }
    
    // 获取参数
    num1Str := args[0].String()
    operator := args[1].String()
    num2Str := args[2].String()
    
    // 转换为数字
    num1, err1 := strconv.ParseFloat(num1Str, 64)
    num2, err2 := strconv.ParseFloat(num2Str, 64)
    
    if err1 != nil || err2 != nil {
        return js.ValueOf("数字格式错误")
    }
    
    // 计算结果
    var result float64
    switch operator {
    case "+":
        result = num1 + num2
    case "-":
        result = num1 - num2
    case "*":
        result = num1 * num2
    case "/":
        if num2 == 0 {
            return js.ValueOf("除数不能为0")
        }
        result = num1 / num2
    default:
        return js.ValueOf("不支持的操作符: " + operator)
    }
    
    return js.ValueOf(result)
}

func main() {
    fmt.Println("计算器模块已加载")
    
    // 导出函数
    js.Global().Set("goCalculate", js.FuncOf(calculate))
    
    select {}
}
```

### 6.2 HTML代码

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Go WebAssembly 计算器</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 400px;
            margin: 50px auto;
            padding: 20px;
        }
        .calculator {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 5px;
        }
        input {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            box-sizing: border-box;
        }
        button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #42b983;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #35a372;
        }
        #result {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="calculator">
        <h2>Go WebAssembly 计算器</h2>
        <input type="number" id="num1" placeholder="数字1" value="10">
        <select id="operator">
            <option value="+">+</option>
            <option value="-">-</option>
            <option value="*">×</option>
            <option value="/">÷</option>
        </select>
        <input type="number" id="num2" placeholder="数字2" value="5">
        <button onclick="calculate()">计算</button>
        <div id="result"></div>
    </div>
    
    <script src="wasm_exec.js"></script>
    <script>
        const go = new Go();
        WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject)
            .then((result) => {
                go.run(result.instance);
            });
        
        function calculate() {
            const num1 = document.getElementById("num1").value;
            const operator = document.getElementById("operator").value;
            const num2 = document.getElementById("num2").value;
            
            const result = goCalculate(num1, operator, num2);
            document.getElementById("result").innerHTML = 
                `<strong>结果: ${result}</strong>`;
        }
    </script>
</body>
</html>
```

## 七、错误处理

### 7.1 捕获JavaScript错误

```go
func safeCall(this js.Value, args []js.Value) interface{} {
    if len(args) < 2 {
        return js.ValueOf("参数不足")
    }
    
    obj := args[0]
    method := args[1].String()
    
    // 使用defer捕获panic
    defer func() {
        if r := recover(); r != nil {
            js.Global().Get("console").Call("error", "错误:", js.ValueOf(fmt.Sprintf("%v", r)))
        }
    }()
    
    // 调用方法
    result := obj.Call(method)
    return result
}

func main() {
    js.Global().Set("goSafeCall", js.FuncOf(safeCall))
    select {}
}
```

### 7.2 验证参数

```go
func validateAndProcess(this js.Value, args []js.Value) interface{} {
    // 验证参数数量
    if len(args) < 1 {
        return js.ValueOf(map[string]interface{}{
            "error": "参数不足",
            "success": false,
        })
    }
    
    // 验证参数类型
    val := args[0]
    if val.Type() != js.TypeString {
        return js.ValueOf(map[string]interface{}{
            "error": "参数必须是字符串",
            "success": false,
        })
    }
    
    // 处理数据
    data := val.String()
    if len(data) == 0 {
        return js.ValueOf(map[string]interface{}{
            "error": "字符串不能为空",
            "success": false,
        })
    }
    
    // 返回成功结果
    return js.ValueOf(map[string]interface{}{
        "result": "处理成功: " + data,
        "success": true,
    })
}

func main() {
    js.Global().Set("goValidateAndProcess", js.FuncOf(validateAndProcess))
    select {}
}
```

## 八、性能优化

### 8.1 减少函数调用

```go
// 不好的做法：多次调用
func badExample() {
    doc := js.Global().Get("document")
    body := doc.Call("getElementsByTagName", "body").Index(0)
    body.Call("appendChild", element1)
    body.Call("appendChild", element2)
    body.Call("appendChild", element3)
}

// 好的做法：缓存引用
func goodExample() {
    doc := js.Global().Get("document")
    body := doc.Call("getElementsByTagName", "body").Index(0)
    
    // 批量操作
    body.Call("appendChild", element1)
    body.Call("appendChild", element2)
    body.Call("appendChild", element3)
}
```

### 8.2 使用批量操作

```go
func batchOperation(this js.Value, args []js.Value) interface{} {
    // 在Go中处理数据
    results := make([]interface{}, 0)
    for i := 0; i < 1000; i++ {
        results = append(results, i*2)
    }
    
    // 一次性返回结果
    arr := js.Global().Get("Array").New()
    for _, r := range results {
        arr.Call("push", r)
    }
    
    return arr
}
```

## 九、下一步学习

完成本课后，你应该能够：

- ✅ 使用syscall/js包调用JavaScript函数
- ✅ 将Go函数导出给JavaScript调用
- ✅ 处理类型转换和参数传递
- ✅ 实现回调函数和异步操作
- ✅ 处理错误和验证参数

接下来可以学习：

1. **第3课：DOM操作** - 使用Go操作DOM元素和处理用户事件
2. **第4课：构建Web应用** - 构建完整的Web应用

## 十、总结

- `syscall/js`包提供了完整的JavaScript交互API
- Go可以调用任何JavaScript函数
- Go函数可以导出给JavaScript调用
- 需要注意类型转换和错误处理
- 合理使用回调函数和异步操作
- 注意性能优化，减少不必要的调用

掌握Go与JavaScript的交互，是构建WebAssembly应用的基础！
