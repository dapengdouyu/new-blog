---
title: WebAssembly实践：构建Web应用
date: 2026-01-15
description: 学习构建完整的Web应用，包括状态管理、HTTP请求、路由等
---

# WebAssembly实践：构建Web应用

本课将学习如何构建一个完整的Web应用，包括项目结构、状态管理、HTTP请求、路由等实际开发中的关键内容。

## 一、项目结构设计

### 1.1 推荐的项目结构

```
my-wasm-app/
├── cmd/
│   └── wasm/
│       └── main.go          # WebAssembly入口
├── internal/
│   ├── app/
│   │   ├── state.go         # 状态管理
│   │   └── router.go       # 路由
│   ├── handlers/
│   │   ├── home.go          # 页面处理器
│   │   └── api.go           # API处理器
│   └── utils/
│       └── dom.go           # DOM工具函数
├── assets/
│   └── styles.css           # 样式文件
├── index.html               # HTML入口
├── wasm_exec.js             # Go支持文件
└── go.mod                    # Go模块文件
```

### 1.2 模块化设计

```go
// internal/app/state.go
package app

type State struct {
    User    *User
    Todos   []Todo
    Loading bool
}

type User struct {
    ID    int
    Name  string
    Email string
}

type Todo struct {
    ID    int
    Text  string
    Done  bool
}

var AppState = &State{
    Todos:   make([]Todo, 0),
    Loading: false,
}
```

## 二、状态管理

### 2.1 简单的状态管理

```go
// internal/app/state.go
package app

import (
    "sync"
    "syscall/js"
)

type State struct {
    mu      sync.RWMutex
    User    *User
    Todos   []Todo
    Counter int
    listeners []func()
}

func NewState() *State {
    return &State{
        listeners: make([]func(), 0),
    }
}

func (s *State) SetUser(user *User) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.User = user
    s.notify()
}

func (s *State) AddTodo(todo Todo) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.Todos = append(s.Todos, todo)
    s.notify()
}

func (s *State) GetTodos() []Todo {
    s.mu.RLock()
    defer s.mu.RUnlock()
    return s.Todos
}

func (s *State) Subscribe(listener func()) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.listeners = append(s.listeners, listener)
}

func (s *State) notify() {
    for _, listener := range s.listeners {
        listener()
    }
}
```

### 2.2 状态更新和UI同步

```go
// internal/handlers/home.go
package handlers

import (
    "my-wasm-app/internal/app"
    "syscall/js"
)

func SetupHome() {
    state := app.GetState()
    
    // 订阅状态变化
    state.Subscribe(func() {
        renderTodos()
    })
    
    // 初始化渲染
    renderTodos()
}

func renderTodos() {
    state := app.GetState()
    todos := state.GetTodos()
    
    doc := js.Global().Get("document")
    container := doc.Call("getElementById", "todoList")
    container.Set("innerHTML", "")
    
    // 渲染逻辑...
}
```

## 三、HTTP请求

### 3.1 使用fetch API

```go
// internal/utils/http.go
package utils

import (
    "encoding/json"
    "fmt"
    "syscall/js"
)

type HTTPClient struct {
    baseURL string
}

func NewHTTPClient(baseURL string) *HTTPClient {
    return &HTTPClient{baseURL: baseURL}
}

func (c *HTTPClient) Get(url string) (js.Value, error) {
    fullURL := c.baseURL + url
    
    promise := js.Global().Get("fetch").Invoke(fullURL)
    
    // 等待Promise完成
    resultChan := make(chan js.Value, 1)
    errorChan := make(chan error, 1)
    
    then := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        response := args[0]
        response.Call("json").Call("then", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
            resultChan <- args[0]
            return nil
        }))
        return nil
    })
    
    catch := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        errorChan <- fmt.Errorf("请求失败: %v", args[0])
        return nil
    })
    
    promise.Call("then", then).Call("catch", catch)
    
    select {
    case result := <-resultChan:
        return result, nil
    case err := <-errorChan:
        return js.Value{}, err
    }
}

func (c *HTTPClient) Post(url string, data interface{}) (js.Value, error) {
    fullURL := c.baseURL + url
    
    // 将Go数据转换为JSON
    jsonData, err := json.Marshal(data)
    if err != nil {
        return js.Value{}, err
    }
    
    options := js.Global().Get("Object").New()
    options.Set("method", "POST")
    options.Set("headers", js.Global().Get("Object").New().Set("Content-Type", "application/json"))
    options.Set("body", string(jsonData))
    
    promise := js.Global().Get("fetch").Invoke(fullURL, options)
    
    // 处理Promise（类似Get方法）
    // ...
    
    return js.Value{}, nil
}
```

### 3.2 使用HTTP客户端

```go
// internal/handlers/api.go
package handlers

import (
    "my-wasm-app/internal/app"
    "my-wasm-app/internal/utils"
    "syscall/js"
)

var httpClient = utils.NewHTTPClient("https://api.example.com")

func LoadTodos() {
    state := app.GetState()
    state.SetLoading(true)
    
    go func() {
        response, err := httpClient.Get("/todos")
        if err != nil {
            js.Global().Get("console").Call("error", "加载失败:", err.Error())
            state.SetLoading(false)
            return
        }
        
        // 解析响应
        todos := parseTodos(response)
        state.SetTodos(todos)
        state.SetLoading(false)
    }()
}

func parseTodos(response js.Value) []app.Todo {
    // 解析JSON响应
    // ...
    return []app.Todo{}
}
```

## 四、路由实现

### 4.1 简单的路由系统

```go
// internal/app/router.go
package app

import (
    "syscall/js"
)

type Route struct {
    Path     string
    Handler  func()
    Title    string
}

type Router struct {
    routes []Route
    currentPath string
}

func NewRouter() *Router {
    return &Router{
        routes: make([]Route, 0),
    }
}

func (r *Router) AddRoute(path string, handler func(), title string) {
    r.routes = append(r.routes, Route{
        Path:    path,
        Handler: handler,
        Title:   title,
    })
}

func (r *Router) Navigate(path string) {
    r.currentPath = path
    
    // 更新浏览器URL
    js.Global().Get("window").Get("history").Call("pushState", nil, "", path)
    
    // 查找并执行路由处理器
    for _, route := range r.routes {
        if route.Path == path {
            // 更新页面标题
            js.Global().Get("document").Set("title", route.Title)
            route.Handler()
            return
        }
    }
    
    // 404处理
    r.handle404()
}

func (r *Router) Start() {
    // 监听浏览器前进后退
    js.Global().Get("window").Call("addEventListener", "popstate", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        path := js.Global().Get("window").Get("location").Get("pathname").String()
        r.Navigate(path)
        return nil
    }))
    
    // 初始路由
    initialPath := js.Global().Get("window").Get("location").Get("pathname").String()
    r.Navigate(initialPath)
}

func (r *Router) handle404() {
    doc := js.Global().Get("document")
    container := doc.Call("getElementById", "app")
    container.Set("innerHTML", "<h1>404 - 页面未找到</h1>")
}
```

### 4.2 使用路由

```go
// cmd/wasm/main.go
package main

import (
    "my-wasm-app/internal/app"
    "my-wasm-app/internal/handlers"
    "syscall/js"
)

func main() {
    router := app.NewRouter()
    
    // 注册路由
    router.AddRoute("/", handlers.Home, "首页")
    router.AddRoute("/todos", handlers.Todos, "待办事项")
    router.AddRoute("/about", handlers.About, "关于")
    
    // 启动路由
    router.Start()
    
    // 导出导航函数
    js.Global().Set("navigate", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        if len(args) > 0 {
            router.Navigate(args[0].String())
        }
        return nil
    }))
    
    select {}
}
```

## 五、组件化开发

### 5.1 组件结构

```go
// internal/components/button.go
package components

import "syscall/js"

type Button struct {
    Text    string
    OnClick func()
    Style   map[string]string
}

func NewButton(text string, onClick func()) *Button {
    return &Button{
        Text:    text,
        OnClick: onClick,
        Style:   make(map[string]string),
    }
}

func (b *Button) Render() js.Value {
    doc := js.Global().Get("document")
    button := doc.Call("createElement", "button")
    button.Set("innerHTML", b.Text)
    
    // 设置样式
    style := button.Get("style")
    for key, value := range b.Style {
        style.Set(key, value)
    }
    
    // 添加事件
    if b.OnClick != nil {
        button.Call("addEventListener", "click", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
            b.OnClick()
            return nil
        }))
    }
    
    return button
}
```

### 5.2 使用组件

```go
func renderPage() {
    doc := js.Global().Get("document")
    container := doc.Call("getElementById", "app")
    
    // 创建按钮组件
    button := components.NewButton("点击我", func() {
        js.Global().Get("alert").Invoke("按钮被点击")
    })
    button.Style["padding"] = "10px 20px"
    button.Style["background"] = "#42b983"
    button.Style["color"] = "white"
    
    // 渲染
    container.Call("appendChild", button.Render())
}
```

## 六、完整示例：待办事项应用（增强版）

### 6.1 项目结构

```
todo-app/
├── cmd/
│   └── wasm/
│       └── main.go
├── internal/
│   ├── app/
│   │   ├── state.go
│   │   └── router.go
│   ├── handlers/
│   │   └── todos.go
│   └── models/
│       └── todo.go
├── index.html
├── wasm_exec.js
└── go.mod
```

### 6.2 状态管理

```go
// internal/app/state.go
package app

import (
    "sync"
)

type State struct {
    mu        sync.RWMutex
    Todos     []Todo
    Filter    string // "all", "active", "completed"
    listeners []func()
}

var globalState = &State{
    Todos:     make([]Todo, 0),
    Filter:    "all",
    listeners: make([]func(), 0),
}

func GetState() *State {
    return globalState
}

func (s *State) AddTodo(text string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    todo := Todo{
        ID:   len(s.Todos) + 1,
        Text: text,
        Done: false,
    }
    s.Todos = append(s.Todos, todo)
    s.notify()
}

func (s *State) ToggleTodo(id int) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    for i := range s.Todos {
        if s.Todos[i].ID == id {
            s.Todos[i].Done = !s.Todos[i].Done
            break
        }
    }
    s.notify()
}

func (s *State) DeleteTodo(id int) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    for i, todo := range s.Todos {
        if todo.ID == id {
            s.Todos = append(s.Todos[:i], s.Todos[i+1:]...)
            break
        }
    }
    s.notify()
}

func (s *State) SetFilter(filter string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.Filter = filter
    s.notify()
}

func (s *State) GetFilteredTodos() []Todo {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    switch s.Filter {
    case "active":
        result := make([]Todo, 0)
        for _, todo := range s.Todos {
            if !todo.Done {
                result = append(result, todo)
            }
        }
        return result
    case "completed":
        result := make([]Todo, 0)
        for _, todo := range s.Todos {
            if todo.Done {
                result = append(result, todo)
            }
        }
        return result
    default:
        return s.Todos
    }
}

func (s *State) Subscribe(listener func()) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.listeners = append(s.listeners, listener)
}

func (s *State) notify() {
    for _, listener := range s.listeners {
        listener()
    }
}
```

### 6.3 处理器

```go
// internal/handlers/todos.go
package handlers

import (
    "fmt"
    "my-wasm-app/internal/app"
    "syscall/js"
)

func SetupTodos() {
    state := app.GetState()
    
    // 订阅状态变化
    state.Subscribe(renderTodos)
    
    // 设置输入框
    setupInput()
    
    // 设置过滤器
    setupFilter()
    
    // 初始渲染
    renderTodos()
}

func setupInput() {
    doc := js.Global().Get("document")
    input := doc.Call("getElementById", "todoInput")
    addBtn := doc.Call("getElementById", "addBtn")
    
    addHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        text := input.Get("value").String()
        if len(text) > 0 {
            state := app.GetState()
            state.AddTodo(text)
            input.Set("value", "")
        }
        return nil
    })
    
    addBtn.Call("addEventListener", "click", addHandler)
    input.Call("addEventListener", "keypress", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        if args[0].Get("key").String() == "Enter" {
            addHandler.Invoke()
        }
        return nil
    }))
}

func setupFilter() {
    doc := js.Global().Get("document")
    
    filters := []string{"all", "active", "completed"}
    for _, filter := range filters {
        btn := doc.Call("getElementById", fmt.Sprintf("filter-%s", filter))
        if btn.Truthy() {
            btn.Call("addEventListener", "click", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
                state := app.GetState()
                state.SetFilter(filter)
                return nil
            }))
        }
    }
}

func renderTodos() {
    state := app.GetState()
    todos := state.GetFilteredTodos()
    
    doc := js.Global().Get("document")
    container := doc.Call("getElementById", "todoList")
    container.Set("innerHTML", "")
    
    if len(todos) == 0 {
        container.Set("innerHTML", "<p>暂无待办事项</p>")
        return
    }
    
    ul := doc.Call("createElement", "ul")
    ul.Set("style", "list-style: none; padding: 0;")
    
    for _, todo := range todos {
        li := createTodoItem(todo)
        ul.Call("appendChild", li)
    }
    
    container.Call("appendChild", ul)
}

func createTodoItem(todo app.Todo) js.Value {
    doc := js.Global().Get("document")
    li := doc.Call("createElement", "li")
    li.Set("style", "padding: 10px; margin: 5px 0; border: 1px solid #ccc; border-radius: 3px; display: flex; align-items: center;")
    
    // 复选框
    checkbox := doc.Call("createElement", "input")
    checkbox.Set("type", "checkbox")
    checkbox.Set("checked", todo.Done)
    checkbox.Call("addEventListener", "change", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        state := app.GetState()
        state.ToggleTodo(todo.ID)
        return nil
    }))
    
    // 文本
    text := doc.Call("createElement", "span")
    text.Set("innerHTML", todo.Text)
    text.Get("style").Set("flex", "1")
    text.Get("style").Set("marginLeft", "10px")
    if todo.Done {
        text.Get("style").Set("textDecoration", "line-through")
        text.Get("style").Set("opacity", "0.5")
    }
    
    // 删除按钮
    deleteBtn := doc.Call("createElement", "button")
    deleteBtn.Set("innerHTML", "删除")
    deleteBtn.Get("style").Set("background", "#ff4444")
    deleteBtn.Get("style").Set("color", "white")
    deleteBtn.Get("style").Set("border", "none")
    deleteBtn.Get("style").Set("padding", "5px 10px")
    deleteBtn.Get("style").Set("borderRadius", "3px")
    deleteBtn.Get("style").Set("cursor", "pointer")
    deleteBtn.Call("addEventListener", "click", js.FuncOf(func(this js.Value, args []js.Value) interface{} {
        state := app.GetState()
        state.DeleteTodo(todo.ID)
        return nil
    }))
    
    li.Call("appendChild", checkbox)
    li.Call("appendChild", text)
    li.Call("appendChild", deleteBtn)
    
    return li
}
```

### 6.4 主程序

```go
// cmd/wasm/main.go
package main

import (
    "my-wasm-app/internal/handlers"
    "syscall/js"
)

func main() {
    js.Global().Get("console").Call("log", "待办事项应用启动")
    
    // 设置应用
    handlers.SetupTodos()
    
    select {}
}
```

## 七、下一步学习

完成本课后，你应该能够：

- ✅ 设计合理的项目结构
- ✅ 实现状态管理
- ✅ 处理HTTP请求
- ✅ 实现路由系统
- ✅ 构建完整的Web应用

接下来可以学习：

1. **第5课：性能优化和最佳实践** - 优化WebAssembly应用性能和部署

## 八、总结

- 合理的项目结构有助于代码组织
- 状态管理是复杂应用的核心
- HTTP请求需要处理异步操作
- 路由系统提供单页应用体验
- 组件化开发提高代码复用性
- 完整的应用需要综合考虑各个方面

掌握这些内容，你就可以构建生产级的WebAssembly应用了！
