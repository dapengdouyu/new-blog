---
title: 9ã€GORMå®è·µï¼šæœ€ä½³å®è·µå’Œé¡¹ç›®ç»“æ„
date: 2026-01-09
description: æŒæ¡GORMçš„æœ€ä½³å®è·µï¼Œå­¦ä¼šè®¾è®¡åˆç†çš„é¡¹ç›®ç»“æ„ï¼Œç†è§£æ•°æ®åº“è®¾è®¡åŸåˆ™
---

# 9ã€GORMå®è·µï¼šæœ€ä½³å®è·µå’Œé¡¹ç›®ç»“æ„

æœ¬æ–‡æ¡£ä»‹ç»GORMçš„æœ€ä½³å®è·µå’Œé¡¹ç›®ç»“æ„è®¾è®¡ï¼Œå¸®åŠ©ä½ åœ¨å®é™…é¡¹ç›®ä¸­æ­£ç¡®ä½¿ç”¨GORMã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡GORMçš„æœ€ä½³å®è·µ
- âœ… å­¦ä¼šè®¾è®¡åˆç†çš„é¡¹ç›®ç»“æ„
- âœ… ç†è§£æ•°æ®åº“è®¾è®¡åŸåˆ™
- âœ… æŒæ¡é”™è¯¯å¤„ç†ç­–ç•¥
- âœ… å­¦ä¼šç¼–å†™å•å…ƒæµ‹è¯•
- âœ… æŒæ¡æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- âœ… ç†è§£éƒ¨ç½²å’Œç»´æŠ¤

---

## å‰ç½®çŸ¥è¯†

- **ç¬¬1-8è¯¾**ï¼šæŒæ¡GORMçš„æ‰€æœ‰åŠŸèƒ½

---

## ä¸€ã€é¡¹ç›®ç»“æ„è®¾è®¡

### 1.1 æ ‡å‡†é¡¹ç›®ç»“æ„

```
project/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go          # åº”ç”¨å…¥å£
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ config.go        # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â””â”€â”€ db.go            # æ•°æ®åº“è¿æ¥
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ user.go          # ç”¨æˆ·æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ order.go         # è®¢å•æ¨¡å‹
â”‚   â”‚   â””â”€â”€ product.go       # äº§å“æ¨¡å‹
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ user_repository.go
â”‚   â”‚   â””â”€â”€ order_repository.go
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ user_service.go
â”‚   â”‚   â””â”€â”€ order_service.go
â”‚   â””â”€â”€ handlers/
â”‚       â”œâ”€â”€ user_handler.go
â”‚       â””â”€â”€ order_handler.go
â”œâ”€â”€ pkg/
â”‚   â””â”€â”€ utils/
â”‚       â””â”€â”€ helpers.go       # å·¥å…·å‡½æ•°
â”œâ”€â”€ migrations/
â”‚   â””â”€â”€ 001_create_users.sql # æ•°æ®åº“è¿ç§»
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ integration/
â”‚       â””â”€â”€ user_test.go      # é›†æˆæµ‹è¯•
â”œâ”€â”€ go.mod
â””â”€â”€ README.md
```

### 1.2 åˆ†å±‚æ¶æ„

```go
// models/user.go - æ¨¡å‹å±‚
package models

type User struct {
    ID    uint   `gorm:"primaryKey"`
    Name  string
    Email string
}

// repositories/user_repository.go - æ•°æ®è®¿é—®å±‚
package repositories

type UserRepository struct {
    db *gorm.DB
}

func (r *UserRepository) Create(user *models.User) error {
    return r.db.Create(user).Error
}

func (r *UserRepository) FindByID(id uint) (*models.User, error) {
    var user models.User
    err := r.db.First(&user, id).Error
    return &user, err
}

// services/user_service.go - ä¸šåŠ¡é€»è¾‘å±‚
package services

type UserService struct {
    repo *repositories.UserRepository
}

func (s *UserService) CreateUser(name, email string) (*models.User, error) {
    user := &models.User{
        Name:  name,
        Email: email,
    }
    return user, s.repo.Create(user)
}

// handlers/user_handler.go - å¤„ç†å±‚
package handlers

type UserHandler struct {
    service *services.UserService
}

func (h *UserHandler) CreateUser(c *gin.Context) {
    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": err.Error()})
        return
    }

    user, err := h.service.CreateUser(req.Name, req.Email)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }

    c.JSON(200, user)
}
```

---

## äºŒã€æ•°æ®åº“è®¾è®¡åŸåˆ™

### 2.1 å‘½åè§„èŒƒ

```go
// è¡¨åï¼šä½¿ç”¨å¤æ•°å½¢å¼ï¼Œè›‡å½¢å‘½å
// User -> users
// OrderItem -> order_items

// åˆ—åï¼šè›‡å½¢å‘½å
type User struct {
    ID        uint   `gorm:"primaryKey"`
    FirstName string `gorm:"column:first_name"`
    LastName  string `gorm:"column:last_name"`
    CreatedAt time.Time `gorm:"column:created_at"`
}
```

### 2.2 ä¸»é”®è®¾è®¡

```go
// æ¨èï¼šä½¿ç”¨è‡ªå¢æ•´æ•°ä¸»é”®
type User struct {
    ID uint `gorm:"primaryKey;autoIncrement"`
}

// æˆ–è€…ä½¿ç”¨UUID
type User struct {
    ID   string `gorm:"primaryKey;type:char(36)"`
    UUID string `gorm:"type:char(36);default:uuid()"`
}
```

### 2.3 ç´¢å¼•è®¾è®¡

```go
type User struct {
    ID    uint   `gorm:"primaryKey"`
    Email string `gorm:"uniqueIndex"`        // å”¯ä¸€ç´¢å¼•
    Name  string `gorm:"index"`              // æ™®é€šç´¢å¼•
    Age   int    `gorm:"index:idx_age"`      // å‘½åç´¢å¼•
}

// å¤åˆç´¢å¼•
db.Model(&User{}).AddIndex("idx_name_age", "name", "age")
```

### 2.4 å¤–é”®è®¾è®¡

```go
type Order struct {
    ID     uint   `gorm:"primaryKey"`
    UserID uint   `gorm:"index"`  // å¤–é”®å­—æ®µ
    User   User   `gorm:"foreignKey:UserID;references:ID"`
    Total  float64
}
```

---

## ä¸‰ã€é”™è¯¯å¤„ç†ç­–ç•¥

### 3.1 ç»Ÿä¸€é”™è¯¯å¤„ç†

```go
package errors

import (
    "errors"
    "gorm.io/gorm"
)

var (
    ErrNotFound      = errors.New("è®°å½•ä¸å­˜åœ¨")
    ErrDuplicateEntry = errors.New("è®°å½•å·²å­˜åœ¨")
    ErrInvalidInput   = errors.New("è¾“å…¥æ— æ•ˆ")
)

// WrapGormError åŒ…è£…GORMé”™è¯¯
func WrapGormError(err error) error {
    if err == nil {
        return nil
    }

    if errors.Is(err, gorm.ErrRecordNotFound) {
        return ErrNotFound
    }

    // å¤„ç†å”¯ä¸€çº¦æŸå†²çª
    if errors.Is(err, gorm.ErrDuplicatedKey) {
        return ErrDuplicateEntry
    }

    return err
}
```

### 3.2 Repositoryå±‚é”™è¯¯å¤„ç†

```go
type UserRepository struct {
    db *gorm.DB
}

func (r *UserRepository) FindByID(id uint) (*User, error) {
    var user User
    err := r.db.First(&user, id).Error
    
    if err != nil {
        return nil, errors.WrapGormError(err)
    }
    
    return &user, nil
}

func (r *UserRepository) Create(user *User) error {
    err := r.db.Create(user).Error
    return errors.WrapGormError(err)
}
```

### 3.3 Serviceå±‚é”™è¯¯å¤„ç†

```go
type UserService struct {
    repo *UserRepository
}

func (s *UserService) GetUser(id uint) (*User, error) {
    user, err := s.repo.FindByID(id)
    if err != nil {
        if errors.Is(err, errors.ErrNotFound) {
            return nil, fmt.Errorf("ç”¨æˆ·ä¸å­˜åœ¨: %w", err)
        }
        return nil, fmt.Errorf("æŸ¥è¯¢ç”¨æˆ·å¤±è´¥: %w", err)
    }
    return user, nil
}
```

---

## å››ã€å•å…ƒæµ‹è¯•

### 4.1 æµ‹è¯•æ•°æ®åº“è®¾ç½®

```go
package tests

import (
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func SetupTestDB() *gorm.DB {
    // ä½¿ç”¨å†…å­˜æ•°æ®åº“è¿›è¡Œæµ‹è¯•
    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    if err != nil {
        panic(err)
    }

    // è¿ç§»
    db.AutoMigrate(&User{}, &Order{})

    return db
}

func TeardownTestDB(db *gorm.DB) {
    sqlDB, _ := db.DB()
    sqlDB.Close()
}
```

### 4.2 Repositoryæµ‹è¯•

```go
package repositories_test

import (
    "testing"
    "your-project/internal/repositories"
    "your-project/tests"
)

func TestUserRepository_Create(t *testing.T) {
    db := tests.SetupTestDB()
    defer tests.TeardownTestDB(db)

    repo := repositories.NewUserRepository(db)

    user := &models.User{
        Name:  "æµ‹è¯•ç”¨æˆ·",
        Email: "test@example.com",
    }

    err := repo.Create(user)
    if err != nil {
        t.Fatalf("åˆ›å»ºç”¨æˆ·å¤±è´¥: %v", err)
    }

    if user.ID == 0 {
        t.Error("ç”¨æˆ·IDåº”è¯¥è¢«è®¾ç½®")
    }
}

func TestUserRepository_FindByID(t *testing.T) {
    db := tests.SetupTestDB()
    defer tests.TeardownTestDB(db)

    repo := repositories.NewUserRepository(db)

    // åˆ›å»ºæµ‹è¯•æ•°æ®
    user := &models.User{Name: "æµ‹è¯•ç”¨æˆ·", Email: "test@example.com"}
    repo.Create(user)

    // æµ‹è¯•æŸ¥è¯¢
    found, err := repo.FindByID(user.ID)
    if err != nil {
        t.Fatalf("æŸ¥è¯¢ç”¨æˆ·å¤±è´¥: %v", err)
    }

    if found.Name != user.Name {
        t.Errorf("æœŸæœ›åç§° %s, å¾—åˆ° %s", user.Name, found.Name)
    }
}
```

### 4.3 ä½¿ç”¨æµ‹è¯•å¤¹å…·

```go
func CreateTestUser(db *gorm.DB) *models.User {
    user := &models.User{
        Name:  "æµ‹è¯•ç”¨æˆ·",
        Email: "test@example.com",
    }
    db.Create(user)
    return user
}

func TestUserService(t *testing.T) {
    db := tests.SetupTestDB()
    defer tests.TeardownTestDB(db)

    repo := repositories.NewUserRepository(db)
    service := services.NewUserService(repo)

    // ä½¿ç”¨æµ‹è¯•å¤¹å…·
    testUser := CreateTestUser(db)

    user, err := service.GetUser(testUser.ID)
    if err != nil {
        t.Fatalf("è·å–ç”¨æˆ·å¤±è´¥: %v", err)
    }

    if user.ID != testUser.ID {
        t.Error("ç”¨æˆ·IDä¸åŒ¹é…")
    }
}
```

---

## äº”ã€æ€§èƒ½ä¼˜åŒ–

### 5.1 æŸ¥è¯¢ä¼˜åŒ–

```go
// 1. åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
db.Select("id", "name", "email").Find(&users)

// 2. ä½¿ç”¨é¢„åŠ è½½é¿å…N+1æŸ¥è¯¢
db.Preload("Orders").Find(&users)

// 3. ä½¿ç”¨ç´¢å¼•
db.Where("email = ?", email).First(&user)  // emailå­—æ®µåº”è¯¥æœ‰ç´¢å¼•

// 4. æ‰¹é‡æ“ä½œ
db.CreateInBatches(users, 100)

// 5. ä½¿ç”¨Limité¿å…æŸ¥è¯¢å¤§é‡æ•°æ®
db.Limit(100).Find(&users)
```

### 5.2 è¿æ¥æ± ä¼˜åŒ–

```go
func NewDB(dsn string) (*gorm.DB, error) {
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        PrepareStmt: true,  // å¯ç”¨é¢„ç¼–è¯‘è¯­å¥
    })
    if err != nil {
        return nil, err
    }

    sqlDB, _ := db.DB()
    
    // æ ¹æ®åº”ç”¨è´Ÿè½½è°ƒæ•´
    sqlDB.SetMaxIdleConns(20)
    sqlDB.SetMaxOpenConns(200)
    sqlDB.SetConnMaxLifetime(time.Hour)
    sqlDB.SetConnMaxIdleTime(10 * time.Minute)

    return db, nil
}
```

### 5.3 ç¼“å­˜ç­–ç•¥

```go
type CachedUserRepository struct {
    db    *gorm.DB
    cache *cache.Cache
}

func (r *CachedUserRepository) FindByID(id uint) (*User, error) {
    // å…ˆæŸ¥ç¼“å­˜
    if user, found := r.cache.Get(fmt.Sprintf("user:%d", id)); found {
        return user.(*User), nil
    }

    // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥æ•°æ®åº“
    var user User
    err := r.db.First(&user, id).Error
    if err != nil {
        return nil, err
    }

    // å†™å…¥ç¼“å­˜
    r.cache.Set(fmt.Sprintf("user:%d", id), &user, cache.DefaultExpiration)

    return &user, nil
}
```

---

## å…­ã€å®‰å…¨æœ€ä½³å®è·µ

### 6.1 SQLæ³¨å…¥é˜²æŠ¤

```go
// å¥½çš„åšæ³•ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
db.Where("email = ?", email).First(&user)

// ä¸å¥½çš„åšæ³•ï¼šå­—ç¬¦ä¸²æ‹¼æ¥ï¼ˆå±é™©ï¼ï¼‰
db.Where(fmt.Sprintf("email = '%s'", email)).First(&user)  // SQLæ³¨å…¥é£é™©
```

### 6.2 å¯†ç å¤„ç†

```go
import "golang.org/x/crypto/bcrypt"

type User struct {
    ID       uint   `gorm:"primaryKey"`
    Email    string
    Password string
}

func (u *User) BeforeCreate(tx *gorm.DB) error {
    if u.Password != "" {
        hashed, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil {
            return err
        }
        u.Password = string(hashed)
    }
    return nil
}

func (u *User) VerifyPassword(password string) bool {
    return bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password)) == nil
}
```

### 6.3 æ•æ„Ÿæ•°æ®ä¿æŠ¤

```go
// åœ¨AfterFindä¸­æ¸…é™¤æ•æ„Ÿä¿¡æ¯
func (u *User) AfterFind(tx *gorm.DB) error {
    u.Password = ""  // æ¸…é™¤å¯†ç 
    return nil
}

// æˆ–è€…ä½¿ç”¨Selectæ’é™¤æ•æ„Ÿå­—æ®µ
db.Omit("password").Find(&users)
```

---

## ä¸ƒã€éƒ¨ç½²å’Œç»´æŠ¤

### 7.1 ç¯å¢ƒé…ç½®

```go
package config

import (
    "os"
    "gorm.io/driver/mysql"
    "gorm.io/driver/postgres"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

type Config struct {
    DBDriver   string
    DBHost     string
    DBPort     string
    DBUser     string
    DBPassword string
    DBName     string
}

func LoadConfig() *Config {
    return &Config{
        DBDriver:   getEnv("DB_DRIVER", "mysql"),
        DBHost:     getEnv("DB_HOST", "localhost"),
        DBPort:     getEnv("DB_PORT", "3306"),
        DBUser:     getEnv("DB_USER", "root"),
        DBPassword: getEnv("DB_PASSWORD", ""),
        DBName:     getEnv("DB_NAME", "test"),
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func NewDB(config *Config) (*gorm.DB, error) {
    var db *gorm.DB
    var err error

    switch config.DBDriver {
    case "mysql":
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
            config.DBUser, config.DBPassword, config.DBHost, config.DBPort, config.DBName)
        db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    case "postgres":
        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable",
            config.DBHost, config.DBUser, config.DBPassword, config.DBName, config.DBPort)
        db, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})
    case "sqlite":
        db, err = gorm.Open(sqlite.Open(config.DBName+".db"), &gorm.Config{})
    default:
        return nil, fmt.Errorf("ä¸æ”¯æŒçš„æ•°æ®åº“é©±åŠ¨: %s", config.DBDriver)
    }

    return db, err
}
```

### 7.2 æ•°æ®åº“è¿ç§»

```go
package migrations

import (
    "gorm.io/gorm"
    "your-project/internal/models"
)

func RunMigrations(db *gorm.DB) error {
    return db.AutoMigrate(
        &models.User{},
        &models.Order{},
        &models.Product{},
        // ... å…¶ä»–æ¨¡å‹
    )
}
```

### 7.3 å¥åº·æ£€æŸ¥

```go
func HealthCheck(db *gorm.DB) error {
    sqlDB, err := db.DB()
    if err != nil {
        return err
    }

    // æ£€æŸ¥è¿æ¥
    if err := sqlDB.Ping(); err != nil {
        return err
    }

    // æ£€æŸ¥è¿æ¥æ± çŠ¶æ€
    stats := sqlDB.Stats()
    if stats.OpenConnections >= stats.MaxOpenConnections {
        return fmt.Errorf("è¿æ¥æ± å·²æ»¡")
    }

    return nil
}
```

---

## å…«ã€å®Œæ•´é¡¹ç›®ç¤ºä¾‹

### 8.1 é¡¹ç›®ç»“æ„

```
gorm-project/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ config.go
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â””â”€â”€ db.go
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ user.go
â”‚   â”‚   â””â”€â”€ order.go
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â”œâ”€â”€ user_repository.go
â”‚   â”‚   â””â”€â”€ order_repository.go
â”‚   â””â”€â”€ services/
â”‚       â”œâ”€â”€ user_service.go
â”‚       â””â”€â”€ order_service.go
â”œâ”€â”€ pkg/
â”‚   â””â”€â”€ errors/
â”‚       â””â”€â”€ errors.go
â”œâ”€â”€ go.mod
â””â”€â”€ README.md
```

### 8.2 æ•°æ®åº“è¿æ¥

```go
// internal/database/db.go
package database

import (
    "fmt"
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
    "your-project/internal/config"
)

var DB *gorm.DB

func InitDB(cfg *config.Config) error {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        cfg.DBUser, cfg.DBPassword, cfg.DBHost, cfg.DBPort, cfg.DBName)

    var err error
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })

    if err != nil {
        return err
    }

    // é…ç½®è¿æ¥æ± 
    sqlDB, _ := DB.DB()
    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetMaxOpenConns(100)

    return nil
}
```

### 8.3 Repositoryå®ç°

```go
// internal/repositories/user_repository.go
package repositories

import (
    "gorm.io/gorm"
    "your-project/internal/models"
    "your-project/pkg/errors"
)

type UserRepository struct {
    db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) Create(user *models.User) error {
    if err := r.db.Create(user).Error; err != nil {
        return errors.WrapGormError(err)
    }
    return nil
}

func (r *UserRepository) FindByID(id uint) (*models.User, error) {
    var user models.User
    if err := r.db.First(&user, id).Error; err != nil {
        return nil, errors.WrapGormError(err)
    }
    return &user, nil
}

func (r *UserRepository) FindByEmail(email string) (*models.User, error) {
    var user models.User
    if err := r.db.Where("email = ?", email).First(&user).Error; err != nil {
        return nil, errors.WrapGormError(err)
    }
    return &user, nil
}

func (r *UserRepository) Update(user *models.User) error {
    if err := r.db.Save(user).Error; err != nil {
        return errors.WrapGormError(err)
    }
    return nil
}

func (r *UserRepository) Delete(id uint) error {
    if err := r.db.Delete(&models.User{}, id).Error; err != nil {
        return errors.WrapGormError(err)
    }
    return nil
}
```

### 8.4 Serviceå®ç°

```go
// internal/services/user_service.go
package services

import (
    "fmt"
    "gorm.io/gorm"
    "your-project/internal/models"
    "your-project/internal/repositories"
    "your-project/pkg/errors"
)

type UserService struct {
    repo *repositories.UserRepository
}

func NewUserService(repo *repositories.UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) CreateUser(name, email string) (*models.User, error) {
    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    _, err := s.repo.FindByEmail(email)
    if err == nil {
        return nil, fmt.Errorf("é‚®ç®±å·²å­˜åœ¨")
    }
    if !errors.Is(err, errors.ErrNotFound) {
        return nil, fmt.Errorf("æŸ¥è¯¢å¤±è´¥: %w", err)
    }

    user := &models.User{
        Name:  name,
        Email: email,
    }

    if err := s.repo.Create(user); err != nil {
        return nil, fmt.Errorf("åˆ›å»ºç”¨æˆ·å¤±è´¥: %w", err)
    }

    return user, nil
}

func (s *UserService) GetUser(id uint) (*models.User, error) {
    user, err := s.repo.FindByID(id)
    if err != nil {
        return nil, fmt.Errorf("è·å–ç”¨æˆ·å¤±è´¥: %w", err)
    }
    return user, nil
}
```

---

## ä¹ã€å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### 9.1 N+1æŸ¥è¯¢é—®é¢˜

**é—®é¢˜**ï¼šæŸ¥è¯¢ç”¨æˆ·åŠå…¶è®¢å•æ—¶ï¼Œä¼šäº§ç”ŸN+1æ¬¡æŸ¥è¯¢

```go
// ä¸å¥½çš„åšæ³•
var users []User
db.Find(&users)
for _, user := range users {
    db.Model(&user).Association("Orders").Find(&user.Orders)  // N+1æŸ¥è¯¢
}

// å¥½çš„åšæ³•ï¼šä½¿ç”¨é¢„åŠ è½½
var users []User
db.Preload("Orders").Find(&users)  // åªéœ€è¦2æ¬¡æŸ¥è¯¢
```

### 9.2 äº‹åŠ¡ä½¿ç”¨ä¸å½“

**é—®é¢˜**ï¼šæ²¡æœ‰ä½¿ç”¨äº‹åŠ¡å¯¼è‡´æ•°æ®ä¸ä¸€è‡´

```go
// ä¸å¥½çš„åšæ³•
db.Create(&user)
db.Create(&profile)  // å¦‚æœè¿™é‡Œå¤±è´¥ï¼Œuserå·²ç»åˆ›å»ºäº†

// å¥½çš„åšæ³•ï¼šä½¿ç”¨äº‹åŠ¡
db.Transaction(func(tx *gorm.DB) error {
    if err := tx.Create(&user).Error; err != nil {
        return err
    }
    return tx.Create(&profile).Error
})
```

### 9.3 å¿˜è®°æ£€æŸ¥é”™è¯¯

**é—®é¢˜**ï¼šæ²¡æœ‰æ£€æŸ¥æ•°æ®åº“æ“ä½œçš„ç»“æœ

```go
// ä¸å¥½çš„åšæ³•
db.Create(&user)  // æ²¡æœ‰æ£€æŸ¥é”™è¯¯

// å¥½çš„åšæ³•ï¼šå§‹ç»ˆæ£€æŸ¥é”™è¯¯
if err := db.Create(&user).Error; err != nil {
    return fmt.Errorf("åˆ›å»ºå¤±è´¥: %w", err)
}
```

---

## åã€æ€§èƒ½ç›‘æ§

### 10.1 æ…¢æŸ¥è¯¢ç›‘æ§

```go
import (
    "time"
    "gorm.io/gorm/logger"
)

newLogger := logger.New(
    log.New(os.Stdout, "\r\n", log.LstdFlags),
    logger.Config{
        SlowThreshold: 200 * time.Millisecond,  // æ…¢æŸ¥è¯¢é˜ˆå€¼
        LogLevel:      logger.Warn,
    },
)
```

### 10.2 è¿æ¥æ± ç›‘æ§

```go
func MonitorConnectionPool(db *gorm.DB) {
    sqlDB, _ := db.DB()
    stats := sqlDB.Stats()

    log.Printf("è¿æ¥æ± çŠ¶æ€:")
    log.Printf("  æ‰“å¼€è¿æ¥: %d", stats.OpenConnections)
    log.Printf("  ä½¿ç”¨ä¸­: %d", stats.InUse)
    log.Printf("  ç©ºé—²: %d", stats.Idle)
    log.Printf("  ç­‰å¾…: %d", stats.WaitCount)
}
```

---

## æ€»ç»“

### æœ€ä½³å®è·µè¦ç‚¹

1. **é¡¹ç›®ç»“æ„**ï¼š
   - ä½¿ç”¨åˆ†å±‚æ¶æ„ï¼ˆModelã€Repositoryã€Serviceã€Handlerï¼‰
   - åˆ†ç¦»å…³æ³¨ç‚¹
   - ä¾¿äºæµ‹è¯•å’Œç»´æŠ¤

2. **æ•°æ®åº“è®¾è®¡**ï¼š
   - éµå¾ªå‘½åè§„èŒƒ
   - åˆç†è®¾è®¡ç´¢å¼•
   - æ­£ç¡®ä½¿ç”¨å¤–é”®

3. **é”™è¯¯å¤„ç†**ï¼š
   - ç»Ÿä¸€é”™è¯¯å¤„ç†
   - åŒ…è£…GORMé”™è¯¯
   - æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯

4. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - ä½¿ç”¨é¢„åŠ è½½é¿å…N+1æŸ¥è¯¢
   - åˆç†é…ç½®è¿æ¥æ± 
   - ä½¿ç”¨æ‰¹é‡æ“ä½œ
   - æ·»åŠ å¿…è¦çš„ç´¢å¼•

5. **å®‰å…¨å®è·µ**ï¼š
   - ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
   - åŠ å¯†æ•æ„Ÿæ•°æ®
   - æ¸…é™¤æ•æ„Ÿä¿¡æ¯

6. **æµ‹è¯•**ï¼š
   - ç¼–å†™å•å…ƒæµ‹è¯•
   - ä½¿ç”¨æµ‹è¯•æ•°æ®åº“
   - ä½¿ç”¨æµ‹è¯•å¤¹å…·

### éƒ¨ç½²å’Œç»´æŠ¤

1. **ç¯å¢ƒé…ç½®**ï¼šä½¿ç”¨ç¯å¢ƒå˜é‡ç®¡ç†é…ç½®
2. **æ•°æ®åº“è¿ç§»**ï¼šä½¿ç”¨AutoMigrateæˆ–è¿ç§»è„šæœ¬
3. **å¥åº·æ£€æŸ¥**ï¼šå®ç°å¥åº·æ£€æŸ¥æ¥å£
4. **ç›‘æ§**ï¼šç›‘æ§æ…¢æŸ¥è¯¢å’Œè¿æ¥æ± çŠ¶æ€

æŒæ¡è¿™äº›æœ€ä½³å®è·µåï¼Œä½ å°†èƒ½å¤Ÿæ„å»ºé«˜è´¨é‡ã€å¯ç»´æŠ¤çš„GORMåº”ç”¨ã€‚åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¦æ ¹æ®å…·ä½“éœ€æ±‚çµæ´»åº”ç”¨è¿™äº›åŸåˆ™ï¼Œä¸æ–­ä¼˜åŒ–å’Œæ”¹è¿›ã€‚