---
title: 13、Go语言高级：并发基础
date: 2026-01-06
description: 深入理解并发与并行的区别，掌握进程、线程、协程的概念及Go协程的实现原理
---

# 13、Go语言高级：并发基础

本文档从进程、线程和协程的基本概念开始，深入介绍Go语言的并发编程基础。理解这些基础概念是掌握Go并发编程的关键。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 理解进程、线程、协程的区别和联系
- ✅ 掌握并发与并行的概念
- ✅ 理解Go协程的实现原理（GMP模型）
- ✅ 掌握goroutine的创建和使用
- ✅ 了解Go的并发模型和调度机制

---

## 一、进程、线程、协程对比

在深入Go语言的并发编程之前，我们先来理解三个重要的概念：**进程（Process）**、**线程（Thread）**和**协程（Coroutine）**。

### 1.1 进程（Process）

进程是操作系统进行资源分配和调度的基本单位，是程序执行时的一个实例。

#### 进程特点：
- **独立的内存空间**：每个进程拥有独立的虚拟内存空间
- **资源隔离**：进程间的资源互不共享，一个进程崩溃不会影响其他进程
- **资源开销大**：创建、销毁和切换进程的开销较大
- **进程间通信复杂**：需要特殊的IPC（Inter-Process Communication）机制

```go
// 示例：进程的资源隔离
// 进程A: 内存地址0x1000-0x2000
// 进程B: 内存地址0x1000-0x2000  
// 实际物理地址不同，但虚拟地址相同
```

### 1.2 线程（Thread）

线程是进程内的执行单元，是CPU调度的基本单位。

#### 线程特点：
- **共享进程资源**：同一进程内的线程共享内存空间、文件描述符等
- **轻量级切换**：线程切换比进程切换开销小
- **资源共享**：线程间可以直接访问共享内存
- **安全性风险**：一个线程的崩溃可能影响整个进程

#### 进程 vs 线程 对比表：

| 特性 | 进程（Process） | 线程（Thread） |
|------|----------------|----------------|
| **资源分配** | 资源分配的基本单位 | CPU调度的基本单位 |
| **内存空间** | 独立的内存空间 | 共享进程内存空间 |
| **创建开销** | 大 | 小 |
| **切换开销** | 大 | 小 |
| **通信方式** | IPC机制 | 直接共享内存 |
| **稳定性** | 一个进程崩溃不影响其他进程 | 一个线程崩溃可能影响整个进程 |

### 1.3 协程（Coroutine）

协程是用户态的轻量级线程，由用户程序控制调度。

#### 协程特点：
- **用户态调度**：由应用程序控制，无需内核参与
- **极低开销**：创建、销毁和切换开销极小
- **协作式调度**：主动让出控制权，不会被强制中断
- **栈空间小**：通常初始栈很小（几KB），按需增长

#### 三种概念的对比：

| 概念 | 资源开销 | 切换开销 | 调度方式 | 并发数量 | 控制权 |
|------|----------|----------|----------|----------|--------|
| **进程** | 最大 | 最大 | 内核调度 | 较少（几百个） | 操作系统 |
| **线程** | 中等 | 中等 | 内核调度 | 中等（几千个） | 操作系统 |
| **协程** | 最小 | 最小 | 用户调度 | 很多（百万级） | 应用程序 |

```go
// 类比理解：
// 进程 = 一家公司（独立运营，资源独立）
// 线程 = 公司里的员工（共享资源，协同工作）
// 协程 = 员工的任务（轻量级，自主切换）
```

### 1.4 线程模型详解

在深入理解Go的GMP模型之前，我们需要了解线程模型的三种实现方式。线程模型的核心差异在于**用户级线程（协程）与内核调度实体KSE（Kernel Scheduling Entity）之间的对应关系**。

#### 内核级线程模型（1:1）

**内核级线程模型中用户线程与内核线程是一对一关系（1:1）**。

**特点：**
- 线程的创建、销毁、切换工作都由内核完成
- 每个用户线程都会被绑定到一个内核线程
- 操作系统调度器管理、调度并分派这些线程

**优点：**
- 在多处理器系统中，内核能够并行执行同一进程内的多个线程
- 如果进程中的一个线程被阻塞，不会阻塞其他线程
- 当一个线程阻塞时，内核可以根据选择运行另一个进程的线程

**缺点：**
- 线程的创建与删除都需要CPU参与，成本大
- 每次线程切换都需要陷入内核态，开销较大

**案例：** Java thread, POSIX threads

#### 用户级线程模型（N:1）

**用户线程模型中的用户线程与内核线程KSE是多对一关系（N:1）**。

**特点：**
- 线程的创建、销毁以及线程之间的协调、同步等工作都是在用户态完成
- 内核对这些是无感知的，内核此时的调度都是基于进程的
- 任意时刻每个进程只能够有一个线程在运行，且只有一个处理器内核会被分配给该进程

**优点：**
- 创建成本低，上下文切换成本低，上下文切换不需要硬件支持
- 线程管理由用户程序控制，灵活性高

**缺点：**
- 如果线程阻塞，整个进程将被阻塞，即不能利用多处理来发挥并发优势
- 无法真正利用多核CPU的并行能力

#### 混合型线程模型（N:M）

**混合型线程模型中用户线程与内核线程KSE是多对多关系（N:M）**。

**特点：**
- 结合了内核级线程和用户级线程的优点
- 用户线程与内核线程是多对多关系
- 线程的创建、调度、同步等由用户态线程库完成
- 多个用户线程可以映射到多个内核线程

**优点：**
- 创建和切换成本低（用户态完成）
- 可以充分利用多核CPU的并行能力
- 一个线程阻塞不会影响其他线程

**缺点：**
- 实现复杂，需要用户态和内核态的协调

**Go语言的线程模型：** Go采用的就是混合型线程模型，通过GMP调度器实现了高效的N:M映射。

#### 三种线程模型对比：

| 特性 | 内核级线程（1:1） | 用户级线程（N:1） | 混合型线程（N:M） |
|------|------------------|------------------|------------------|
| **用户线程:KSE** | 1:1 | N:1 | N:M |
| **创建成本** | 高 | 低 | 低 |
| **切换成本** | 高（需要内核态） | 低（用户态） | 低（用户态） |
| **多核利用** | 是 | 否 | 是 |
| **线程阻塞影响** | 不影响其他线程 | 阻塞整个进程 | 不影响其他线程 |
| **实现复杂度** | 低 | 中 | 高 |
| **代表案例** | Java, POSIX | 早期协程库 | Go, Erlang |

---

## 二、并发与并行

### 2.0 并发 vs 并行的区别

在理解Go的并发模型之前，我们需要先理解两个重要概念：**并发（Concurrency）**和**并行（Parallelism）**。

#### 并发 vs 并行

**并发（Concurrency）**：
- 指**同时处理多个任务**的能力
- 多个任务可以在**时间上重叠**执行
- 不要求同时执行，可以在单核CPU上通过**时间片轮转**实现
- 关注的是**程序的设计结构**，如何组织代码以处理多个任务
- **核心**：任务之间的交替执行，通过快速切换给用户"同时"的感觉

**并行（Parallelism）**：
- 指**同时执行多个任务**
- 多个任务**真正同时**运行
- 需要**多核CPU**或多台机器
- 关注的是**执行效率**，如何同时执行多个任务
- **核心**：任务的同时执行，真正意义上的"同时"

#### 形象比喻

想象你在做两件事：**煮咖啡**和**烤面包**。

- **并发**：你可以在等水开的时候去准备面包，然后回来继续煮咖啡。虽然你一次只做一件事，但通过合理安排，两件事在时间上重叠了。
- **并行**：如果你有两只手，可以一只手煮咖啡，另一只手烤面包，真正同时进行。

#### 对比表格

| 特性 | 并发（Concurrency） | 并行（Parallelism） |
|------|-------------------|-------------------|
| **定义** | 同时处理多个任务的能力 | 同时执行多个任务 |
| **执行方式** | 时间片轮转，交替执行 | 真正同时执行 |
| **硬件要求** | 单核CPU即可 | 需要多核CPU |
| **关注点** | 程序结构设计 | 执行效率 |
| **Go语言** | Goroutine | GOMAXPROCS控制 |
| **类比** | 一个人同时做多件事 | 多个人同时做一件事 |

---

## 三、Go协程（Goroutine）基础

Go语言通过**Goroutine**实现了轻量级的并发。Goroutine是Go并发编程的核心，理解其特点和使用方法对于掌握Go并发编程至关重要。

> **注意**：关于GMP调度模型的详细内容，请参考[13.1、Go语言高级：GMP调度模型](./13.1.Go语言高级：GMP调度模型.md)文档。

### 3.1 Goroutine的特点

1. **极轻量级**：初始栈仅2KB，按需增长
2. **创建成本低**：可以创建成千上万个Goroutine
3. **自动调度**：由Go运行时自动管理，无需手动管理线程
4. **内存效率高**：共享内存池，减少内存碎片
5. **协作式调度**：通过channel等机制实现goroutine间的通信和同步

---

## 四、Goroutine基础使用

### 4.1 基本使用

Goroutine的创建非常简单，只需在函数调用前加上 `go` 关键字。

```go
package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    // 启动goroutine
    go sayHello()

    // 主goroutine继续执行
    fmt.Println("Hello from main!")

    // 等待一下，让goroutine有时间执行
    time.Sleep(100 * time.Millisecond)
}
```

### 4.2 多个Goroutine

```go
package main

import (
    "fmt"
    "time"
)

func printNumbers(id int) {
    for i := 1; i <= 5; i++ {
        fmt.Printf("Goroutine %d: %d\n", id, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // 启动多个goroutine
    for i := 1; i <= 3; i++ {
        go printNumbers(i)
    }

    // 等待所有goroutine完成
    time.Sleep(2 * time.Second)
}
```

### 4.3 Goroutine性能对比

让我们对比一下使用goroutine和不使用goroutine的性能差异：

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

// 模拟一个耗时任务
func task(id int) int {
    sum := 0
    for i := 0; i < 1000000; i++ {
        sum += i
    }
    return sum
}

// 顺序执行
func sequentialExecution(tasks int) time.Duration {
    start := time.Now()
    
    for i := 0; i < tasks; i++ {
        task(i)
    }
    
    return time.Since(start)
}

// 并发执行
func concurrentExecution(tasks int) time.Duration {
    start := time.Now()
    var wg sync.WaitGroup
    
    for i := 0; i < tasks; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            task(id)
        }(i)
    }
    
    wg.Wait()
    return time.Since(start)
}

func main() {
    tasks := 10
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())
    
    fmt.Println("=== 性能对比 ===")
    fmt.Printf("任务数量: %d\n", tasks)
    
    seqTime := sequentialExecution(tasks)
    fmt.Printf("顺序执行耗时: %v\n", seqTime)
    
    concTime := concurrentExecution(tasks)
    fmt.Printf("并发执行耗时: %v\n", concTime)
    
    speedup := float64(seqTime) / float64(concTime)
    fmt.Printf("加速比: %.2fx\n", speedup)
}
```

**输出示例**：
```
CPU核心数: 8
=== 性能对比 ===
任务数量: 10
顺序执行耗时: 45ms
并发执行耗时: 12ms
加速比: 3.75x
```

这个示例展示了在多核CPU上，使用goroutine并发执行可以显著提升性能。

---

## 五、sync.WaitGroup

`sync.WaitGroup` 是Go语言中用于等待一组goroutine完成的同步原语。它解决了主goroutine需要等待所有子goroutine完成的问题。

### 5.1 为什么需要WaitGroup？

在使用goroutine时，我们经常遇到这样的问题：

```go
package main

import (
    "fmt"
    "time"
)

func worker(id int) {
    fmt.Printf("Worker %d 开始工作\n", id)
    time.Sleep(1 * time.Second)  // 模拟工作
    fmt.Printf("Worker %d 完成工作\n", id)
}

func main() {
    // 启动多个goroutine
    for i := 1; i <= 3; i++ {
        go worker(i)
    }
    
    // 问题：主goroutine如何知道所有worker都完成了？
    // 如果直接结束，worker可能还没执行完
    fmt.Println("主goroutine结束")
    // 输出可能只有"主goroutine结束"，worker的输出可能看不到
}
```

**问题**：主goroutine不知道子goroutine何时完成，可能提前退出。

### 5.2 WaitGroup的作用

`sync.WaitGroup` 提供了三个核心方法：

1. **`Add(delta int)`**：增加等待的goroutine数量
2. **`Done()`**：减少等待的goroutine数量（相当于 `Add(-1)`）
3. **`Wait()`**：阻塞直到计数器归零

### 5.3 基本使用

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // 完成时调用Done，减少计数器
    
    fmt.Printf("Worker %d 开始工作\n", id)
    time.Sleep(1 * time.Second)  // 模拟工作
    fmt.Printf("Worker %d 完成工作\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    // 启动3个goroutine
    for i := 1; i <= 3; i++ {
        wg.Add(1)  // 增加计数器
        go worker(i, &wg)
    }
    
    wg.Wait()  // 等待所有goroutine完成
    fmt.Println("所有worker都完成了！")
}
```

**输出**：
```
Worker 1 开始工作
Worker 2 开始工作
Worker 3 开始工作
Worker 1 完成工作
Worker 2 完成工作
Worker 3 完成工作
所有worker都完成了！
```

### 5.4 工作原理

WaitGroup内部维护一个计数器：
- `Add(n)`：计数器 +n
- `Done()`：计数器 -1
- `Wait()`：当计数器为0时返回，否则阻塞

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    
    fmt.Println("初始状态：计数器 = 0")
    
    // 启动5个goroutine
    for i := 1; i <= 5; i++ {
        wg.Add(1)  // 每次Add(1)，计数器+1
        fmt.Printf("启动goroutine %d，计数器 = %d\n", i, i)
        
        go func(id int) {
            defer wg.Done()  // 完成时计数器-1
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("Goroutine %d 完成\n", id)
        }(i)
    }
    
    fmt.Println("等待所有goroutine完成...")
    wg.Wait()  // 阻塞直到计数器归零
    fmt.Println("所有goroutine都完成了！")
}
```

### 5.5 常见使用模式

#### 1. 使用defer确保Done被调用

```go
func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // 使用defer确保即使panic也会调用Done
    
    // 可能panic的代码
    if id == 0 {
        panic("invalid id")
    }
    
    // 工作代码...
}
```

#### 2. 批量Add

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    numWorkers := 10
    
    // 一次性Add所有goroutine数量
    wg.Add(numWorkers)
    
    for i := 0; i < numWorkers; i++ {
        go func(id int) {
            defer wg.Done()
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("Worker %d 完成\n", id)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("所有worker完成")
}
```

#### 3. 嵌套使用

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func taskGroup(groupID int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    var innerWg sync.WaitGroup
    numTasks := 3
    
    innerWg.Add(numTasks)
    for i := 0; i < numTasks; i++ {
        go func(taskID int) {
            defer innerWg.Done()
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("Group %d, Task %d 完成\n", groupID, taskID)
        }(i)
    }
    
    innerWg.Wait()
    fmt.Printf("Group %d 所有任务完成\n", groupID)
}

func main() {
    var wg sync.WaitGroup
    numGroups := 2
    
    wg.Add(numGroups)
    for i := 0; i < numGroups; i++ {
        go taskGroup(i, &wg)
    }
    
    wg.Wait()
    fmt.Println("所有组都完成了")
}
```

### 5.6 常见错误和注意事项

#### 1. ❌ 错误：传递值而非指针

```go
// 错误：传递值
func worker(wg sync.WaitGroup) {
    defer wg.Done()
    // ...
}

func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go worker(wg)  // 错误！传递了副本
    wg.Wait()  // 可能永远等待
}

// 正确：传递指针
func worker(wg *sync.WaitGroup) {
    defer wg.Done()
    // ...
}

func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go worker(&wg)  // 正确！传递指针
    wg.Wait()
}
```

**原因**：`sync.WaitGroup` 包含内部状态，传递值会创建副本，导致 `Done()` 操作的是副本而非原始对象。

#### 2. ❌ 错误：Add和Done不匹配

```go
// 错误：Add了3次，但只Done了2次
var wg sync.WaitGroup
wg.Add(3)
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
// 忘记第三个Done
wg.Wait()  // 永远等待

// 正确：确保Add和Done匹配
var wg sync.WaitGroup
wg.Add(3)
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
wg.Wait()
```

**最佳实践**：在goroutine启动前调用 `Add()`，在goroutine内部使用 `defer wg.Done()` 确保一定会调用。

#### 3. ❌ 错误：在goroutine启动前调用Wait

```go
// 错误：Wait在goroutine启动之前
var wg sync.WaitGroup
wg.Add(1)
wg.Wait()  // 立即返回，因为计数器已经是0（Add后立即Wait）
go func() {
    defer wg.Done()
    // ...
}()

// 正确：Wait在goroutine启动之后
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    // ...
}()
wg.Wait()  // 等待goroutine完成
```

#### 4. ❌ 错误：重复使用WaitGroup

```go
// 错误：WaitGroup不能重复使用
var wg sync.WaitGroup

// 第一轮
wg.Add(2)
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
wg.Wait()

// 第二轮：不能重复使用同一个WaitGroup
wg.Add(2)  // 可能有问题
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
wg.Wait()

// 正确：每次使用新的WaitGroup或确保计数器归零后再使用
```

**说明**：虽然WaitGroup在计数器归零后可以重用，但为了避免混淆，建议每次使用新的WaitGroup实例。

---

## 六、Go并发最佳实践

### 6.1 选择合适的并发策略

根据任务类型选择合适的并发策略：

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

// 1. CPU密集型：goroutine数量 = CPU核心数
func cpuIntensiveWork() {
    numCPU := runtime.NumCPU()
    var wg sync.WaitGroup

    fmt.Printf("CPU密集型任务，使用 %d 个goroutine（等于CPU核心数）\n", numCPU)
    
    for i := 0; i < numCPU; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // CPU密集型任务
            for j := 0; j < 1000000; j++ {
                // 消耗CPU的计算
            }
        }()
    }
    wg.Wait()
}

// 2. IO密集型：可以使用更多goroutine
func ioIntensiveWork() {
    var wg sync.WaitGroup

    // 可以根据实际情况调整，比如100-1000个
    numWorkers := 100
    fmt.Printf("IO密集型任务，使用 %d 个goroutine\n", numWorkers)
    
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // IO操作（网络请求、文件读写等）
            time.Sleep(10 * time.Millisecond)  // 模拟IO等待
        }()
    }
    wg.Wait()
}

func main() {
    fmt.Println("根据任务类型选择合适的并发策略：")
    fmt.Println("1. CPU密集型：goroutine数 = CPU核心数")
    fmt.Println("2. IO密集型：可以使用更多goroutine")
    
    fmt.Println("\n演示CPU密集型任务:")
    start := time.Now()
    cpuIntensiveWork()
    fmt.Printf("CPU密集型任务耗时: %v\n", time.Since(start))
    
    fmt.Println("\n演示IO密集型任务:")
    start = time.Now()
    ioIntensiveWork()
    fmt.Printf("IO密集型任务耗时: %v\n", time.Since(start))
}
```

### 6.2 避免常见陷阱

#### 1. 避免Goroutine泄漏

```go
package main

import (
    "fmt"
    "time"
)

// 错误：可能导致goroutine泄漏
func badExample() {
    ch := make(chan int)
    // 发送者在goroutine中，但没有接收者
    // 这会导致goroutine永远阻塞
    go func() {
        ch <- 42  // 这里会永远阻塞
    }()
    
    // 如果不接收，goroutine会泄漏
    // time.Sleep(1 * time.Second)
    // fmt.Println(<-ch)  // 如果启用这行，就不会泄漏
}

// 正确：避免goroutine泄漏
func goodExample() {
    ch := make(chan int, 1)  // 使用带缓冲的channel
    go func() {
        ch <- 42  // 不会阻塞，因为有缓冲
    }()
    
    fmt.Println(<-ch)  // 接收数据
}

func main() {
    fmt.Println("避免goroutine泄漏:")
    goodExample()
}
```

#### 2. 合理设置GOMAXPROCS

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    // 获取当前GOMAXPROCS设置
    current := runtime.GOMAXPROCS(0)
    fmt.Printf("当前GOMAXPROCS: %d\n", current)
    
    // 获取CPU核心数
    cpuNum := runtime.NumCPU()
    fmt.Printf("CPU核心数: %d\n", cpuNum)
    
    // 通常不需要手动设置，Go会自动设置为CPU核心数
    // runtime.GOMAXPROCS(cpuNum)  // 默认就是这样设置的
}
```

---

## 总结

### 核心概念回顾

1. **进程、线程、协程**：
   - **进程**：资源分配的基本单位，独立内存空间
   - **线程**：CPU调度的基本单位，共享进程资源
   - **协程**：用户态轻量级线程，用户控制调度

2. **并发 vs 并行**：
   - **并发**：同时处理多个任务（时间重叠）
   - **并行**：同时执行多个任务（真正同时）

3. **Goroutine使用**：
   - 使用`go`关键字创建
   - 通过`sync.WaitGroup`同步
   - 根据任务类型调整并发策略

掌握这些基础知识后，你将能够更好地理解Go语言的并发编程模型，并在实际项目中正确使用goroutine。

> **深入学习**：关于GMP调度模型的详细内容，请参考[13.1、Go语言高级：GMP调度模型](./13.1.Go语言高级：GMP调度模型.md)文档。

在接下来的课程中，我们将学习goroutine之间的通信机制——Channel。