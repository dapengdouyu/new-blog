---
title: 16ã€Goè¯­è¨€é«˜çº§ï¼šå¹¶å‘æ¨¡å¼ä¸å®‰å…¨
date: 2026-01-06
description: æ·±å…¥ç†è§£Goè¯­è¨€ä¸­çš„å¹¶å‘è®¾è®¡æ¨¡å¼ã€å¹¶å‘å®‰å…¨æœºåˆ¶å’Œå¸¸è§å¹¶å‘é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ
---

# 16ã€Goè¯­è¨€é«˜çº§ï¼šå¹¶å‘æ¨¡å¼ä¸å®‰å…¨

æœ¬æ–‡æ¡£å°†è¯¦ç»†ä»‹ç»Goè¯­è¨€ä¸­çš„å¹¶å‘è®¾è®¡æ¨¡å¼ã€å¹¶å‘å®‰å…¨æœºåˆ¶ä»¥åŠå¸¸è§å¹¶å‘é—®é¢˜çš„è§£å†³æ–¹æ¡ˆã€‚è¿™äº›çŸ¥è¯†æ˜¯æ„å»ºé«˜è´¨é‡å¹¶å‘ç¨‹åºçš„å…³é”®ã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡å¸¸è§çš„å¹¶å‘è®¾è®¡æ¨¡å¼
- âœ… ç†è§£å¹¶å‘å®‰å…¨çš„æ¦‚å¿µå’Œå®ç°æœºåˆ¶
- âœ… è¯†åˆ«å’Œè§£å†³ç«æ€æ¡ä»¶é—®é¢˜
- âœ… ä½¿ç”¨åŸå­æ“ä½œè¿›è¡Œé«˜æ•ˆåŒæ­¥
- âœ… å®ç°çº¿ç¨‹å®‰å…¨çš„æ•°æ®ç»“æ„

---

## ä¸€ã€å¹¶å‘è®¾è®¡æ¨¡å¼

### 1.1 å·¥ä½œæ± æ¨¡å¼ï¼ˆWorker Poolï¼‰

å·¥ä½œæ± æ¨¡å¼æ˜¯ä¸€ç§å¸¸è§çš„å¹¶å‘è®¾è®¡æ¨¡å¼ï¼Œç”¨äºå¤„ç†å¤§é‡ç›¸ä¼¼ä»»åŠ¡ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ä»»åŠ¡ç»“æ„
type Job struct {
    ID      int
    Payload string
}

// ç»“æœç»“æ„
type Result struct {
    JobID int
    Data  string
}

// å·¥ä½œæ± ç»“æ„
type WorkerPool struct {
    workers    int
    jobQueue   chan Job
    resultChan chan Result
    wg         sync.WaitGroup
}

// åˆ›å»ºå·¥ä½œæ± 
func NewWorkerPool(workers int) *WorkerPool {
    return &WorkerPool{
        workers:    workers,
        jobQueue:   make(chan Job, 100),      // ä»»åŠ¡é˜Ÿåˆ—
        resultChan: make(chan Result, 100),   // ç»“æœé˜Ÿåˆ—
    }
}

// å·¥ä½œå‡½æ•°
func (wp *WorkerPool) worker(id int) {
    defer wp.wg.Done()
    
    for job := range wp.jobQueue {
        fmt.Printf("Worker %d å¼€å§‹å¤„ç†ä»»åŠ¡ %d: %s\n", id, job.ID, job.Payload)
        
        // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
        time.Sleep(500 * time.Millisecond)
        
        // å¤„ç†ä»»åŠ¡
        result := Result{
            JobID: job.ID,
            Data:  fmt.Sprintf("å¤„ç†ç»“æœ_%d_%s", job.ID, job.Payload),
        }
        
        wp.resultChan <- result
        fmt.Printf("Worker %d å®Œæˆä»»åŠ¡ %d\n", id, job.ID)
    }
}

// å¯åŠ¨å·¥ä½œæ± 
func (wp *WorkerPool) Start() {
    for i := 1; i <= wp.workers; i++ {
        wp.wg.Add(1)
        go wp.worker(i)
    }
}

// æäº¤ä»»åŠ¡
func (wp *WorkerPool) SubmitJob(job Job) {
    wp.jobQueue <- job
}

// å…³é—­å·¥ä½œæ± 
func (wp *WorkerPool) Close() {
    close(wp.jobQueue)
    wp.wg.Wait()
    close(wp.resultChan)
}

// è·å–ç»“æœ
func (wp *WorkerPool) GetResults() <-chan Result {
    return wp.resultChan
}

func workerPoolExample() {
    // åˆ›å»ºå·¥ä½œæ± ï¼Œä½¿ç”¨3ä¸ªå·¥ä½œåç¨‹
    pool := NewWorkerPool(3)
    pool.Start()
    
    // æäº¤ä»»åŠ¡
    for i := 1; i <= 10; i++ {
        job := Job{
            ID:      i,
            Payload: fmt.Sprintf("ä»»åŠ¡æ•°æ®_%d", i),
        }
        pool.SubmitJob(job)
    }
    
    // å…³é—­å·¥ä½œæ± å¹¶æ”¶é›†ç»“æœ
    go func() {
        pool.Close()
    }()
    
    // æ¥æ”¶ç»“æœ
    resultsReceived := 0
    for result := range pool.GetResults() {
        fmt.Printf("æ¥æ”¶åˆ°ç»“æœ: %v\n", result)
        resultsReceived++
        if resultsReceived >= 10 {
            break
        }
    }
}

func main() {
    fmt.Println("=== å·¥ä½œæ± æ¨¡å¼ç¤ºä¾‹ ===")
    workerPoolExample()
}
```

### 1.2 ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼

ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼é€šè¿‡Channelè¿æ¥ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ï¼Œå®ç°è§£è€¦ã€‚

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

// äº§å“ç»“æ„
type Product struct {
    ID   int
    Name string
    Time time.Time
}

// ç”Ÿäº§è€…
func producer(id int, out chan<- Product, wg *sync.WaitGroup, maxProducts int) {
    defer wg.Done()
    
    for i := 1; i <= maxProducts; i++ {
        product := Product{
            ID:   i,
            Name: fmt.Sprintf("Product-%d-%d", id, i),
            Time: time.Now(),
        }
        
        // éšæœºå»¶è¿Ÿæ¨¡æ‹Ÿç”Ÿäº§æ—¶é—´
        time.Sleep(time.Duration(rand.Intn(500)) * time.Millisecond)
        
        out <- product
        fmt.Printf("ç”Ÿäº§è€… %d ç”Ÿäº§äº†: %s\n", id, product.Name)
    }
}

// æ¶ˆè´¹è€…
func consumer(id int, in <-chan Product, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for product := range in {
        // éšæœºå»¶è¿Ÿæ¨¡æ‹Ÿæ¶ˆè´¹æ—¶é—´
        time.Sleep(time.Duration(rand.Intn(300)) * time.Millisecond)
        
        fmt.Printf("æ¶ˆè´¹è€… %d æ¶ˆè´¹äº†: %s at %v\n", id, product.Name, product.Time)
    }
}

func producerConsumerExample() {
    // åˆ›å»ºäº§å“Channel
    products := make(chan Product, 20) // å¸¦ç¼“å†²Channel
    
    var producerWg, consumerWg sync.WaitGroup
    
    // å¯åŠ¨3ä¸ªç”Ÿäº§è€…
    for i := 1; i <= 3; i++ {
        producerWg.Add(1)
        go producer(i, products, &producerWg, 5) // æ¯ä¸ªç”Ÿäº§è€…ç”Ÿäº§5ä¸ªäº§å“
    }
    
    // å¯åŠ¨2ä¸ªæ¶ˆè´¹è€…
    for i := 1; i <= 2; i++ {
        consumerWg.Add(1)
        go consumer(i, products, &consumerWg)
    }
    
    // åœ¨ç”Ÿäº§è€…å®Œæˆåå…³é—­Channel
    go func() {
        producerWg.Wait()
        close(products)
    }()
    
    // ç­‰å¾…æ¶ˆè´¹è€…å®Œæˆ
    consumerWg.Wait()
}

func main() {
    fmt.Println("\n=== ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ç¤ºä¾‹ ===")
    rand.Seed(time.Now().UnixNano())
    producerConsumerExample()
}
```

### 1.3 å‘å¸ƒ-è®¢é˜…æ¨¡å¼

å‘å¸ƒ-è®¢é˜…æ¨¡å¼å…è®¸å¤šä¸ªè®¢é˜…è€…æ¥æ”¶å‘å¸ƒçš„æ¶ˆæ¯ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// æ¶ˆæ¯ç±»å‹
type Message struct {
    Topic   string
    Content string
    Time    time.Time
}

// è®¢é˜…è€…æ¥å£
type Subscriber interface {
    GetID() string
    Receive(msg Message)
}

// å…·ä½“è®¢é˜…è€…å®ç°
type ConcreteSubscriber struct {
    id string
}

func (cs *ConcreteSubscriber) GetID() string {
    return cs.id
}

func (cs *ConcreteSubscriber) Receive(msg Message) {
    fmt.Printf("[è®¢é˜…è€… %s] æ¥æ”¶åˆ°æ¶ˆæ¯ - Topic: %s, Content: %s, Time: %v\n", 
               cs.id, msg.Topic, msg.Content, msg.Time)
    
    // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
    time.Sleep(100 * time.Millisecond)
}

// å‘å¸ƒ-è®¢é˜…ç³»ç»Ÿ
type PubSub struct {
    subscribers map[string][]Subscriber
    mutex       sync.RWMutex
    msgChan     chan Message
    done        chan struct{}
}

func NewPubSub() *PubSub {
    ps := &PubSub{
        subscribers: make(map[string][]Subscriber),
        msgChan:     make(chan Message, 100),
        done:        make(chan struct{}),
    }
    
    // å¯åŠ¨æ¶ˆæ¯åˆ†å‘åç¨‹
    go ps.dispatchMessages()
    
    return ps
}

// è®¢é˜…ä¸»é¢˜
func (ps *PubSub) Subscribe(topic string, sub Subscriber) {
    ps.mutex.Lock()
    defer ps.mutex.Unlock()
    
    ps.subscribers[topic] = append(ps.subscribers[topic], sub)
    fmt.Printf("è®¢é˜…è€… %s è®¢é˜…äº†ä¸»é¢˜ %s\n", sub.GetID(), topic)
}

// å‘å¸ƒæ¶ˆæ¯
func (ps *PubSub) Publish(msg Message) {
    ps.msgChan <- msg
}

// åˆ†å‘æ¶ˆæ¯
func (ps *PubSub) dispatchMessages() {
    for {
        select {
        case msg := <-ps.msgChan:
            ps.distributeMessage(msg)
        case <-ps.done:
            return
        }
    }
}

// åˆ†å‘æ¶ˆæ¯ç»™è®¢é˜…è€…
func (ps *PubSub) distributeMessage(msg Message) {
    ps.mutex.RLock()
    subscribers, exists := ps.subscribers[msg.Topic]
    ps.mutex.RUnlock()
    
    if !exists {
        return
    }
    
    // å¹¶å‘å‘é€ç»™æ‰€æœ‰è®¢é˜…è€…
    var wg sync.WaitGroup
    for _, sub := range subscribers {
        wg.Add(1)
        go func(s Subscriber) {
            defer wg.Done()
            s.Receive(msg)
        }(sub)
    }
    wg.Wait()
}

// å…³é—­å‘å¸ƒ-è®¢é˜…ç³»ç»Ÿ
func (ps *PubSub) Close() {
    close(ps.msgChan)
    close(ps.done)
}

func pubSubExample() {
    pubsub := NewPubSub()
    
    // åˆ›å»ºè®¢é˜…è€…
    sub1 := &ConcreteSubscriber{id: "Sub1"}
    sub2 := &ConcreteSubscriber{id: "Sub2"}
    sub3 := &ConcreteSubscriber{id: "Sub3"}
    
    // è®¢é˜…ä¸åŒä¸»é¢˜
    pubsub.Subscribe("news", sub1)
    pubsub.Subscribe("news", sub2)
    pubsub.Subscribe("sports", sub2)
    pubsub.Subscribe("tech", sub3)
    
    // å‘å¸ƒæ¶ˆæ¯
    time.Sleep(100 * time.Millisecond) // ç­‰å¾…è®¢é˜…å®Œæˆ
    
    pubsub.Publish(Message{Topic: "news", Content: "ä»Šæ—¥æ–°é—»"})
    pubsub.Publish(Message{Topic: "sports", Content: "ä½“è‚²æ–°é—»"})
    pubsub.Publish(Message{Topic: "tech", Content: "ç§‘æŠ€æ–°é—»"})
    pubsub.Publish(Message{Topic: "news", Content: "çªå‘æ–°é—»"})
    
    time.Sleep(1 * time.Second) // ç­‰å¾…æ¶ˆæ¯å¤„ç†å®Œæˆ
    pubsub.Close()
}

func main() {
    fmt.Println("\n=== å‘å¸ƒ-è®¢é˜…æ¨¡å¼ç¤ºä¾‹ ===")
    pubSubExample()
}
```

---

## äºŒã€å¹¶å‘å®‰å…¨æœºåˆ¶

### 2.1 ç«æ€æ¡ä»¶ï¼ˆRace Conditionï¼‰

ç«æ€æ¡ä»¶å‘ç”Ÿåœ¨å¤šä¸ªgoroutineåŒæ—¶è®¿é—®å…±äº«èµ„æºæ—¶ï¼Œå¯¼è‡´ç¨‹åºè¡Œä¸ºä¸ç¡®å®šã€‚

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// éçº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨ï¼ˆç«æ€æ¡ä»¶ç¤ºä¾‹ï¼‰
type UnsafeCounter struct {
    value int
}

func (uc *UnsafeCounter) Increment() {
    uc.value++ // éåŸå­æ“ä½œï¼šè¯»å–->ä¿®æ”¹->å†™å…¥
}

func (uc *UnsafeCounter) Value() int {
    return uc.value
}

// æ¼”ç¤ºç«æ€æ¡ä»¶
func raceConditionDemo() {
    counter := &UnsafeCounter{}
    var wg sync.WaitGroup
    
    // å¯åŠ¨1000ä¸ªgoroutineåŒæ—¶å¢åŠ è®¡æ•°å™¨
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 10; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    
    fmt.Printf("æœŸæœ›å€¼: %d, å®é™…å€¼: %d\n", 10000, counter.Value())
    fmt.Printf("å­˜åœ¨ç«æ€æ¡ä»¶: %t\n", counter.Value() != 10000)
}

func main() {
    fmt.Println("\n=== ç«æ€æ¡ä»¶ç¤ºä¾‹ ===")
    raceConditionDemo()
}
```

### 2.2 äº’æ–¥é”ï¼ˆMutexï¼‰è§£å†³æ–¹æ¡ˆ

```go
package main

import (
    "fmt"
    "sync"
)

// çº¿ç¨‹å®‰å…¨çš„è®¡æ•°å™¨
type SafeCounter struct {
    mu    sync.Mutex
    value int
}

func (sc *SafeCounter) Increment() {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    sc.value++
}

func (sc *SafeCounter) Value() int {
    sc.mu.Lock()
    defer sc.mu.Unlock()
    return sc.value
}

// æ¼”ç¤ºä½¿ç”¨äº’æ–¥é”è§£å†³ç«æ€æ¡ä»¶
func mutexSolutionDemo() {
    counter := &SafeCounter{}
    var wg sync.WaitGroup
    
    // å¯åŠ¨1000ä¸ªgoroutineåŒæ—¶å¢åŠ è®¡æ•°å™¨
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 10; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    
    fmt.Printf("æœŸæœ›å€¼: %d, å®é™…å€¼: %d\n", 10000, counter.Value())
    fmt.Printf("ç«æ€æ¡ä»¶å·²è§£å†³: %t\n", counter.Value() == 10000)
}

func main() {
    fmt.Println("\n=== äº’æ–¥é”è§£å†³æ–¹æ¡ˆ ===")
    mutexSolutionDemo()
}
```

### 2.3 åŸå­æ“ä½œï¼ˆAtomic Operationsï¼‰

åŸå­æ“ä½œæä¾›æ›´é«˜æ•ˆçš„åŒæ­¥æœºåˆ¶ï¼Œé€‚ç”¨äºç®€å•çš„è®¡æ•°å’Œæ ‡å¿—æ“ä½œã€‚

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// ä½¿ç”¨åŸå­æ“ä½œçš„è®¡æ•°å™¨
type AtomicCounter struct {
    value int64
}

func (ac *AtomicCounter) Increment() {
    atomic.AddInt64(&ac.value, 1)
}

func (ac *AtomicCounter) Value() int64 {
    return atomic.LoadInt64(&ac.value)
}

// æ€§èƒ½æ¯”è¾ƒ
func performanceComparison() {
    // åŸå­æ“ä½œç‰ˆæœ¬
    atomicCounter := &AtomicCounter{}
    var wg1 sync.WaitGroup
    
    start1 := time.Now()
    for i := 0; i < 1000; i++ {
        wg1.Add(1)
        go func() {
            defer wg1.Done()
            for j := 0; j < 1000; j++ {
                atomicCounter.Increment()
            }
        }()
    }
    wg1.Wait()
    atomicDuration := time.Since(start1)
    
    // äº’æ–¥é”ç‰ˆæœ¬
    mutexCounter := &SafeCounter{} // ä½¿ç”¨ä¸Šé¢å®šä¹‰çš„SafeCounter
    var wg2 sync.WaitGroup
    
    start2 := time.Now()
    for i := 0; i < 1000; i++ {
        wg2.Add(1)
        go func() {
            defer wg2.Done()
            for j := 0; j < 1000; j++ {
                mutexCounter.Increment()
            }
        }()
    }
    wg2.Wait()
    mutexDuration := time.Since(start2)
    
    fmt.Printf("åŸå­æ“ä½œè€—æ—¶: %v, ç»“æœ: %d\n", atomicDuration, atomicCounter.Value())
    fmt.Printf("äº’æ–¥é”è€—æ—¶: %v, ç»“æœ: %d\n", mutexDuration, mutexCounter.Value())
    fmt.Printf("åŸå­æ“ä½œæ€§èƒ½æå‡: %.2fx\n", float64(mutexDuration)/float64(atomicDuration))
}

func main() {
    fmt.Println("\n=== åŸå­æ“ä½œæ€§èƒ½æ¯”è¾ƒ ===")
    performanceComparison()
}
```

### 2.4 è¯»å†™é”ï¼ˆRWMutexï¼‰

è¯»å†™é”é€‚ç”¨äºè¯»å¤šå†™å°‘çš„åœºæ™¯ã€‚

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// çº¿ç¨‹å®‰å…¨çš„æ˜ å°„
type SafeMap struct {
    data map[string]interface{}
    mu   sync.RWMutex
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]interface{}),
    }
}

// å†™æ“ä½œ
func (sm *SafeMap) Set(key string, value interface{}) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.data[key] = value
}

// è¯»æ“ä½œ
func (sm *SafeMap) Get(key string) (interface{}, bool) {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    value, exists := sm.data[key]
    return value, exists
}

// è·å–æ‰€æœ‰é”®
func (sm *SafeMap) Keys() []string {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    keys := make([]string, 0, len(sm.data))
    for k := range sm.data {
        keys = append(keys, k)
    }
    return keys
}

func rwMutexExample() {
    sm := NewSafeMap()
    var wg sync.WaitGroup
    
    // å¯åŠ¨å†™åç¨‹
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 10; i++ {
            key := fmt.Sprintf("key%d", i)
            sm.Set(key, fmt.Sprintf("value%d", i))
            fmt.Printf("å†™å…¥: %s = %s\n", key, sm.data[key])
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    // å¯åŠ¨å¤šä¸ªè¯»åç¨‹
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(readerID int) {
            defer wg.Done()
            for j := 0; j < 5; j++ {
                keys := sm.Keys()
                for _, key := range keys {
                    if value, exists := sm.Get(key); exists {
                        fmt.Printf("Reader %d è¯»å–: %s = %v\n", readerID, key, value)
                    }
                }
                time.Sleep(50 * time.Millisecond)
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("æœ€ç»ˆæ•°æ®: %v\n", sm.data)
}

func main() {
    fmt.Println("\n=== è¯»å†™é”ç¤ºä¾‹ ===")
    rwMutexExample()
}
```

---

## ä¸‰ã€å¹¶å‘å®‰å…¨æ•°æ®ç»“æ„

### 3.1 çº¿ç¨‹å®‰å…¨çš„æ ˆ

```go
package main

import (
    "errors"
    "fmt"
    "sync"
)

// çº¿ç¨‹å®‰å…¨çš„æ ˆ
type ConcurrentStack struct {
    items []interface{}
    mutex sync.Mutex
}

func NewConcurrentStack() *ConcurrentStack {
    return &ConcurrentStack{
        items: make([]interface{}, 0),
    }
}

// å…¥æ ˆ
func (cs *ConcurrentStack) Push(item interface{}) {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    cs.items = append(cs.items, item)
}

// å‡ºæ ˆ
func (cs *ConcurrentStack) Pop() (interface{}, error) {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    
    if len(cs.items) == 0 {
        return nil, errors.New("æ ˆä¸ºç©º")
    }
    
    item := cs.items[len(cs.items)-1]
    cs.items = cs.items[:len(cs.items)-1]
    return item, nil
}

// æŸ¥çœ‹æ ˆé¡¶å…ƒç´ 
func (cs *ConcurrentStack) Peek() (interface{}, error) {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    
    if len(cs.items) == 0 {
        return nil, errors.New("æ ˆä¸ºç©º")
    }
    
    return cs.items[len(cs.items)-1], nil
}

// æ ˆå¤§å°
func (cs *ConcurrentStack) Size() int {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    return len(cs.items)
}

// æ˜¯å¦ä¸ºç©º
func (cs *ConcurrentStack) IsEmpty() bool {
    cs.mutex.Lock()
    defer cs.mutex.Unlock()
    return len(cs.items) == 0
}

func stackExample() {
    stack := NewConcurrentStack()
    var wg sync.WaitGroup
    
    // å¯åŠ¨å¤šä¸ªç”Ÿäº§è€…
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(producerID int) {
            defer wg.Done()
            for j := 0; j < 5; j++ {
                item := fmt.Sprintf("Item-%d-%d", producerID, j)
                stack.Push(item)
                fmt.Printf("ç”Ÿäº§è€… %d æ¨å…¥: %s\n", producerID, item)
            }
        }(i)
    }
    
    // å¯åŠ¨å¤šä¸ªæ¶ˆè´¹è€…
    for i := 0; i < 2; i++ {
        wg.Add(1)
        go func(consumerID int) {
            defer wg.Done()
            for j := 0; j < 7; j++ { // æ¯ä¸ªæ¶ˆè´¹è€…æ¶ˆè´¹7ä¸ªå…ƒç´ 
                if item, err := stack.Pop(); err == nil {
                    fmt.Printf("æ¶ˆè´¹è€… %d å¼¹å‡º: %v\n", consumerID, item)
                } else {
                    fmt.Printf("æ¶ˆè´¹è€… %d é‡åˆ°é”™è¯¯: %v\n", consumerID, err)
                    break
                }
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("æœ€ç»ˆæ ˆå¤§å°: %d\n", stack.Size())
}

func main() {
    fmt.Println("\n=== çº¿ç¨‹å®‰å…¨æ ˆç¤ºä¾‹ ===")
    stackExample()
}
```

### 3.2 çº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—

```go
package main

import (
    "errors"
    "fmt"
    "sync"
)

// çº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—
type ConcurrentQueue struct {
    items []interface{}
    mutex sync.Mutex
}

func NewConcurrentQueue() *ConcurrentQueue {
    return &ConcurrentQueue{
        items: make([]interface{}, 0),
    }
}

// å…¥é˜Ÿ
func (cq *ConcurrentQueue) Enqueue(item interface{}) {
    cq.mutex.Lock()
    defer cq.mutex.Unlock()
    cq.items = append(cq.items, item)
}

// å‡ºé˜Ÿ
func (cq *ConcurrentQueue) Dequeue() (interface{}, error) {
    cq.mutex.Lock()
    defer cq.mutex.Unlock()
    
    if len(cq.items) == 0 {
        return nil, errors.New("é˜Ÿåˆ—ä¸ºç©º")
    }
    
    item := cq.items[0]
    cq.items = cq.items[1:]
    return item, nil
}

// æŸ¥çœ‹é˜Ÿé¦–å…ƒç´ 
func (cq *ConcurrentQueue) Front() (interface{}, error) {
    cq.mutex.Lock()
    defer cq.mutex.Unlock()
    
    if len(cq.items) == 0 {
        return nil, errors.New("é˜Ÿåˆ—ä¸ºç©º")
    }
    
    return cq.items[0], nil
}

// é˜Ÿåˆ—å¤§å°
func (cq *ConcurrentQueue) Size() int {
    cq.mutex.Lock()
    defer cq.mutex.Unlock()
    return len(cq.items)
}

// æ˜¯å¦ä¸ºç©º
func (cq *ConcurrentQueue) IsEmpty() bool {
    cq.mutex.Lock()
    defer cq.mutex.Unlock()
    return len(cq.items) == 0
}

func queueExample() {
    queue := NewConcurrentQueue()
    var wg sync.WaitGroup
    
    // å¯åŠ¨ç”Ÿäº§è€…
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 10; i++ {
            item := fmt.Sprintf("Data-%d", i)
            queue.Enqueue(item)
            fmt.Printf("ç”Ÿäº§è€…å…¥é˜Ÿ: %s\n", item)
        }
    }()
    
    // å¯åŠ¨æ¶ˆè´¹è€…
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 10; i++ {
            if item, err := queue.Dequeue(); err == nil {
                fmt.Printf("æ¶ˆè´¹è€…å‡ºé˜Ÿ: %v\n", item)
            } else {
                fmt.Printf("æ¶ˆè´¹è€…é‡åˆ°é”™è¯¯: %v\n", err)
                break
            }
        }
    }()
    
    wg.Wait()
    fmt.Printf("æœ€ç»ˆé˜Ÿåˆ—å¤§å°: %d\n", queue.Size())
}

func main() {
    fmt.Println("\n=== çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—ç¤ºä¾‹ ===")
    queueExample()
}
```

---

## å››ã€å¹¶å‘å®‰å…¨æœ€ä½³å®è·µ

### 4.1 ä½¿ç”¨Channelä»£æ›¿å…±äº«å†…å­˜

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// ä½¿ç”¨å…±äº«å†…å­˜çš„æ–¹å¼ï¼ˆä¸æ¨èï¼‰
type SharedMemoryCounter struct {
    value int
    mutex sync.Mutex
}

func (smc *SharedMemoryCounter) Increment() {
    smc.mutex.Lock()
    defer smc.mutex.Unlock()
    smc.value++
}

func sharedMemoryExample() {
    counter := &SharedMemoryCounter{}
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Printf("å…±äº«å†…å­˜è®¡æ•°: %d\n", counter.value)
}

// ä½¿ç”¨Channelçš„æ–¹å¼ï¼ˆæ¨èï¼‰
type IncrementRequest struct {
    response chan int
}

func channelBasedCounter(requests <-chan IncrementRequest) <-chan int {
    result := make(chan int, 1)
    
    go func() {
        count := 0
        for req := range requests {
            count++
            req.response <- count
        }
        result <- count
    }()
    
    return result
}

func channelExample() {
    requests := make(chan IncrementRequest, 1000)
    var wg sync.WaitGroup
    
    // å¯åŠ¨è®¡æ•°å™¨
    result := channelBasedCounter(requests)
    
    // å‘é€è¯·æ±‚
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            response := make(chan int, 1)
            requests <- IncrementRequest{response: response}
            <-response // ç­‰å¾…å“åº”
        }()
    }
    
    wg.Wait()
    close(requests)
    finalCount := <-result
    fmt.Printf("Channelè®¡æ•°: %d\n", finalCount)
}

func main() {
    fmt.Println("\n=== å¹¶å‘å®‰å…¨æœ€ä½³å®è·µ ===")
    fmt.Println("å…±äº«å†…å­˜æ–¹å¼:")
    sharedMemoryExample()
    
    fmt.Println("Channelæ–¹å¼:")
    channelExample()
}
```

### 4.2 é¿å…æ­»é”

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// å®¹æ˜“äº§ç”Ÿæ­»é”çš„ä»£ç 
type Account struct {
    id      int
    balance int
    mutex   sync.Mutex
}

// é”™è¯¯çš„è½¬è´¦å®ç°ï¼ˆå¯èƒ½å¯¼è‡´æ­»é”ï¼‰
func unsafeTransfer(from, to *Account, amount int) bool {
    from.mutex.Lock()
    // æ¨¡æ‹Ÿä¸€äº›å¤„ç†æ—¶é—´ï¼Œå¢åŠ æ­»é”æ¦‚ç‡
    time.Sleep(1 * time.Millisecond)
    to.mutex.Lock()
    
    if from.balance >= amount {
        from.balance -= amount
        to.balance += amount
        fmt.Printf("è½¬è´¦æˆåŠŸ: %d ä»è´¦æˆ· %d åˆ°è´¦æˆ· %d\n", amount, from.id, to.id)
        result := fmt.Sprintf("è½¬è´¦å - From: %d, To: %d", from.balance, to.balance)
        fmt.Println(result)
        to.mutex.Unlock()
        from.mutex.Unlock()
        return true
    }
    
    to.mutex.Unlock()
    from.mutex.Unlock()
    return false
}

// æ­£ç¡®çš„è½¬è´¦å®ç°ï¼ˆé¿å…æ­»é”ï¼‰
func safeTransfer(from, to *Account, amount int) bool {
    // ç¡®ä¿æ€»æ˜¯ä»¥ç›¸åŒçš„é¡ºåºè·å–é”
   	first, second := from, to
   	if from.id > to.id {
   		first, second = to, from
   	}
   
    first.mutex.Lock()
   	defer first.mutex.Unlock()
   	
   	second.mutex.Lock()
   	defer second.mutex.Unlock()
    
    if from.balance >= amount {
        from.balance -= amount
        to.balance += amount
        fmt.Printf("å®‰å…¨è½¬è´¦æˆåŠŸ: %d ä»è´¦æˆ· %d åˆ°è´¦æˆ· %d\n", amount, from.id, to.id)
        return true
    }
    
    return false
}

func deadlockExample() {
    account1 := &Account{id: 1, balance: 1000}
    account2 := &Account{id: 2, balance: 1000}
    
    var wg sync.WaitGroup
    
    // å®‰å…¨çš„å¹¶å‘è½¬è´¦
    wg.Add(2)
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            safeTransfer(account1, account2, 10)
            time.Sleep(10 * time.Millisecond)
        }
    }()
    
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            safeTransfer(account2, account1, 15)
            time.Sleep(10 * time.Millisecond)
        }
    }()
    
    wg.Wait()
    fmt.Printf("æœ€ç»ˆä½™é¢ - è´¦æˆ·1: %d, è´¦æˆ·2: %d\n", account1.balance, account2.balance)
}

func main() {
    fmt.Println("\n=== é¿å…æ­»é”ç¤ºä¾‹ ===")
    deadlockExample()
}
```

### 4.3 ä½¿ç”¨Contextè¿›è¡Œè¶…æ—¶æ§åˆ¶

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// æ¨¡æ‹Ÿä¸€ä¸ªå¯èƒ½é•¿æ—¶é—´è¿è¡Œçš„æ“ä½œ
func longRunningOperation(ctx context.Context, operationID string) error {
    select {
    case <-time.After(3 * time.Second): // æ¨¡æ‹Ÿé•¿æ—¶é—´æ“ä½œ
        fmt.Printf("æ“ä½œ %s å®Œæˆ\n", operationID)
        return nil
    case <-ctx.Done(): // æ£€æŸ¥ä¸Šä¸‹æ–‡æ˜¯å¦è¢«å–æ¶ˆ
        fmt.Printf("æ“ä½œ %s è¢«å–æ¶ˆ: %v\n", operationID, ctx.Err())
        return ctx.Err()
    }
}

// ä½¿ç”¨è¶…æ—¶çš„å¹¶å‘æ“ä½œ
func timeoutControlExample() {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ä¸Šä¸‹æ–‡
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    // å¯åŠ¨é•¿æ—¶é—´æ“ä½œ
    done := make(chan error, 1)
    
    go func() {
        err := longRunningOperation(ctx, "TestOperation")
        done <- err
    }()
    
    // ç­‰å¾…æ“ä½œå®Œæˆæˆ–è¶…æ—¶
    select {
    case err := <-done:
        if err != nil {
            fmt.Printf("æ“ä½œå¤±è´¥: %v\n", err)
        } else {
            fmt.Println("æ“ä½œæˆåŠŸå®Œæˆ")
        }
    case <-ctx.Done():
        fmt.Printf("æ“ä½œè¶…æ—¶: %v\n", ctx.Err())
    }
}

// å¹¶å‘æ“ä½œçš„æ‰¹é‡è¶…æ—¶æ§åˆ¶
func batchTimeoutExample() {
    operations := []string{"Op1", "Op2", "Op3", "Op4", "Op5"}
    
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ä¸Šä¸‹æ–‡
    ctx, cancel := context.WithTimeout(context.Background(), 1500*time.Millisecond)
    defer cancel()
    
    results := make(chan string, len(operations))
    
    // å¯åŠ¨æ‰€æœ‰æ“ä½œ
    for _, op := range operations {
        go func(operation string) {
            // æ¨¡æ‹Ÿä¸åŒé•¿åº¦çš„æ“ä½œæ—¶é—´
            delay := time.Duration(len(operation)) * 500 * time.Millisecond
            select {
            case <-time.After(delay):
                select {
                case <-ctx.Done():
                    results <- fmt.Sprintf("%s: å–æ¶ˆ", operation)
                default:
                    results <- fmt.Sprintf("%s: å®Œæˆ", operation)
                }
            case <-ctx.Done():
                results <- fmt.Sprintf("%s: å–æ¶ˆ", operation)
            }
        }(op)
    }
    
    // æ”¶é›†ç»“æœ
    completed := 0
    for {
        select {
        case result := <-results:
            fmt.Printf("ç»“æœ: %s\n", result)
            completed++
            if completed == len(operations) {
                return
            }
        case <-ctx.Done():
            fmt.Printf("ä¸Šä¸‹æ–‡å–æ¶ˆï¼Œæ”¶é›†å‰©ä½™ç»“æœ...\n")
            // å°è¯•æ”¶é›†å‰©ä½™ç»“æœï¼Œä½†ä¸è¦é˜»å¡
            for i := completed; i < len(operations); i++ {
                select {
                case result := <-results:
                    fmt.Printf("æœ€ç»ˆç»“æœ: %s\n", result)
                case <-time.After(100 * time.Millisecond):
                    fmt.Println("è¶…æ—¶ç­‰å¾…ç»“æœ")
                    return
                }
            }
            return
        }
    }
}

func main() {
    fmt.Println("\n=== Contextè¶…æ—¶æ§åˆ¶ç¤ºä¾‹ ===")
    fmt.Println("å•ä¸ªæ“ä½œè¶…æ—¶æ§åˆ¶:")
    timeoutControlExample()
    
    fmt.Println("\næ‰¹é‡æ“ä½œè¶…æ—¶æ§åˆ¶:")
    batchTimeoutExample()
}
```

---

## äº”ã€å¹¶å‘è°ƒè¯•å’Œæµ‹è¯•

### 5.1 ç«æ€æ£€æµ‹

Goæä¾›äº†ç«æ€æ£€æµ‹å·¥å…·ï¼Œåœ¨ç¼–è¯‘æ—¶åŠ ä¸Š `-race` å‚æ•°å¯ä»¥æ£€æµ‹ç«æ€æ¡ä»¶ã€‚

```go
// ç¤ºä¾‹ï¼šå¦‚ä½•è¿è¡Œç«æ€æ£€æµ‹
// go run -race your_program.go
// go build -race your_program.go
```

### 5.2 å¹¶å‘æµ‹è¯•

```go
package main

import (
    "sync"
    "testing"
)

// ç®€å•çš„å¹¶å‘å®‰å…¨è®¡æ•°å™¨ç”¨äºæµ‹è¯•
type TestCounter struct {
    value int64
    mutex sync.Mutex
}

func (tc *TestCounter) Increment() {
    tc.mutex.Lock()
    defer tc.mutex.Unlock()
    tc.value++
}

func (tc *TestCounter) Value() int64 {
    tc.mutex.Lock()
    defer tc.mutex.Unlock()
    return tc.value
}

// å¹¶å‘æµ‹è¯•å‡½æ•°
func TestConcurrentIncrement(t *testing.T) {
    counter := &TestCounter{}
    const numGoroutines = 10
    const incrementsPerGoroutine = 1000
    
    var wg sync.WaitGroup
    
    // å¯åŠ¨å¤šä¸ªgoroutineåŒæ—¶å¢åŠ è®¡æ•°å™¨
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < incrementsPerGoroutine; j++ {
                counter.Increment()
            }
        }()
    }
    
    wg.Wait()
    
    expected := int64(numGoroutines * incrementsPerGoroutine)
    actual := counter.Value()
    
    if actual != expected {
        t.Errorf("æœŸæœ›å€¼: %d, å®é™…å€¼: %d", expected, actual)
    }
}

// æ€§èƒ½åŸºå‡†æµ‹è¯•
func BenchmarkConcurrentIncrement(b *testing.B) {
    counter := &TestCounter{}
    var wg sync.WaitGroup
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    wg.Wait()
}

func main() {
    // åœ¨å®é™…é¡¹ç›®ä¸­ï¼Œè¿™äº›æµ‹è¯•å‡½æ•°ä¼šè¢«go testè¿è¡Œ
    println("è¿™æ˜¯ä¸€ä¸ªå±•ç¤ºå¹¶å‘æµ‹è¯•çš„ç¤ºä¾‹")
}
```

---

## æ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µå›é¡¾

1. **å¹¶å‘è®¾è®¡æ¨¡å¼**ï¼š
   - **å·¥ä½œæ± æ¨¡å¼**ï¼šå¤„ç†å¤§é‡ç›¸ä¼¼ä»»åŠ¡
   - **ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼**ï¼šè§£è€¦ç”Ÿäº§å’Œæ¶ˆè´¹è¿‡ç¨‹
   - **å‘å¸ƒ-è®¢é˜…æ¨¡å¼**ï¼šä¸€å¯¹å¤šçš„æ¶ˆæ¯ä¼ é€’

2. **å¹¶å‘å®‰å…¨æœºåˆ¶**ï¼š
   - **ç«æ€æ¡ä»¶**ï¼šå¤šä¸ªgoroutineåŒæ—¶è®¿é—®å…±äº«èµ„æº
   - **äº’æ–¥é”**ï¼šä¿æŠ¤ä¸´ç•ŒåŒº
   - **åŸå­æ“ä½œ**ï¼šé«˜æ•ˆçš„åŒæ­¥åŸè¯­
   - **è¯»å†™é”**ï¼šè¯»å¤šå†™å°‘åœºæ™¯ä¼˜åŒ–

3. **çº¿ç¨‹å®‰å…¨æ•°æ®ç»“æ„**ï¼š
   - **çº¿ç¨‹å®‰å…¨æ ˆ**ï¼šLIFOæ•°æ®ç»“æ„
   - **çº¿ç¨‹å®‰å…¨é˜Ÿåˆ—**ï¼šFIFOæ•°æ®ç»“æ„
   - **å®‰å…¨æ˜ å°„**ï¼šé”®å€¼å¯¹å­˜å‚¨

4. **æœ€ä½³å®è·µ**ï¼š
   - **Channelä¼˜äºå…±äº«å†…å­˜**ï¼šCSPæ¨¡å‹
   - **é¿å…æ­»é”**ï¼šä¸€è‡´çš„é”è·å–é¡ºåº
   - **ä½¿ç”¨Context**ï¼šè¶…æ—¶å’Œå–æ¶ˆæ§åˆ¶

5. **è°ƒè¯•å’Œæµ‹è¯•**ï¼š
   - **ç«æ€æ£€æµ‹**ï¼š`go run -race`
   - **å¹¶å‘æµ‹è¯•**ï¼šéªŒè¯çº¿ç¨‹å®‰å…¨æ€§
   - **æ€§èƒ½åŸºå‡†**ï¼šè¯„ä¼°å¹¶å‘æ€§èƒ½

æŒæ¡è¿™äº›å¹¶å‘æ¨¡å¼å’Œå®‰å…¨æœºåˆ¶åï¼Œä½ å°†èƒ½å¤Ÿæ„å»ºé«˜æ€§èƒ½ã€é«˜å¯é çš„å¹¶å‘ç¨‹åºã€‚è®°ä½ï¼Œæ­£ç¡®çš„å¹¶å‘è®¾è®¡æ¯”åæœŸä¿®å¤å¹¶å‘é—®é¢˜æ›´åŠ é‡è¦ã€‚