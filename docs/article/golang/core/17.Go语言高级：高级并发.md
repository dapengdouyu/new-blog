---
title: 17ã€Goè¯­è¨€é«˜çº§ï¼šé«˜çº§å¹¶å‘
date: 2026-01-06
description: æ·±å…¥æ¢è®¨Goè¯­è¨€çš„é«˜çº§å¹¶å‘ç‰¹æ€§ï¼ŒåŒ…æ‹¬æ€§èƒ½ä¼˜åŒ–ã€å¹¶å‘ç›‘æ§å’Œè°ƒè¯•æŠ€å·§
---

# 17ã€Goè¯­è¨€é«˜çº§ï¼šé«˜çº§å¹¶å‘

æœ¬æ–‡æ¡£å°†æ·±å…¥æ¢è®¨Goè¯­è¨€çš„é«˜çº§å¹¶å‘ç‰¹æ€§ï¼ŒåŒ…æ‹¬æ€§èƒ½ä¼˜åŒ–ã€å¹¶å‘ç›‘æ§å’Œè°ƒè¯•æŠ€å·§ã€‚è¿™äº›çŸ¥è¯†å°†å¸®åŠ©æ‚¨æ„å»ºé«˜æ€§èƒ½ã€é«˜å¯é æ€§çš„å¹¶å‘ç¨‹åºã€‚

> **æ³¨æ„**ï¼šå…³äºGMPè°ƒåº¦æ¨¡å‹çš„è¯¦ç»†å†…å®¹ï¼Œè¯·å‚è€ƒ[13.1ã€Goè¯­è¨€é«˜çº§ï¼šGMPè°ƒåº¦æ¨¡å‹](./13.1.Goè¯­è¨€é«˜çº§ï¼šGMPè°ƒåº¦æ¨¡å‹.md)æ–‡æ¡£ã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡å¹¶å‘æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- âœ… å­¦ä¼šä½¿ç”¨pprofè¿›è¡Œæ€§èƒ½åˆ†æ
- âœ… äº†è§£å¹¶å‘ç›‘æ§å’Œè°ƒè¯•æ–¹æ³•
- âœ… æŒæ¡é«˜çº§å¹¶å‘æ¨¡å¼å’Œæœ€ä½³å®è·µ

---

## ä¸€ã€å¹¶å‘æ€§èƒ½ä¼˜åŒ–

### 1.1 GOMAXPROCSè°ƒä¼˜

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

// æµ‹è¯•ä¸åŒGOMAXPROCSå€¼çš„æ€§èƒ½
func gomaxprocsBenchmark() {
    const numTasks = 1000
    const iterations = 100000
    
    originalGOMAXPROCS := runtime.GOMAXPROCS(0)
    defer runtime.GOMAXPROCS(originalGOMAXPROCS)
    
    // æµ‹è¯•ä¸åŒçš„GOMAXPROCSå€¼
    for _, procs := range []int{1, 2, runtime.NumCPU(), runtime.NumCPU() * 2} {
        runtime.GOMAXPROCS(procs)
        
        start := time.Now()
        var wg sync.WaitGroup
        
        for i := 0; i < numTasks; i++ {
            wg.Add(1)
            go func() {
                defer wg.Done()
                // CPUå¯†é›†å‹ä»»åŠ¡
                result := 0
                for j := 0; j < iterations; j++ {
                    result += j
                }
                _ = result
            }()
        }
        
        wg.Wait()
        duration := time.Since(start)
        
        fmt.Printf("GOMAXPROCS=%d, è€—æ—¶: %v\n", procs, duration)
    }
}

func main() {
    fmt.Println("=== GOMAXPROCSæ€§èƒ½æµ‹è¯• ===")
    gomaxprocsBenchmark()
}
```

### 1.2 å‡å°‘é”ç«äº‰

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// ä½¿ç”¨åˆ†ç‰‡é”å‡å°‘ç«äº‰
type ShardedCounter struct {
    shards []int64
    mutexes []sync.Mutex
}

func NewShardedCounter(shardCount int) *ShardedCounter {
    return &ShardedCounter{
        shards:  make([]int64, shardCount),
        mutexes: make([]sync.Mutex, shardCount),
    }
}

func (sc *ShardedCounter) Increment() {
    // ä½¿ç”¨goroutine IDçš„å“ˆå¸Œå€¼é€‰æ‹©åˆ†ç‰‡ï¼ˆç®€åŒ–ç‰ˆï¼‰
    shard := int(time.Now().UnixNano()) % len(sc.shards)
    sc.mutexes[shard].Lock()
    sc.shards[shard]++
    sc.mutexes[shard].Unlock()
}

func (sc *ShardedCounter) Total() int64 {
    var total int64
    for i := range sc.shards {
        sc.mutexes[i].Lock()
        total += sc.shards[i]
        sc.mutexes[i].Unlock()
    }
    return total
}

// æ€§èƒ½æ¯”è¾ƒ
func lockContentionComparison() {
    const numGoroutines = 100
    const incrementsPerGoroutine = 10000
    
    // æ™®é€šäº’æ–¥é”
    var wg1 sync.WaitGroup
    var normalCounter struct {
        value int64
        mutex sync.Mutex
    }
    
    start1 := time.Now()
    for i := 0; i < numGoroutines; i++ {
        wg1.Add(1)
        go func() {
            defer wg1.Done()
            for j := 0; j < incrementsPerGoroutine; j++ {
                normalCounter.mutex.Lock()
                normalCounter.value++
                normalCounter.mutex.Unlock()
            }
        }()
    }
    wg1.Wait()
    normalDuration := time.Since(start1)
    
    // åˆ†ç‰‡é”
    shardedCounter := NewShardedCounter(16)
    var wg2 sync.WaitGroup
    
    start2 := time.Now()
    for i := 0; i < numGoroutines; i++ {
        wg2.Add(1)
        go func() {
            defer wg2.Done()
            for j := 0; j < incrementsPerGoroutine; j++ {
                shardedCounter.Increment()
            }
        }()
    }
    wg2.Wait()
    shardedDuration := time.Since(start2)
    
    // åŸå­æ“ä½œ
    var atomicCounter int64
    var wg3 sync.WaitGroup
    
    start3 := time.Now()
    for i := 0; i < numGoroutines; i++ {
        wg3.Add(1)
        go func() {
            defer wg3.Done()
            for j := 0; j < incrementsPerGoroutine; j++ {
                atomic.AddInt64(&atomicCounter, 1)
            }
        }()
    }
    wg3.Wait()
    atomicDuration := time.Since(start3)
    
    fmt.Printf("æ™®é€šäº’æ–¥é”è€—æ—¶: %v\n", normalDuration)
    fmt.Printf("åˆ†ç‰‡é”è€—æ—¶: %v\n", shardedDuration)
    fmt.Printf("åŸå­æ“ä½œè€—æ—¶: %v\n", atomicDuration)
    
    fmt.Printf("åˆ†ç‰‡é”æ€§èƒ½æå‡: %.2fx\n", float64(normalDuration)/float64(shardedDuration))
    fmt.Printf("åŸå­æ“ä½œæ€§èƒ½æå‡: %.2fx\n", float64(normalDuration)/float64(atomicDuration))
}

func main() {
    fmt.Println("\n=== é”ç«äº‰ä¼˜åŒ–æ¯”è¾ƒ ===")
    lockContentionComparison()
}
```

### 1.3 å†…å­˜åˆ†é…ä¼˜åŒ–

```go
package main

import (
    "fmt"
    "strings"
    "sync"
    "time"
)

// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘å†…å­˜åˆ†é…
type BufferPool struct {
    pool sync.Pool
}

func NewBufferPool() *BufferPool {
    return &BufferPool{
        pool: sync.Pool{
            New: func() interface{} {
                return &strings.Builder{}
            },
        },
    }
}

func (bp *BufferPool) Get() *strings.Builder {
    return bp.pool.Get().(*strings.Builder)
}

func (bp *BufferPool) Put(sb *strings.Builder) {
    sb.Reset()
    bp.pool.Put(sb)
}

// æ€§èƒ½æ¯”è¾ƒï¼šæ™®é€šå­—ç¬¦ä¸²æ‹¼æ¥ vs ä½¿ç”¨å¯¹è±¡æ± 
func memoryAllocationOptimization() {
    const numOperations = 100000
    
    // æ™®é€šå­—ç¬¦ä¸²æ‹¼æ¥
    start1 := time.Now()
    for i := 0; i < numOperations; i++ {
        s := ""
        for j := 0; j < 10; j++ {
            s += fmt.Sprintf("part%d", j)
        }
        _ = s
    }
    normalDuration := time.Since(start1)
    
    // ä½¿ç”¨strings.Builder
    start2 := time.Now()
    for i := 0; i < numOperations; i++ {
        var sb strings.Builder
        for j := 0; j < 10; j++ {
            sb.WriteString(fmt.Sprintf("part%d", j))
        }
        _ = sb.String()
    }
    builderDuration := time.Since(start2)
    
    // ä½¿ç”¨å¯¹è±¡æ± çš„strings.Builder
    pool := NewBufferPool()
    start3 := time.Now()
    for i := 0; i < numOperations; i++ {
        sb := pool.Get()
        for j := 0; j < 10; j++ {
            sb.WriteString(fmt.Sprintf("part%d", j))
        }
        _ = sb.String()
        pool.Put(sb)
    }
    pooledDuration := time.Since(start3)
    
    fmt.Printf("æ™®é€šå­—ç¬¦ä¸²æ‹¼æ¥å¾…: %v\n", normalDuration)
    fmt.Printf("strings.Builder: %v\n", builderDuration)
    fmt.Printf("å¯¹è±¡æ± +strings.Builder: %v\n", pooledDuration)
    
    fmt.Printf("Builderæ€§èƒ½æå‡: %.2fx\n", float64(normalDuration)/float64(builderDuration))
    fmt.Printf("å¯¹è±¡æ± æ€§èƒ½æå‡: %.2fx\n", float64(normalDuration)/float64(pooledDuration))
}

func main() {
    fmt.Println("\n=== å†…å­˜åˆ†é…ä¼˜åŒ–æ¯”è¾ƒ ===")
    memoryAllocationOptimization()
}
```

---

## äºŒã€æ€§èƒ½åˆ†æå·¥å…·pprof

### 2.1 CPUæ€§èƒ½åˆ†æ

```go
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
    "runtime"
    "sync"
    "time"
)

// æ¨¡æ‹ŸCPUå¯†é›†å‹ä»»åŠ¡ç”¨äºpprofåˆ†æ
func cpuIntensiveTask() {
    // æ¨¡æ‹Ÿä¸€äº›CPUå¯†é›†å‹è®¡ç®—
    for i := 0; i < 1000000; i++ {
        _ = i * i
    }
}

func startPprofServer() {
    go func() {
        fmt.Println("pprofæœåŠ¡å™¨å¯åŠ¨åœ¨: http://localhost:6060/debug/pprof/")
        if err := http.ListenAndServe(":6060", nil); err != nil {
            fmt.Printf("pprofæœåŠ¡å™¨å¯åŠ¨å¤±è´¥: %v\n", err)
        }
    }()
}

func cpuProfilingDemo() {
    startPprofServer()
    
    fmt.Println("å¼€å§‹CPUå¯†é›†å‹ä»»åŠ¡...")
    var wg sync.WaitGroup
    
    // å¯åŠ¨å¤šä¸ªgoroutineæ‰§è¡ŒCPUå¯†é›†å‹ä»»åŠ¡
    numWorkers := runtime.NumCPU()
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                cpuIntensiveTask()
                time.Sleep(time.Millisecond) // æ¨¡æ‹Ÿå·¥ä½œé—´éš”
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Println("CPUå¯†é›†å‹ä»»åŠ¡å®Œæˆ")
}

func main() {
    fmt.Println("\n=== CPUæ€§èƒ½åˆ†ææ¼”ç¤º ===")
    cpuProfilingDemo()
}
```

### 2.2 å†…å­˜æ€§èƒ½åˆ†æ

```go
package main

import (
    "fmt"
    "math/rand"
    "net/http"
    _ "net/http/pprof"
    "sync"
    "time"
)

// æ¨¡æ‹Ÿå†…å­˜åˆ†é…ç”¨äºpprofåˆ†æ
type LargeStruct struct {
    data [1000]int
}

func allocateMemory() *LargeStruct {
    ls := &LargeStruct{}
    for i := range ls.data {
        ls.data[i] = rand.Intn(1000)
    }
    return ls
}

func memoryProfilingDemo() {
    go func() {
        fmt.Println("å†…å­˜pprofæœåŠ¡å™¨å¯åŠ¨åœ¨: http://localhost:6060/debug/pprof/")
        http.ListenAndServe(":6061", nil)
    }()
    
    fmt.Println("å¼€å§‹å†…å­˜åˆ†é…æµ‹è¯•...")
    var wg sync.WaitGroup
    var dataStore []*LargeStruct
    var mutex sync.Mutex
    
    // å¯åŠ¨å¤šä¸ªgoroutineåˆ†é…å†…å­˜
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 1000; j++ {
                obj := allocateMemory()
                
                mutex.Lock()
                dataStore = append(dataStore, obj)
                // å¶å°”æ¸…ç†ä¸€äº›å¯¹è±¡
                if len(dataStore) > 100 {
                    dataStore = dataStore[50:] // æ¨¡æ‹ŸGCå‹åŠ›
                }
                mutex.Unlock()
                
                time.Sleep(time.Millisecond)
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("æœ€ç»ˆå­˜å‚¨äº† %d ä¸ªå¯¹è±¡\n", len(dataStore))
}

func main() {
    rand.Seed(time.Now().UnixNano())
    fmt.Println("\n=== å†…å­˜æ€§èƒ½åˆ†ææ¼”ç¤º ===")
    memoryProfilingDemo()
}
```

### 2.3 é˜»å¡åˆ†æ

```go
package main

import (
    "fmt"
    "net/http"
    _ "net/http/pprof"
    "sync"
    "time"
)

func blockingOperationDemo() {
    go func() {
        fmt.Println("é˜»å¡åˆ†ææœåŠ¡å™¨å¯åŠ¨åœ¨: http://localhost:6060/debug/pprof/")
        http.ListenAndServe(":6062", nil)
    }()
    
    fmt.Println("å¼€å§‹é˜»å¡æ“ä½œæµ‹è¯•...")
    
    var mu sync.Mutex
    var wg sync.WaitGroup
    
    // åˆ›å»ºå¤šä¸ªgoroutineï¼Œå®ƒä»¬ä¼šç›¸äº’é˜»å¡
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            for j := 0; j < 10; j++ {
                mu.Lock()
                fmt.Printf("Goroutine %d è·å–é”, æ“ä½œ %d\n", id, j)
                
                // æ¨¡æ‹ŸæŒæœ‰é”çš„æ—¶é—´
                time.Sleep(time.Millisecond * 100)
                
                mu.Unlock()
                fmt.Printf("Goroutine %d é‡Šæ”¾é”, æ“ä½œ %d\n", id, j)
                
                // æ¨¡æ‹Ÿä¸æŒæœ‰é”çš„æ—¶é—´
                time.Sleep(time.Millisecond * 50)
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Println("é˜»å¡æ“ä½œæµ‹è¯•å®Œæˆ")
}

func main() {
    fmt.Println("\n=== é˜»å¡åˆ†ææ¼”ç¤º ===")
    blockingOperationDemo()
}
```

---

## ä¸‰ã€å¹¶å‘ç›‘æ§å’Œè°ƒè¯•

### 3.1 è¿è¡Œæ—¶æŒ‡æ ‡ç›‘æ§

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

// è¿è¡Œæ—¶æŒ‡æ ‡æ”¶é›†å™¨
type RuntimeMetrics struct {
    NumGoroutine int
    NumCPU       int
    NumCGocalls  int
    GOMAXPROCS   int
    MemStats     runtime.MemStats
}

func CollectRuntimeMetrics() RuntimeMetrics {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    
    return RuntimeMetrics{
        NumGoroutine: runtime.NumGoroutine(),
        NumCPU:       runtime.NumCPU(),
        NumCGocalls:  runtime.NumCgoCall(),
        GOMAXPROCS:   runtime.GOMAXPROCS(0),
        MemStats:     m,
    }
}

func (rm RuntimeMetrics) Print() {
    fmt.Printf("Goroutines: %d, CPUs: %d, CGoCalls: %d, GOMAXPROCS: %d\n",
        rm.NumGoroutine, rm.NumCPU, rm.NumCGocalls, rm.GOMAXPROCS)
    fmt.Printf("Alloc: %d KB, Sys: %d KB, NumGC: %d\n",
        rm.MemStats.Alloc/1024, rm.MemStats.Sys/1024, rm.MemStats.NumGC)
}

func runtimeMetricsDemo() {
    fmt.Println("=== è¿è¡Œæ—¶æŒ‡æ ‡ç›‘æ§ ===")
    
    // å¯åŠ¨ä¸€äº›goroutine
    var wg sync.WaitGroup
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            time.Sleep(time.Millisecond * time.Duration(id%10))
        }(i)
    }
    
    // å®šæœŸæ‰“å°æŒ‡æ ‡
    for i := 0; i < 10; i++ {
        fmt.Printf("ç›‘æ§ç‚¹ %d: ", i+1)
        metrics := CollectRuntimeMetrics()
        metrics.Print()
        time.Sleep(time.Second)
    }
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰goroutineå®Œæˆ")
    
    fmt.Print("æœ€ç»ˆæŒ‡æ ‡: ")
    finalMetrics := CollectRuntimeMetrics()
    finalMetrics.Print()
}

func main() {
    runtimeMetricsDemo()
}
```

### 3.2 æ­»é”æ£€æµ‹

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// æ­»é”æ£€æµ‹å™¨çš„ç®€åŒ–å®ç°
type DeadlockDetector struct {
    mu       sync.Mutex
    resources map[string]*sync.Mutex
    holders  map[string]string  // resource -> holder
    waiters  map[string][]string // holder -> [resources waiting for]
}

func NewDeadlockDetector() *DeadlockDetector {
    return &DeadlockDetector{
        resources: make(map[string]*sync.Mutex),
        holders:  make(map[string]string),
        waiters:  make(map[string][]string),
    }
}

// æ¨¡æ‹Ÿä¸€ä¸ªå®‰å…¨çš„èµ„æºç®¡ç†ç³»ç»Ÿ
type ResourceManager struct {
    resources map[string]*sync.Mutex
    mu        sync.RWMutex
}

func NewResourceManager() *ResourceManager {
    rm := &ResourceManager{
        resources: make(map[string]*sync.Mutex),
    }
    
    // é¢„è®¾ä¸€äº›èµ„æº
    for i := 0; i < 5; i++ {
        rm.resources[fmt.Sprintf("resource_%d", i)] = &sync.Mutex{}
    }
    
    return rm
}

// å®‰å…¨çš„èµ„æºè·å–ï¼ˆé¿å…æ­»é”ï¼‰
func (rm *ResourceManager) SafeAcquire(resourceIDs []string) {
    // æŒ‰ç…§å›ºå®šçš„é¡ºåºè·å–é”ï¼Œé¿å…æ­»é”
    sortedResources := make([]*sync.Mutex, len(resourceIDs))
    for i, id := range resourceIDs {
        rm.mu.RLock()
        sortedResources[i] = rm.resources[id]
        rm.mu.RUnlock()
    }
    
    // å¯¹èµ„æºæ’åºä»¥ç¡®ä¿ä¸€è‡´çš„è·å–é¡ºåº
    for i := 0; i < len(sortedResources)-1; i++ {
        for j := i + 1; j < len(sortedResources); j++ {
            if fmt.Sprintf("%p", sortedResources[i]) > fmt.Sprintf("%p", sortedResources[j]) {
                sortedResources[i], sortedResources[j] = sortedResources[j], sortedResources[i]
            }
        }
    }
    
    // æŒ‰é¡ºåºè·å–æ‰€æœ‰é”
    acquired := make([]bool, len(sortedResources))
    for i, mutex := range sortedResources {
        mutex.Lock()
        acquired[i] = true
    }
    
    // ä½¿ç”¨èµ„æºåé‡Šæ”¾
    for i := len(sortedResources) - 1; i >= 0; i-- {
        if acquired[i] {
            sortedResources[i].Unlock()
        }
    }
}

func deadlockAvoidanceDemo() {
    fmt.Println("\n=== æ­»é”é¿å…æ¼”ç¤º ===")
    
    rm := NewResourceManager()
    var wg sync.WaitGroup
    
    // å¯åŠ¨å¤šä¸ªgoroutineï¼Œæ¯ä¸ªå°è¯•è·å–å¤šä¸ªèµ„æº
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // æ¯ä¸ªgoroutineéœ€è¦ä¸åŒçš„èµ„æºç»„åˆ
            resources := []string{
                fmt.Sprintf("resource_%d", id%5),
                fmt.Sprintf("resource_%d", (id+1)%5),
            }
            
            fmt.Printf("Goroutine %d å°è¯•è·å–èµ„æº: %v\n", id, resources)
            rm.SafeAcquire(resources)
            fmt.Printf("Goroutine %d å®Œæˆèµ„æºæ“ä½œ\n", id)
            
            time.Sleep(time.Millisecond * 10) // æ¨¡æ‹Ÿå·¥ä½œ
        }(i)
    }
    
    wg.Wait()
    fmt.Println("æ‰€æœ‰goroutineå®Œæˆï¼Œæ— æ­»é”å‘ç”Ÿ")
}

func main() {
    deadlockAvoidanceDemo()
}
```

### 3.3 ç«æ€æ¡ä»¶æ£€æµ‹

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

// æ¼”ç¤ºå¦‚ä½•æ£€æµ‹å’Œé¿å…ç«æ€æ¡ä»¶
type RaceConditionDetector struct {
    value int64
    mu    sync.Mutex
}

// éçº¿ç¨‹å®‰å…¨çš„æ“ä½œï¼ˆæ¼”ç¤ºç«æ€æ¡ä»¶ï¼‰
func (rcd *RaceConditionDetector) UnsafeIncrement() {
    // è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„ç«æ€æ¡ä»¶åœºæ™¯
    // è¯»å– -> ä¿®æ”¹ -> å†™å…¥ ä¸æ˜¯åŸå­æ“ä½œ
    current := rcd.value  // è¯»å–
    time.Sleep(time.Nanosecond) // å¢åŠ ç«æ€æ¡ä»¶å‘ç”Ÿçš„å¯èƒ½æ€§
    rcd.value = current + 1  // ä¿®æ”¹å’Œå†™å…¥
}

// çº¿ç¨‹å®‰å…¨çš„æ“ä½œ
func (rcd *RaceConditionDetector) SafeIncrement() {
    rcd.mu.Lock()
    defer rcd.mu.Unlock()
    rcd.value++
}

// ä½¿ç”¨åŸå­æ“ä½œï¼ˆæœ€é«˜æ•ˆï¼‰
func (rcd *RaceConditionDetector) AtomicIncrement() {
    atomic.AddInt64(&rcd.value, 1)
}

func raceConditionDemo() {
    fmt.Println("\n=== ç«æ€æ¡ä»¶æ¼”ç¤º ===")
    
    // æ¼”ç¤ºç«æ€æ¡ä»¶
    unsafeCounter := &RaceConditionDetector{}
    var wg sync.WaitGroup
    
    start := time.Now()
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 100; j++ {
                unsafeCounter.UnsafeIncrement()
            }
        }()
    }
    wg.Wait()
    unsafeDuration := time.Since(start)
    
    fmt.Printf("éçº¿ç¨‹å®‰å…¨è®¡æ•°å™¨ - æœŸæœ›: 10000, å®é™…: %d, è€—æ—¶: %v\n", 
               unsafeCounter.value, unsafeDuration)
    
    // æ¼”ç¤ºçº¿ç¨‹å®‰å…¨æ“ä½œ
    safeCounter := &RaceConditionDetector{}
    start = time.Now()
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 100; j++ {
                safeCounter.SafeIncrement()
            }
        }()
    }
    wg.Wait()
    safeDuration := time.Since(start)
    
    fmt.Printf("çº¿ç¨‹å®‰å…¨è®¡æ•°å™¨ - æœŸæœ›: 10000, å®é™…: %d, è€—æ—¶: %v\n", 
               safeCounter.value, safeDuration)
    
    // æ¼”ç¤ºåŸå­æ“ä½œ
    atomicCounter := &RaceConditionDetector{}
    start = time.Now()
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for j := 0; j < 100; j++ {
                atomicCounter.AtomicIncrement()
            }
        }()
    }
    wg.Wait()
    atomicDuration := time.Since(start)
    
    fmt.Printf("åŸå­æ“ä½œè®¡æ•°å™¨ - æœŸæœ›: 10000, å®é™…: %d, è€—æ—¶: %v\n", 
               atomicCounter.value, atomicDuration)
}

func main() {
    raceConditionDemo()
}
```

---

## å››ã€é«˜çº§å¹¶å‘æ¨¡å¼

### 4.1 Future/Promiseæ¨¡å¼

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

// Future/Promiseçš„å®ç°
type Future struct {
    resultChan chan interface{}
    errorChan  chan error
    completed  bool
}

// æ‰§è¡Œå™¨å‡½æ•°ç±»å‹
type Executor func() (interface{}, error)

// å¼‚æ­¥æ‰§è¡Œå‡½æ•°å¹¶è¿”å›Future
func AsyncExecute(executor Executor) *Future {
    future := &Future{
        resultChan: make(chan interface{}, 1),
        errorChan:  make(chan error, 1),
    }
    
    go func() {
        result, err := executor()
        if err != nil {
            future.errorChan <- err
        } else {
            future.resultChan <- result
        }
    }()
    
    return future
}

// è·å–ç»“æœï¼ˆé˜»å¡ç›´åˆ°å®Œæˆï¼‰
func (f *Future) Get() (interface{}, error) {
    if f.completed {
        return nil, errors.New("futureå·²ç»è·å–è¿‡ç»“æœ")
    }
    
    select {
    case result := <-f.resultChan:
        f.completed = true
        return result, nil
    case err := <-f.errorChan:
        f.completed = true
        return nil, err
    }
}

// å°è¯•è·å–ç»“æœï¼ˆéé˜»å¡ï¼‰
func (f *Future) TryGet() (interface{}, error, bool) {
    select {
    case result := <-f.resultChan:
        f.completed = true
        return result, nil, true
    case err := <-f.errorChan:
        f.completed = true
        return nil, err, true
    default:
        return nil, nil, false // æœªå®Œæˆ
    }
}

// Futureç»„åˆæ¨¡å¼
func CombineFutures(futures ...*Future) *Future {
    return AsyncExecute(func() (interface{}, error) {
        results := make([]interface{}, len(futures))
        for i, future := range futures {
            result, err := future.Get()
            if err != nil {
                return nil, err
            }
            results[i] = result
        }
        return results, nil
    })
}

func futurePatternDemo() {
    fmt.Println("\n=== Future/Promiseæ¨¡å¼æ¼”ç¤º ===")
    
    // åˆ›å»ºå‡ ä¸ªå¼‚æ­¥ä»»åŠ¡
    task1 := AsyncExecute(func() (interface{}, error) {
        time.Sleep(1 * time.Second)
        return "Task1 Result", nil
    })
    
    task2 := AsyncExecute(func() (interface{}, error) {
        time.Sleep(500 * time.Millisecond)
        return 42, nil
    })
    
    task3 := AsyncExecute(func() (interface{}, error) {
        time.Sleep(1500 * time.Millisecond)
        return []string{"a", "b", "c"}, nil
    })
    
    // å¹¶å‘è·å–ç»“æœ
    result1, err1 := task1.Get()
    if err1 != nil {
        fmt.Printf("Task1é”™è¯¯: %v\n", err1)
    } else {
        fmt.Printf("Task1ç»“æœ: %v\n", result1)
    }
    
    result2, err2 := task2.Get()
    if err2 != nil {
        fmt.Printf("Task2é”™è¯¯: %v\n", err2)
    } else {
        fmt.Printf("Task2ç»“æœ: %v\n", result2)
    }
    
    result3, err3 := task3.Get()
    if err3 != nil {
        fmt.Printf("Task3é”™è¯¯: %v\n", err3)
    } else {
        fmt.Printf("Task3ç»“æœ: %v\n", result3)
    }
    
    // ç»„åˆFuture
    combined := CombineFutures(task1, task2, task3)
    combinedResult, err := combined.Get()
    if err != nil {
        fmt.Printf("ç»„åˆä»»åŠ¡é”™è¯¯: %v\n", err)
    } else {
        fmt.Printf("ç»„åˆç»“æœ: %v\n", combinedResult)
    }
}

func main() {
    futurePatternDemo()
}
```

### 4.2 å“åº”å¼æµæ¨¡å¼

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// å“åº”å¼æµçš„åŸºæœ¬ç»„ä»¶
type Stream struct {
    source chan interface{}
    done   chan struct{}
}

// åˆ›å»ºæ–°æµ
func NewStream() *Stream {
    return &Stream{
        source: make(chan interface{}, 100),
        done:   make(chan struct{}),
    }
}

// å‘é€æ•°æ®åˆ°æµ
func (s *Stream) Send(value interface{}) {
    select {
    case s.source <- value:
    case <-s.done:
    }
}

// å…³é—­æµ
func (s *Stream) Close() {
    close(s.done)
    close(s.source)
}

// æ˜ å°„æ“ä½œ
func (s *Stream) Map(mapper func(interface{}) interface{}) *Stream {
    outputStream := NewStream()
    
    go func() {
        defer outputStream.Close()
        for {
            select {
            case value, ok := <-s.source:
                if !ok {
                    return
                }
                mappedValue := mapper(value)
                outputStream.Send(mappedValue)
            case <-s.done:
                return
            }
        }
    }()
    
    return outputStream
}

// è¿‡æ»¤æ“ä½œ
func (s *Stream) Filter(filterFunc func(interface{}) bool) *Stream {
    outputStream := NewStream()
    
    go func() {
        defer outputStream.Close()
        for {
            select {
            case value, ok := <-s.source:
                if !ok {
                    return
                }
                if filterFunc(value) {
                    outputStream.Send(value)
                }
            case <-s.done:
                return
            }
        }
    }()
    
    return outputStream
}

// è®¢é˜…æµ
func (s *Stream) Subscribe(handler func(interface{})) {
    go func() {
        for {
            select {
            case value, ok := <-s.source:
                if !ok {
                    return
                }
                handler(value)
            case <-s.done:
                return
            }
        }
    }()
}

// å¹¶è¡Œå¤„ç†
func (s *Stream) ParallelMap(mapper func(interface{}) interface{}, concurrency int) *Stream {
    outputStream := NewStream()
    
    // åˆ›å»ºå·¥ä½œæ± 
    jobs := make(chan interface{}, 100)
    results := make(chan interface{}, 100)
    
    // å¯åŠ¨å·¥ä½œè€…
    var wg sync.WaitGroup
    for i := 0; i < concurrency; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for job := range jobs {
                result := mapper(job)
                results <- result
            }
        }()
    }
    
    // å¯åŠ¨ç»“æœæ”¶é›†å™¨
    go func() {
        defer outputStream.Close()
        go func() {
            defer close(results)
            defer close(jobs)
            
            for {
                select {
                case value, ok := <-s.source:
                    if !ok {
                        break
                    }
                    jobs <- value
                case <-s.done:
                    return
                }
            }
        }()
        
        for result := range results {
            outputStream.Send(result)
        }
    }()
    
    // ç­‰å¾…æ‰€æœ‰å·¥ä½œè€…å®Œæˆ
    go func() {
        wg.Wait()
    }()
    
    return outputStream
}

func reactiveStreamDemo() {
    fmt.Println("\n=== å“åº”å¼æµæ¨¡å¼æ¼”ç¤º ===")
    
    // åˆ›å»ºæ•°æ®æº
    stream := NewStream()
    
    // å¯åŠ¨æ•°æ®ç”Ÿäº§è€…
    go func() {
        defer stream.Close()
        for i := 1; i <= 20; i++ {
            stream.Send(i)
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    // æ„å»ºå¤„ç†æµæ°´çº¿
    processedStream := stream.
        Filter(func(v interface{}) bool {
            num := v.(int)
            return num%2 == 0 // åªä¿ç•™å¶æ•°
        }).
        Map(func(v interface{}) interface{} {
            num := v.(int)
            return num * num // å¹³æ–¹
        }).
        ParallelMap(func(v interface{}) interface{} {
            num := v.(int)
            time.Sleep(50 * time.Millisecond) // æ¨¡æ‹Ÿå¤„ç†æ—¶é—´
            return fmt.Sprintf("Processed_%d", num)
        }, 3) // 3ä¸ªå¹¶å‘å¤„ç†å™¨
    
    // è®¢é˜…ç»“æœ
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        defer wg.Done()
        count := 0
        processedStream.Subscribe(func(value interface{}) {
            count++
            fmt.Printf("æ”¶åˆ°: %v (ç¬¬%dä¸ª)\n", value, count)
        })
    }()
    
    wg.Wait()
    fmt.Println("æµå¤„ç†å®Œæˆ")
}

func main() {
    reactiveStreamDemo()
}
```

---

## äº”ã€å¹¶å‘æœ€ä½³å®è·µæ€»ç»“

### 5.1 æ€§èƒ½è°ƒä¼˜æ¸…å•

```go
// Goå¹¶å‘æ€§èƒ½è°ƒä¼˜æ£€æŸ¥æ¸…å•
/*
1. GOMAXPROCSè®¾ç½®ï¼š
   - å¯¹äºCPUå¯†é›†å‹ä»»åŠ¡ï¼šè®¾ç½®ä¸ºCPUæ ¸å¿ƒæ•°
   - å¯¹äºIOå¯†é›†å‹ä»»åŠ¡ï¼šå¯ä»¥é€‚å½“å¢åŠ 

2. å‡å°‘é”ç«äº‰ï¼š
   - ä½¿ç”¨åŸå­æ“ä½œæ›¿ä»£äº’æ–¥é”ï¼ˆé€‚åˆç®€å•æ“ä½œï¼‰
   - ä½¿ç”¨åˆ†ç‰‡é”å‡å°‘çƒ­ç‚¹
   - å‡å°‘ä¸´ç•ŒåŒºå¤§å°

3. å†…å­˜åˆ†é…ä¼˜åŒ–ï¼š
   - ä½¿ç”¨sync.Poolå¤ç”¨å¯¹è±¡
   - é¢„åˆ†é…åˆ‡ç‰‡å’Œæ˜ å°„
   - é¿å…ä¸å¿…è¦çš„å­—ç¬¦ä¸²æ“ä½œ

4. Channelä½¿ç”¨ï¼š
   - é€‰æ‹©åˆé€‚çš„ç¼“å†²åŒºå¤§å°
   - é¿å…æ— ç¼“å†²Channelé€ æˆçš„é˜»å¡
   - æ­£ç¡®å…³é—­Channel

5. èµ„æºç®¡ç†ï¼š
   - ä½¿ç”¨contextè¿›è¡Œè¶…æ—¶æ§åˆ¶
   - åŠæ—¶é‡Šæ”¾èµ„æº
   - é¿å…goroutineæ³„æ¼
*/
```

### 5.2 ç›‘æ§å’Œè°ƒè¯•å·¥å…·

```go
// æ¨èçš„ç›‘æ§å’Œè°ƒè¯•å·¥å…·
/*
1. pprofï¼š
   - go tool pprof http://localhost:6060/debug/pprof/profile
   - go tool pprof http://localhost:6060/debug/pprof/heap
   - go tool pprof http://localhost:6060/debug/pprof/block

2. ç«æ€æ£€æµ‹ï¼š
   - go run -race
   - go build -race

3. æ€§èƒ½åˆ†æï¼š
   - runtime.ReadMemStats()
   - expvaråŒ…ç”¨äºå¯¼å‡ºå˜é‡
   - è‡ªå®šä¹‰ç›‘æ§æŒ‡æ ‡

4. æ—¥å¿—è®°å½•ï¼š
   - ç»“æ„åŒ–æ—¥å¿—è®°å½•
   - åŒ…å«goroutine IDæˆ–è¯·æ±‚ID
   - é€‚å½“çš„æ—¥å¿—çº§åˆ«
*/
```

---

## æ€»ç»“

### æ ¸å¿ƒæ¦‚å¿µå›é¡¾

1. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - GOMAXPROCSè°ƒä¼˜
   - å‡å°‘é”ç«äº‰çš„æŠ€æœ¯
   - å†…å­˜åˆ†é…ä¼˜åŒ–

2. **æ€§èƒ½åˆ†æ**ï¼š
   - pprofå·¥å…·çš„ä½¿ç”¨
   - CPUã€å†…å­˜ã€é˜»å¡åˆ†æ
   - æ€§èƒ½ç“¶é¢ˆè¯†åˆ«

3. **ç›‘æ§è°ƒè¯•**ï¼š
   - è¿è¡Œæ—¶æŒ‡æ ‡æ”¶é›†
   - æ­»é”å’Œç«æ€æ¡ä»¶æ£€æµ‹
   - é”™è¯¯å¤„ç†å’Œæ¢å¤

4. **é«˜çº§æ¨¡å¼**ï¼š
   - Future/Promiseæ¨¡å¼
   - å“åº”å¼æµå¤„ç†
   - å¹¶è¡Œå¤„ç†æŠ€æœ¯

æŒæ¡è¿™äº›é«˜çº§å¹¶å‘æŠ€æœ¯åï¼Œä½ å°†èƒ½å¤Ÿæ„å»ºé«˜æ€§èƒ½ã€é«˜å¯é æ€§çš„Goå¹¶å‘ç¨‹åºã€‚è®°ä½ï¼Œåˆç†çš„æ¶æ„è®¾è®¡å’ŒæŒç»­çš„æ€§èƒ½ç›‘æ§æ˜¯ä¿æŒç³»ç»Ÿé«˜æ€§èƒ½çš„å…³é”®ã€‚

> **æ·±å…¥å­¦ä¹ **ï¼šå…³äºGMPè°ƒåº¦æ¨¡å‹çš„è¯¦ç»†å†…å®¹ï¼Œè¯·å‚è€ƒ[13.1ã€Goè¯­è¨€é«˜çº§ï¼šGMPè°ƒåº¦æ¨¡å‹](./13.1.Goè¯­è¨€é«˜çº§ï¼šGMPè°ƒåº¦æ¨¡å‹.md)æ–‡æ¡£ã€‚