---
title: 15、Go语言高级：并发控制
date: 2026-01-06
description: 深入理解Go语言的并发控制机制，包括Select语句、同步原语和并发协调技术
---

# 15、Go语言高级：并发控制

本文档将详细介绍Go语言中的并发控制机制，包括Select语句、各种同步原语和并发协调技术。这些工具是构建可靠并发程序的基础。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 理解Select语句的工作原理和使用方法
- ✅ 掌握各种同步原语（Mutex、RWMutex、Once、Cond）
- ✅ 学会使用Select进行并发协调
- ✅ 理解超时控制和非阻塞操作
- ✅ 掌握Context在并发控制中的应用

---

## 一、Select语句

### 1.1 Select基本概念

Select是Go语言中用于多路复用的关键字，它允许一个goroutine同时等待多个通信操作。Select会随机选择一个可用的通信操作执行。

#### Select的特点：
- **多路复用**：同时监控多个Channel
- **随机选择**：当多个case都可用时，随机选择一个执行
- **阻塞机制**：当没有case可用时，Select会阻塞

### 1.2 Select基本语法

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    // 启动两个goroutine
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "来自Channel 1的消息"
    }()
    
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "来自Channel 2的消息"
    }()
    
    fmt.Println("等待接收消息...")
    
    // 使用Select同时监听两个Channel
    select {
    case msg1 := <-ch1:
        fmt.Printf("接收到: %s\n", msg1)
    case msg2 := <-ch2:
        fmt.Printf("接收到: %s\n", msg2)
    }
    
    fmt.Println("Select执行完毕")
}
```

### 1.3 Select多case处理

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    ch3 := make(chan int)
    
    // 启动三个goroutine
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- 1
    }()
    
    go func() {
        time.Sleep(500 * time.Millisecond)
        ch2 <- 2
    }()
    
    go func() {
        time.Sleep(1500 * time.Millisecond)
        ch3 <- 3
    }()
    
    // 接收前3个消息
    for i := 0; i < 3; i++ {
        select {
        case val1 := <-ch1:
            fmt.Printf("从Channel 1接收到: %d\n", val1)
        case val2 := <-ch2:
            fmt.Printf("从Channel 2接收到: %d\n", val2)
        case val3 := <-ch3:
            fmt.Printf("从Channel 3接收到: %d\n", val3)
        }
    }
}
```

---

## 二、Select的高级用法

### 2.1 Default分支（非阻塞操作）

Default分支使Select成为非阻塞操作：

```go
package main

import "fmt"

func main() {
    ch := make(chan int)
    
    // 非阻塞接收
    select {
    case value := <-ch:
        fmt.Printf("接收到值: %d\n", value)
    default:
        fmt.Println("Channel为空，无法接收")
    }
    
    // 非阻塞发送
    select {
    case ch <- 42:
        fmt.Println("成功发送值")
    default:
        fmt.Println("Channel已满，无法发送")
    }
    
    // 创建带缓冲的Channel
    bufferedCh := make(chan int, 1)
    bufferedCh <- 10
    
    // 尝试再次发送
    select {
    case bufferedCh <- 20:
        fmt.Println("成功发送到缓冲Channel")
    default:
        fmt.Println("缓冲Channel已满")
    }
}
```

### 2.2 超时控制

使用time包实现超时控制：

```go
package main

import (
    "fmt"
    "time"
)

func timeoutExample() {
    ch := make(chan string)
    
    go func() {
        time.Sleep(3 * time.Second) // 模拟长时间操作
        ch <- "操作完成"
    }()
    
    fmt.Println("等待操作结果...")
    
    // 设置超时时间为2秒
    select {
    case result := <-ch:
        fmt.Printf("接收到结果: %s\n", result)
    case <-time.After(2 * time.Second):
        fmt.Println("操作超时")
    }
    
    // 再次尝试，这次超时时间为5秒
    select {
    case result := <-ch:
        fmt.Printf("接收到结果: %s\n", result)
    case <-time.After(5 * time.Second):
        fmt.Println("操作超时")
    }
}

func main() {
    timeoutExample()
}
```

### 2.3 Select中的发送操作

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)
    
    // 接收器
    go func() {
        for {
            select {
            case msg1 := <-ch1:
                fmt.Printf("从Channel 1接收到: %s\n", msg1)
            case msg2 := <-ch2:
                fmt.Printf("从Channel 2接收到: %s\n", msg2)
            }
        }
    }()
    
    // 发送器
    go func() {
        for i := 1; i <= 3; i++ {
            select {
            case ch1 <- fmt.Sprintf("消息%d到Channel1", i):
                fmt.Printf("发送到Channel 1: 消息%d\n", i)
            case ch2 <- fmt.Sprintf("消息%d到Channel2", i):
                fmt.Printf("发送到Channel 2: 消息%d\n", i)
            case <-time.After(100 * time.Millisecond):
                fmt.Printf("发送消息%d超时\n", i)
            }
            time.Sleep(200 * time.Millisecond)
        }
    }()
    
    time.Sleep(3 * time.Second) // 等待执行
}
```

### 2.4 Select死锁检测

```go
package main

import (
    "fmt"
    "time"
)

// 演示如何避免Select死锁
func avoidDeadlock() {
    ch := make(chan int)
    
    go func() {
        time.Sleep(1 * time.Second)
        ch <- 42
    }()
    
    // 使用带超时的Select避免无限阻塞
    select {
    case value := <-ch:
        fmt.Printf("接收到值: %d\n", value)
    case <-time.After(2 * time.Second):
        fmt.Println("超时，没有接收到值")
    }
}

func main() {
    avoidDeadlock()
}
```

---

## 三、同步原语

### 3.1 Mutex（互斥锁）

Mutex是最常用的同步原语，用于保护临界区。

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 共享资源
type Counter struct {
    mu    sync.Mutex
    value int
}

// 增加计数器值
func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

// 获取计数值
func (c *Counter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func mutexExample() {
    counter := &Counter{}
    var wg sync.WaitGroup
    
    // 启动10个goroutine同时增加计数器
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 100; j++ {
                counter.Increment()
                fmt.Printf("Goroutine %d, 当前值: %d\n", id, counter.Value())
            }
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("最终计数值: %d\n", counter.Value())
}

func main() {
    mutexExample()
}
```

### 3.2 RWMutex（读写锁）

RWMutex适用于读多写少的场景。

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type SafeMap struct {
    mu   sync.RWMutex
    data map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]int),
    }
}

// 写操作
func (sm *SafeMap) Set(key string, value int) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.data[key] = value
}

// 读操作
func (sm *SafeMap) Get(key string) (int, bool) {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    value, ok := sm.data[key]
    return value, ok
}

// 获取所有键
func (sm *SafeMap) Keys() []string {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    keys := make([]string, 0, len(sm.data))
    for k := range sm.data {
        keys = append(keys, k)
    }
    return keys
}

func rwMutexExample() {
    sm := NewSafeMap()
    var wg sync.WaitGroup
    
    // 启动写goroutine
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            key := fmt.Sprintf("key%d", i)
            sm.Set(key, i*10)
            fmt.Printf("写入: %s = %d\n", key, i*10)
            time.Sleep(200 * time.Millisecond)
        }
    }()
    
    // 启动读goroutine
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(readerID int) {
            defer wg.Done()
            for j := 0; j < 5; j++ {
                keys := sm.Keys()
                for _, key := range keys {
                    if value, ok := sm.Get(key); ok {
                        fmt.Printf("Reader %d 读取 %s = %d\n", readerID, key, value)
                    }
                }
                time.Sleep(300 * time.Millisecond)
            }
        }(i)
    }
    
    wg.Wait()
}

func main() {
    rwMutexExample()
}
```

### 3.3 Once（单次执行）

Once确保某个函数只执行一次。

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var once sync.Once
var resource string

func initializeResource() {
    fmt.Println("初始化资源...")
    time.Sleep(1 * time.Second) // 模拟初始化时间
    resource = "已初始化的资源"
    fmt.Println("资源初始化完成")
}

func accessResource() string {
    once.Do(initializeResource) // 确保只初始化一次
    return resource
}

func onceExample() {
    var wg sync.WaitGroup
    
    // 启动10个goroutine同时访问资源
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            res := accessResource()
            fmt.Printf("Goroutine %d 访问资源: %s\n", id, res)
        }(i)
    }
    
    wg.Wait()
    fmt.Printf("最终资源状态: %s\n", resource)
}

func main() {
    onceExample()
}
```

### 3.4 Cond（条件变量）

Cond用于goroutine间的条件同步。

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type TaskQueue struct {
    cond  *sync.Cond
    tasks []string
}

func NewTaskQueue() *TaskQueue {
    return &TaskQueue{
        cond: sync.NewCond(&sync.Mutex{}),
    }
}

// 添加任务
func (tq *TaskQueue) AddTask(task string) {
    tq.cond.L.Lock()
    defer tq.cond.L.Unlock()
    tq.tasks = append(tq.tasks, task)
    fmt.Printf("添加任务: %s\n", task)
    tq.cond.Signal() // 通知等待的worker
}

// 获取任务
func (tq *TaskQueue) GetTask() string {
    tq.cond.L.Lock()
    defer tq.cond.L.Unlock()
    
    // 等待直到有任务
    for len(tq.tasks) == 0 {
        fmt.Println("等待任务...")
        tq.cond.Wait()
    }
    
    task := tq.tasks[0]
    tq.tasks = tq.tasks[1:]
    return task
}

func condExample() {
    queue := NewTaskQueue()
    var wg sync.WaitGroup
    
    // 启动3个worker
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(workerID int) {
            defer wg.Done()
            for {
                task := queue.GetTask()
                fmt.Printf("Worker %d 处理任务: %s\n", workerID, task)
                time.Sleep(1 * time.Second) // 模拟处理时间
                
                // 随机决定是否继续
                if len(queue.tasks) == 0 && workerID > 0 {
                    return // 避免无限循环
                }
            }
        }(i)
    }
    
    // 添加一些任务
    time.Sleep(500 * time.Millisecond)
    for i := 1; i <= 5; i++ {
        queue.AddTask(fmt.Sprintf("任务%d", i))
        time.Sleep(300 * time.Millisecond)
    }
    
    time.Sleep(3 * time.Second)
}

func main() {
    condExample()
}
```

---

## 四、并发协调模式

### 4.1 信号量模式

使用Channel模拟信号量控制并发数量：

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 信号量结构
type Semaphore struct {
    ch chan struct{}
}

func NewSemaphore(maxConcurrency int) *Semaphore {
    return &Semaphore{
        ch: make(chan struct{}, maxConcurrency),
    }
}

func (s *Semaphore) Acquire() {
    s.ch <- struct{}{}
}

func (s *Semaphore) Release() {
    <-s.ch
}

func semaphoreExample() {
    // 限制最大并发数为3
    sem := NewSemaphore(3)
    var wg sync.WaitGroup
    
    // 启动10个任务
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go func(taskID int) {
            defer wg.Done()
            
            fmt.Printf("任务 %d 等待获取信号量\n", taskID)
            sem.Acquire()
            defer sem.Release()
            
            fmt.Printf("任务 %d 开始执行\n", taskID)
            time.Sleep(2 * time.Second) // 模拟工作
            fmt.Printf("任务 %d 执行完成\n", taskID)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("所有任务完成")
}

func main() {
    semaphoreExample()
}
```

### 4.2 生产者-消费者模式

结合Channel和Select实现复杂的生产者-消费者模式：

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

type Job struct {
    ID       int
    Priority int
    Data     string
}

type PriorityQueue struct {
    high   chan Job  // 高优先级
    medium chan Job  // 中优先级
    low    chan Job  // 低优先级
    quit   chan bool
}

func NewPriorityQueue() *PriorityQueue {
    return &PriorityQueue{
        high:   make(chan Job, 10),
        medium: make(chan Job, 10),
        low:    make(chan Job, 10),
        quit:   make(chan bool),
    }
}

func (pq *PriorityQueue) ProduceJobs(numJobs int) {
    for i := 1; i <= numJobs; i++ {
        job := Job{
            ID:       i,
            Priority: rand.Intn(3), // 0=高, 1=中, 2=低
            Data:     fmt.Sprintf("数据-%d", i),
        }
        
        switch job.Priority {
        case 0:
            pq.high <- job
            fmt.Printf("生产高优先级任务: %d\n", job.ID)
        case 1:
            pq.medium <- job
            fmt.Printf("生产中优先级任务: %d\n", job.ID)
        case 2:
            pq.low <- job
            fmt.Printf("生产低优先级任务: %d\n", job.ID)
        }
        
        time.Sleep(100 * time.Millisecond)
    }
}

func (pq *PriorityQueue) ConsumeJobs() {
    for {
        select {
        case job := <-pq.high:
            fmt.Printf("处理高优先级任务: %d (%s)\n", job.ID, job.Data)
            time.Sleep(300 * time.Millisecond)
        case job := <-pq.medium:
            fmt.Printf("处理中优先级任务: %d (%s)\n", job.ID, job.Data)
            time.Sleep(400 * time.Millisecond)
        case job := <-pq.low:
            fmt.Printf("处理低优先级任务: %d (%s)\n", job.ID, job.Data)
            time.Sleep(500 * time.Millisecond)
        case <-pq.quit:
            fmt.Println("消费者退出")
            return
        default:
            // 当没有任务时，短暂休眠
            time.Sleep(50 * time.Millisecond)
        }
    }
}

func priorityQueueExample() {
    pq := NewPriorityQueue()
    var wg sync.WaitGroup
    
    // 启动生产者
    wg.Add(1)
    go func() {
        defer wg.Done()
        pq.ProduceJobs(15)
    }()
    
    // 启动消费者
    wg.Add(1)
    go func() {
        defer wg.Done()
        pq.ConsumeJobs()
    }()
    
    time.Sleep(10 * time.Second) // 运行一段时间
    pq.quit <- true              // 发送退出信号
    
    wg.Wait()
}

func main() {
    rand.Seed(time.Now().UnixNano())
    priorityQueueExample()
}
```

### 4.3 超时重试模式

使用Select实现带超时和重试的模式：

```go
package main

import (
    "fmt"
    "math/rand"
    "time"
)

// 模拟一个可能失败的操作
func unreliableOperation(operationID int) error {
    // 30%的概率失败
    if rand.Float32() < 0.3 {
        return fmt.Errorf("操作 %d 失败", operationID)
    }
    fmt.Printf("操作 %d 成功\n", operationID)
    return nil
}

// 带超时和重试的操作
func operationWithRetryAndTimeout(opID int, maxRetries int, timeout time.Duration) error {
    for attempt := 1; attempt <= maxRetries; attempt++ {
        fmt.Printf("尝试执行操作 %d，第 %d 次\n", opID, attempt)
        
        done := make(chan error, 1)
        
        // 在goroutine中执行操作
        go func() {
            done <- unreliableOperation(opID)
        }()
        
        // 等待操作完成或超时
        select {
        case err := <-done:
            if err == nil {
                fmt.Printf("操作 %d 在第 %d 次尝试后成功\n", opID, attempt)
                return nil
            }
            fmt.Printf("操作 %d 第 %d 次尝试失败: %v\n", opID, attempt, err)
            
        case <-time.After(timeout):
            fmt.Printf("操作 %d 第 %d 次尝试超时\n", opID, attempt)
        }
        
        // 如果不是最后一次尝试，等待一段时间再重试
        if attempt < maxRetries {
            waitTime := time.Duration(attempt) * 200 * time.Millisecond
            fmt.Printf("等待 %.2f 秒后重试...\n", waitTime.Seconds())
            time.Sleep(waitTime)
        }
    }
    
    return fmt.Errorf("操作 %d 经过 %d 次尝试后仍然失败", opID, maxRetries)
}

func retryTimeoutExample() {
    rand.Seed(time.Now().UnixNano())
    
    // 测试多个操作
    for i := 1; i <= 5; i++ {
        fmt.Printf("\n--- 执行操作 %d ---\n", i)
        err := operationWithRetryAndTimeout(i, 3, 1*time.Second)
        if err != nil {
            fmt.Printf("操作 %d 最终失败: %v\n", i, err)
        }
        time.Sleep(500 * time.Millisecond)
    }
}

func main() {
    retryTimeoutExample()
}
```

---

## 五、Context在并发控制中的应用

### 5.1 Context基础

Context用于在goroutine间传递截止时间、取消信号和其他请求范围的值。

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func contextExample() {
    // 创建根context
    ctx := context.Background()
    
    // 创建带取消功能的context
    ctxWithCancel, cancel := context.WithCancel(ctx)
    defer cancel()
    
    // 创建带超时的context
    ctxWithTimeout, cancel2 := context.WithTimeout(ctx, 3*time.Second)
    defer cancel2()
    
    // 创建带截止时间的context
    deadline := time.Now().Add(5 * time.Second)
    ctxWithDeadline, cancel3 := context.WithDeadline(ctx, deadline)
    defer cancel3()
    
    fmt.Println("启动goroutine...")
    
    go func() {
        select {
        case <-ctxWithCancel.Done():
            fmt.Println("Cancel context 完成:", ctxWithCancel.Err())
        case <-time.After(2 * time.Second):
            fmt.Println("Cancel context 仍在运行")
        }
    }()
    
    go func() {
        <-ctxWithTimeout.Done()
        fmt.Println("Timeout context 完成:", ctxWithTimeout.Err())
    }()
    
    go func() {
        <-ctxWithDeadline.Done()
        fmt.Println("Deadline context 完成:", ctxWithDeadline.Err())
    }()
    
    time.Sleep(4 * time.Second)
}

func main() {
    contextExample()
}
```

### 5.2 Context链式调用

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func chainedContextExample() {
    // 创建根context
    rootCtx := context.Background()
    
    // 添加值到context
    ctxWithValue := context.WithValue(rootCtx, "requestId", "12345")
    
    // 创建带超时的子context
    ctxWithTimeout, cancel := context.WithTimeout(ctxWithValue, 2*time.Second)
    defer cancel()
    
    // 创建更深层的子context
    deepCtx, deepCancel := context.WithCancel(ctxWithTimeout)
    defer deepCancel()
    
    fmt.Printf("Request ID: %v\n", ctxWithValue.Value("requestId"))
    fmt.Printf("Deep context Request ID: %v\n", deepCtx.Value("requestId"))
    
    go func(ctx context.Context) {
        for {
            select {
            case <-ctx.Done():
                fmt.Println("Goroutine收到取消信号:", ctx.Err())
                return
            case <-time.After(500 * time.Millisecond):
                fmt.Println("Goroutine仍在运行...")
            }
        }
    }(deepCtx)
    
    time.Sleep(3 * time.Second)
    fmt.Println("主函数即将结束")
}

func main() {
    chainedContextExample()
}
```

### 5.3 Context在HTTP服务中的应用

```go
package main

import (
    "context"
    "fmt"
    "time"
)

// 模拟数据库查询
func databaseQuery(ctx context.Context, query string) (string, error) {
    // 模拟查询时间
    select {
    case <-time.After(2 * time.Second):
        // 检查context是否已被取消
        select {
        case <-ctx.Done():
            return "", ctx.Err()
        default:
            return fmt.Sprintf("查询结果: %s", query), nil
        }
    case <-ctx.Done():
        return "", ctx.Err()
    }
}

// 模拟外部API调用
func externalAPICall(ctx context.Context, endpoint string) (string, error) {
    select {
    case <-time.After(1 * time.Second):
        select {
        case <-ctx.Done():
            return "", ctx.Err()
        default:
            return fmt.Sprintf("API响应: %s", endpoint), nil
        }
    case <-ctx.Done():
        return "", ctx.Err()
    }
}

// 业务逻辑函数
func businessLogic(ctx context.Context, userID string) (string, error) {
    // 检查context是否已被取消
    select {
    case <-ctx.Done():
        return "", ctx.Err()
    default:
    }
    
    // 查询用户信息
    userInfo, err := databaseQuery(ctx, fmt.Sprintf("SELECT * FROM users WHERE id = '%s'", userID))
    if err != nil {
        return "", err
    }
    
    // 调用外部API
    apiResponse, err := externalAPICall(ctx, fmt.Sprintf("/api/user/%s/profile", userID))
    if err != nil {
        return "", err
    }
    
    return fmt.Sprintf("用户信息: %s, API响应: %s", userInfo, apiResponse), nil
}

func contextPropagationExample() {
    // 创建带超时的context
    ctx, cancel := context.WithTimeout(context.Background(), 1500*time.Millisecond)
    defer cancel()
    
    // 添加请求相关的信息
    ctx = context.WithValue(ctx, "requestId", "req-001")
    ctx = context.WithValue(ctx, "userId", "user-123")
    
    fmt.Printf("请求ID: %v\n", ctx.Value("requestId"))
    
    result, err := businessLogic(ctx, ctx.Value("userId").(string))
    if err != nil {
        fmt.Printf("业务逻辑执行失败: %v\n", err)
    } else {
        fmt.Printf("业务逻辑执行成功: %s\n", result)
    }
}

func main() {
    contextPropagationExample()
}
```

---

## 六、并发控制最佳实践

### 6.1 避免死锁

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 正确的锁顺序避免死锁
type SafeAccount struct {
    id  int
    balance int
    mu  sync.Mutex
}

func transfer(from, to *SafeAccount, amount int) {
    // 确保总是按照相同的顺序获取锁
    first, second := from, to
    if from.id > to.id {
        first, second = to, from
    }
    
    first.mu.Lock()
    defer first.mu.Unlock()
    
    second.mu.Lock()
    defer second.mu.Unlock()
    
    if from.balance >= amount {
        from.balance -= amount
        to.balance += amount
        fmt.Printf("转账 %d: %d -> %d, From余额: %d, To余额: %d\n", 
                   amount, from.id, to.id, from.balance, to.balance)
    } else {
        fmt.Printf("余额不足，转账失败\n")
    }
}

func deadlockPreventionExample() {
    account1 := &SafeAccount{id: 1, balance: 1000}
    account2 := &SafeAccount{id: 2, balance: 1000}
    
    var wg sync.WaitGroup
    
    // 安全的并发转账
    wg.Add(2)
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            transfer(account1, account2, 10)
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            transfer(account2, account1, 15)
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    wg.Wait()
    fmt.Printf("最终余额 - 账户1: %d, 账户2: %d\n", account1.balance, account2.balance)
}

func main() {
    deadlockPreventionExample()
}
```

### 6.2 资源竞争检测

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 使用原子操作避免竞争
import "sync/atomic"

type AtomicCounter struct {
    value int64
}

func (ac *AtomicCounter) Increment() {
    atomic.AddInt64(&ac.value, 1)
}

func (ac *AtomicCounter) Value() int64 {
    return atomic.LoadInt64(&ac.value)
}

func raceDetectionExample() {
    counter := &AtomicCounter{}
    var wg sync.WaitGroup
    
    // 启动多个goroutine同时增加计数器
    numGoroutines := 10
    operationsPerGoroutine := 1000
    
    start := time.Now()
    
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(goroutineID int) {
            defer wg.Done()
            for j := 0; j < operationsPerGoroutine; j++ {
                counter.Increment()
                if j%100 == 0 {
                    current := counter.Value()
                    fmt.Printf("Goroutine %d, 当前计数: %d\n", goroutineID, current)
                }
            }
        }(i)
    }
    
    wg.Wait()
    duration := time.Since(start)
    
    expected := int64(numGoroutines * operationsPerGoroutine)
    actual := counter.Value()
    
    fmt.Printf("执行时间: %v\n", duration)
    fmt.Printf("期望值: %d, 实际值: %d\n", expected, actual)
    fmt.Printf("结果正确: %t\n", expected == actual)
}

func main() {
    raceDetectionExample()
}
```

---

## 总结

### 核心概念回顾

1. **Select语句**：
   - 多路复用通信操作
   - 支持超时和非阻塞操作
   - 随机选择可用的case

2. **同步原语**：
   - **Mutex**：保护临界区
   - **RWMutex**：读写分离优化
   - **Once**：单次执行保障
   - **Cond**：条件同步机制

3. **并发协调**：
   - 信号量控制并发数量
   - 生产者-消费者模式
   - 超时重试机制

4. **Context应用**：
   - 跨API边界传递截止时间
   - 取消信号传播
   - 请求范围的值传递

掌握这些并发控制技术后，你将能够构建更加健壮和高效的并发程序。在实际应用中，需要根据具体场景选择合适的同步机制。