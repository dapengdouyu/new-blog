---
title: 3ã€Ginè¿›é˜¶ï¼šä¸­é—´ä»¶ä¸è·¯ç”±ç»„
date: 2026-01-06
description: æ·±å…¥ç†è§£Ginæ¡†æ¶çš„ä¸­é—´ä»¶æœºåˆ¶å’Œè·¯ç”±ç»„çš„ä½¿ç”¨
---

# 3ã€Ginè¿›é˜¶ï¼šä¸­é—´ä»¶ä¸è·¯ç”±ç»„

æœ¬æ–‡æ¡£æ·±å…¥è®²è§£Ginæ¡†æ¶çš„ä¸­é—´ä»¶æœºåˆ¶ï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨è·¯ç”±ç»„æ¥ç»„ç»‡ä»£ç ã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… ç†è§£ä¸­é—´ä»¶çš„æ¦‚å¿µå’Œä½œç”¨
- âœ… æŒæ¡è‡ªå®šä¹‰ä¸­é—´ä»¶çš„ç¼–å†™
- âœ… å­¦ä¼šä½¿ç”¨è·¯ç”±ç»„ç»„ç»‡ä»£ç 
- âœ… å®ç°è®¤è¯å’Œæˆæƒä¸­é—´ä»¶
- âœ… ç†è§£ä¸­é—´ä»¶çš„æ‰§è¡Œé¡ºåº

---

## ä¸€ã€ä¸­é—´ä»¶åŸºç¡€

### 1.1 ä»€ä¹ˆæ˜¯ä¸­é—´ä»¶ï¼Ÿ

ä¸­é—´ä»¶ï¼ˆMiddlewareï¼‰æ˜¯åœ¨HTTPè¯·æ±‚åˆ°è¾¾å¤„ç†å™¨ä¹‹å‰æˆ–ä¹‹åæ‰§è¡Œçš„å‡½æ•°ã€‚å®ƒå¯ä»¥ï¼š

- **å¤„ç†è¯·æ±‚**ï¼šä¿®æ”¹è¯·æ±‚ã€éªŒè¯æƒé™ã€è®°å½•æ—¥å¿—
- **å¤„ç†å“åº”**ï¼šä¿®æ”¹å“åº”ã€æ·»åŠ å“åº”å¤´ã€å‹ç¼©å“åº”
- **æ§åˆ¶æµç¨‹**ï¼šå†³å®šæ˜¯å¦ç»§ç»­å¤„ç†è¯·æ±‚

### 1.2 ä¸­é—´ä»¶çš„ç­¾å

ä¸­é—´ä»¶å‡½æ•°çš„ç­¾åï¼š

```go
func(c *gin.Context)
```

ä¸­é—´ä»¶é€šè¿‡è°ƒç”¨`c.Next()`ç»§ç»­æ‰§è¡Œåç»­çš„ä¸­é—´ä»¶å’Œå¤„ç†å™¨ï¼Œæˆ–è°ƒç”¨`c.Abort()`ç»ˆæ­¢æ‰§è¡Œã€‚

### 1.3 åŸºæœ¬ä¸­é—´ä»¶ç¤ºä¾‹

```go
package main

import (
    "github.com/gin-gonic/gin"
    "time"
)

func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        // è¯·æ±‚å‰
        start := time.Now()
        path := c.Request.URL.Path
        
        // ç»§ç»­å¤„ç†è¯·æ±‚
        c.Next()
        
        // è¯·æ±‚å
        latency := time.Since(start)
        status := c.Writer.Status()
        
        fmt.Printf("[%s] %s %s %d %v\n",
            time.Now().Format("2006-01-02 15:04:05"),
            c.Request.Method,
            path,
            status,
            latency,
        )
    }
}

func main() {
    r := gin.New()
    
    // ä½¿ç”¨ä¸­é—´ä»¶
    r.Use(Logger())
    
    r.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "Hello"})
    })
    
    r.Run()
}
```

---

## äºŒã€å†…ç½®ä¸­é—´ä»¶

### 2.1 Loggerä¸­é—´ä»¶

è®°å½•HTTPè¯·æ±‚æ—¥å¿—ï¼š

```go
package main

import "github.com/gin-gonic/gin"

func main() {
    r := gin.Default() // å·²åŒ…å«Loggerå’ŒRecovery
    
    // æˆ–è€…æ‰‹åŠ¨æ·»åŠ 
    // r := gin.New()
    // r.Use(gin.Logger())
    
    r.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{"message": "Hello"})
    })
    
    r.Run()
}
```

### 2.2 Recoveryä¸­é—´ä»¶

æ•è·panicå¹¶è¿”å›500é”™è¯¯ï¼š

```go
r := gin.New()
r.Use(gin.Recovery())
```

### 2.3 è‡ªå®šä¹‰Loggeræ ¼å¼

```go
r := gin.New()

// è‡ªå®šä¹‰æ—¥å¿—æ ¼å¼
r.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
    return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
        param.ClientIP,
        param.TimeStamp.Format(time.RFC1123),
        param.Method,
        param.Path,
        param.Request.Protocol,
        param.StatusCode,
        param.Latency,
        param.Request.UserAgent(),
        param.ErrorMessage,
    )
}))
```

---

## ä¸‰ã€è‡ªå®šä¹‰ä¸­é—´ä»¶

### 3.1 ç®€å•ä¸­é—´ä»¶

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

// è®¤è¯ä¸­é—´ä»¶
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        
        if token == "" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Authorization header required",
            })
            c.Abort() // ç»ˆæ­¢åç»­å¤„ç†
            return
        }
        
        // éªŒè¯tokenï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
        if token != "Bearer valid-token" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Invalid token",
            })
            c.Abort()
            return
        }
        
        // éªŒè¯é€šè¿‡ï¼Œç»§ç»­å¤„ç†
        c.Next()
    }
}

func main() {
    r := gin.Default()
    
    // åº”ç”¨ä¸­é—´ä»¶
    r.Use(AuthMiddleware())
    
    r.GET("/protected", func(c *gin.Context) {
        c.JSON(200, gin.H{
            "message": "This is a protected route",
        })
    })
    
    r.Run()
}
```

### 3.2 å¸¦é…ç½®çš„ä¸­é—´ä»¶

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
    "time"
)

// CORSä¸­é—´ä»¶é…ç½®
type CORSConfig struct {
    AllowOrigins     []string
    AllowMethods     []string
    AllowHeaders     []string
    ExposeHeaders    []string
    AllowCredentials bool
    MaxAge           time.Duration
}

// CORSä¸­é—´ä»¶
func CORSMiddleware(config CORSConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.GetHeader("Origin")
        
        // æ£€æŸ¥æºæ˜¯å¦å…è®¸
        allowed := false
        for _, o := range config.AllowOrigins {
            if o == "*" || o == origin {
                allowed = true
                break
            }
        }
        
        if allowed {
            c.Header("Access-Control-Allow-Origin", origin)
        }
        
        if config.AllowCredentials {
            c.Header("Access-Control-Allow-Credentials", "true")
        }
        
        if len(config.AllowMethods) > 0 {
            methods := ""
            for i, m := range config.AllowMethods {
                if i > 0 {
                    methods += ", "
                }
                methods += m
            }
            c.Header("Access-Control-Allow-Methods", methods)
        }
        
        if len(config.AllowHeaders) > 0 {
            headers := ""
            for i, h := range config.AllowHeaders {
                if i > 0 {
                    headers += ", "
                }
                headers += h
            }
            c.Header("Access-Control-Allow-Headers", headers)
        }
        
        // å¤„ç†é¢„æ£€è¯·æ±‚
        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(http.StatusNoContent)
            return
        }
        
        c.Next()
    }
}

func main() {
    r := gin.Default()
    
    // é…ç½®CORS
    r.Use(CORSMiddleware(CORSConfig{
        AllowOrigins:     []string{"http://localhost:3000"},
        AllowMethods:     []string{"GET", "POST", "PUT", "DELETE"},
        AllowHeaders:     []string{"Content-Type", "Authorization"},
        AllowCredentials: true,
        MaxAge:           12 * time.Hour,
    }))
    
    r.GET("/api/data", func(c *gin.Context) {
        c.JSON(200, gin.H{"data": "Hello"})
    })
    
    r.Run()
}
```

### 3.3 è¯·æ±‚é™æµä¸­é—´ä»¶

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
    "sync"
    "time"
)

type RateLimiter struct {
    requests map[string][]time.Time
    mutex    sync.Mutex
    limit    int
    window   time.Duration
}

func NewRateLimiter(limit int, window time.Duration) *RateLimiter {
    return &RateLimiter{
        requests: make(map[string][]time.Time),
        limit:   limit,
        window:  window,
    }
}

func (rl *RateLimiter) Middleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        ip := c.ClientIP()
        
        rl.mutex.Lock()
        defer rl.mutex.Unlock()
        
        now := time.Now()
        
        // æ¸…ç†è¿‡æœŸè¯·æ±‚
        if times, exists := rl.requests[ip]; exists {
            validTimes := []time.Time{}
            for _, t := range times {
                if now.Sub(t) < rl.window {
                    validTimes = append(validTimes, t)
                }
            }
            rl.requests[ip] = validTimes
        }
        
        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
        if len(rl.requests[ip]) >= rl.limit {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Rate limit exceeded",
            })
            c.Abort()
            return
        }
        
        // è®°å½•æœ¬æ¬¡è¯·æ±‚
        rl.requests[ip] = append(rl.requests[ip], now)
        
        c.Next()
    }
}

func main() {
    r := gin.Default()
    
    // é™æµï¼šæ¯åˆ†é’Ÿæœ€å¤š10ä¸ªè¯·æ±‚
    limiter := NewRateLimiter(10, time.Minute)
    r.Use(limiter.Middleware())
    
    r.GET("/api/data", func(c *gin.Context) {
        c.JSON(200, gin.H{"data": "Hello"})
    })
    
    r.Run()
}
```

---

## å››ã€ä¸­é—´ä»¶çš„æ‰§è¡Œé¡ºåº

### 4.1 æ‰§è¡Œæµç¨‹

ä¸­é—´ä»¶çš„æ‰§è¡Œé¡ºåºï¼š

```
è¯·æ±‚ â†’ ä¸­é—´ä»¶1 â†’ ä¸­é—´ä»¶2 â†’ ... â†’ å¤„ç†å™¨ â†’ ... â†’ ä¸­é—´ä»¶2 â†’ ä¸­é—´ä»¶1 â†’ å“åº”
```

### 4.2 ç¤ºä¾‹

```go
package main

import (
    "fmt"
    "github.com/gin-gonic/gin"
)

func Middleware1() gin.HandlerFunc {
    return func(c *gin.Context) {
        fmt.Println("Middleware1: Before")
        c.Next()
        fmt.Println("Middleware1: After")
    }
}

func Middleware2() gin.HandlerFunc {
    return func(c *gin.Context) {
        fmt.Println("Middleware2: Before")
        c.Next()
        fmt.Println("Middleware2: After")
    }
}

func Middleware3() gin.HandlerFunc {
    return func(c *gin.Context) {
        fmt.Println("Middleware3: Before")
        c.Next()
        fmt.Println("Middleware3: After")
    }
}

func main() {
    r := gin.New()
    
    // å…¨å±€ä¸­é—´ä»¶ï¼ˆæŒ‰é¡ºåºæ‰§è¡Œï¼‰
    r.Use(Middleware1())
    r.Use(Middleware2())
    
    r.GET("/test", Middleware3(), func(c *gin.Context) {
        fmt.Println("Handler: Processing")
        c.JSON(200, gin.H{"message": "OK"})
    })
    
    r.Run()
}
```

**è¾“å‡ºé¡ºåº**ï¼š

```
Middleware1: Before
Middleware2: Before
Middleware3: Before
Handler: Processing
Middleware3: After
Middleware2: After
Middleware1: After
```

### 4.3 ä½¿ç”¨Abortç»ˆæ­¢æ‰§è¡Œ

```go
func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token == "" {
            c.JSON(401, gin.H{"error": "Unauthorized"})
            c.Abort() // ç»ˆæ­¢æ‰§è¡Œï¼Œä¸ä¼šè°ƒç”¨åç»­ä¸­é—´ä»¶å’Œå¤„ç†å™¨
            return
        }
        c.Next()
    }
}
```

---

## äº”ã€è·¯ç”±ç»„ï¼ˆRoute Groupsï¼‰

### 5.1 åŸºæœ¬ä½¿ç”¨

è·¯ç”±ç»„ç”¨äºç»„ç»‡ç›¸å…³çš„è·¯ç”±å’Œä¸­é—´ä»¶ï¼š

```go
package main

import "github.com/gin-gonic/gin"

func main() {
    r := gin.Default()
    
    // åˆ›å»ºè·¯ç”±ç»„
    v1 := r.Group("/v1")
    {
        v1.GET("/users", func(c *gin.Context) {
            c.JSON(200, gin.H{"version": "v1", "path": "/users"})
        })
        v1.GET("/posts", func(c *gin.Context) {
            c.JSON(200, gin.H{"version": "v1", "path": "/posts"})
        })
    }
    
    v2 := r.Group("/v2")
    {
        v2.GET("/users", func(c *gin.Context) {
            c.JSON(200, gin.H{"version": "v2", "path": "/users"})
        })
        v2.GET("/posts", func(c *gin.Context) {
            c.JSON(200, gin.H{"version": "v2", "path": "/posts"})
        })
    }
    
    r.Run()
}
```

### 5.2 è·¯ç”±ç»„ä¸­é—´ä»¶

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func AuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token == "" {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            c.Abort()
            return
        }
        c.Next()
    }
}

func AdminMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        role := c.GetHeader("X-User-Role")
        if role != "admin" {
            c.JSON(http.StatusForbidden, gin.H{"error": "Forbidden"})
            c.Abort()
            return
        }
        c.Next()
    }
}

func main() {
    r := gin.Default()
    
    // å…¬å¼€è·¯ç”±
    public := r.Group("/public")
    {
        public.GET("/info", func(c *gin.Context) {
            c.JSON(200, gin.H{"message": "Public info"})
        })
    }
    
    // éœ€è¦è®¤è¯çš„è·¯ç”±
    private := r.Group("/private")
    private.Use(AuthMiddleware())
    {
        private.GET("/profile", func(c *gin.Context) {
            c.JSON(200, gin.H{"message": "User profile"})
        })
    }
    
    // éœ€è¦ç®¡ç†å‘˜æƒé™çš„è·¯ç”±
    admin := r.Group("/admin")
    admin.Use(AuthMiddleware(), AdminMiddleware())
    {
        admin.GET("/users", func(c *gin.Context) {
            c.JSON(200, gin.H{"message": "Admin users"})
        })
    }
    
    r.Run()
}
```

### 5.3 åµŒå¥—è·¯ç”±ç»„

```go
package main

import "github.com/gin-gonic/gin"

func main() {
    r := gin.Default()
    
    api := r.Group("/api")
    {
        // /api/v1/users
        v1 := api.Group("/v1")
        {
            users := v1.Group("/users")
            {
                users.GET("", func(c *gin.Context) {
                    c.JSON(200, gin.H{"path": "/api/v1/users"})
                })
                users.GET("/:id", func(c *gin.Context) {
                    id := c.Param("id")
                    c.JSON(200, gin.H{"path": "/api/v1/users/" + id})
                })
            }
        }
        
        // /api/v2/users
        v2 := api.Group("/v2")
        {
            users := v2.Group("/users")
            {
                users.GET("", func(c *gin.Context) {
                    c.JSON(200, gin.H{"path": "/api/v2/users"})
                })
            }
        }
    }
    
    r.Run()
}
```

---

## å…­ã€è®¤è¯ä¸­é—´ä»¶å®ç°

### 6.1 JWTè®¤è¯ä¸­é—´ä»¶

```go
package main

import (
    "github.com/gin-gonic/gin"
    "github.com/golang-jwt/jwt/v5"
    "net/http"
    "strings"
    "time"
)

var jwtSecret = []byte("your-secret-key")

type Claims struct {
    Username string `json:"username"`
    jwt.RegisteredClaims
}

func GenerateToken(username string) (string, error) {
    claims := Claims{
        Username: username,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(jwtSecret)
}

func JWTAuthMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Authorization header required",
            })
            c.Abort()
            return
        }
        
        // æå–token
        parts := strings.Split(authHeader, " ")
        if len(parts) != 2 || parts[0] != "Bearer" {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Invalid authorization header format",
            })
            c.Abort()
            return
        }
        
        tokenString := parts[1]
        
        // è§£ætoken
        claims := &Claims{}
        token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
            return jwtSecret, nil
        })
        
        if err != nil || !token.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Invalid token",
            })
            c.Abort()
            return
        }
        
        // å°†ç”¨æˆ·ä¿¡æ¯å­˜å‚¨åˆ°ä¸Šä¸‹æ–‡
        c.Set("username", claims.Username)
        
        c.Next()
    }
}

func main() {
    r := gin.Default()
    
    // ç™»å½•æ¥å£ï¼ˆä¸éœ€è¦è®¤è¯ï¼‰
    r.POST("/login", func(c *gin.Context) {
        var loginData struct {
            Username string `json:"username"`
            Password string `json:"password"`
        }
        
        if err := c.ShouldBindJSON(&loginData); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // éªŒè¯ç”¨æˆ·åå¯†ç ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
        if loginData.Username == "admin" && loginData.Password == "password" {
            token, err := GenerateToken(loginData.Username)
            if err != nil {
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
            }
            
            c.JSON(http.StatusOK, gin.H{
                "token": token,
            })
        } else {
            c.JSON(http.StatusUnauthorized, gin.H{
                "error": "Invalid credentials",
            })
        }
    })
    
    // éœ€è¦è®¤è¯çš„è·¯ç”±ç»„
    protected := r.Group("/api")
    protected.Use(JWTAuthMiddleware())
    {
        protected.GET("/profile", func(c *gin.Context) {
            username, _ := c.Get("username")
            c.JSON(http.StatusOK, gin.H{
                "username": username,
                "message": "This is a protected route",
            })
        })
    }
    
    r.Run()
}
```

---

## ä¸ƒã€ç»¼åˆç¤ºä¾‹

åˆ›å»ºä¸€ä¸ªå®Œæ•´çš„APIé¡¹ç›®ç»“æ„ï¼š

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
    "time"
)

// æ—¥å¿—ä¸­é—´ä»¶
func LoggerMiddleware() gin.HandlerFunc {
    return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
            param.ClientIP,
            param.TimeStamp.Format(time.RFC1123),
            param.Method,
            param.Path,
            param.Request.Protocol,
            param.StatusCode,
            param.Latency,
            param.Request.UserAgent(),
            param.ErrorMessage,
        )
    })
}

// è¯·æ±‚IDä¸­é—´ä»¶
func RequestIDMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        requestID := c.GetHeader("X-Request-ID")
        if requestID == "" {
            requestID = generateUUID() // éœ€è¦å®ç°UUIDç”Ÿæˆ
        }
        c.Header("X-Request-ID", requestID)
        c.Set("request_id", requestID)
        c.Next()
    }
}

func main() {
    r := gin.New()
    
    // å…¨å±€ä¸­é—´ä»¶
    r.Use(LoggerMiddleware())
    r.Use(gin.Recovery())
    r.Use(RequestIDMiddleware())
    
    // å¥åº·æ£€æŸ¥
    r.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "ok",
            "time":   time.Now().Unix(),
        })
    })
    
    // APIè·¯ç”±ç»„
    api := r.Group("/api/v1")
    {
        // ç”¨æˆ·è·¯ç”±ç»„
        users := api.Group("/users")
        {
            users.GET("", GetUsers)
            users.GET("/:id", GetUser)
            users.POST("", CreateUser)
            users.PUT("/:id", UpdateUser)
            users.DELETE("/:id", DeleteUser)
        }
        
        // éœ€è¦è®¤è¯çš„è·¯ç”±ç»„
        protected := api.Group("/protected")
        protected.Use(JWTAuthMiddleware())
        {
            protected.GET("/data", func(c *gin.Context) {
                c.JSON(http.StatusOK, gin.H{"data": "Protected data"})
            })
        }
    }
    
    r.Run(":8080")
}

// å¤„ç†å™¨å‡½æ•°
func GetUsers(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"users": []string{"user1", "user2"}})
}

func GetUser(c *gin.Context) {
    id := c.Param("id")
    c.JSON(http.StatusOK, gin.H{"id": id})
}

func CreateUser(c *gin.Context) {
    c.JSON(http.StatusCreated, gin.H{"message": "User created"})
}

func UpdateUser(c *gin.Context) {
    id := c.Param("id")
    c.JSON(http.StatusOK, gin.H{"id": id, "message": "User updated"})
}

func DeleteUser(c *gin.Context) {
    id := c.Param("id")
    c.JSON(http.StatusOK, gin.H{"id": id, "message": "User deleted"})
}
```

---

## æ€»ç»“

1. **ä¸­é—´ä»¶**ï¼šåœ¨è¯·æ±‚å¤„ç†å‰åæ‰§è¡Œçš„å‡½æ•°ï¼Œç”¨äºæ—¥å¿—ã€è®¤è¯ã€é™æµç­‰
2. **å†…ç½®ä¸­é—´ä»¶**ï¼šLoggerå’ŒRecoveryï¼Œ`gin.Default()`å·²åŒ…å«
3. **è‡ªå®šä¹‰ä¸­é—´ä»¶**ï¼šå¯ä»¥åˆ›å»ºå¸¦é…ç½®çš„ä¸­é—´ä»¶ï¼Œå®ç°å„ç§åŠŸèƒ½
4. **æ‰§è¡Œé¡ºåº**ï¼šæŒ‰æ·»åŠ é¡ºåºæ‰§è¡Œï¼Œ`c.Next()`ç»§ç»­ï¼Œ`c.Abort()`ç»ˆæ­¢
5. **è·¯ç”±ç»„**ï¼šç»„ç»‡ç›¸å…³è·¯ç”±ï¼Œå¯ä»¥åº”ç”¨ä¸­é—´ä»¶
6. **è®¤è¯ä¸­é—´ä»¶**ï¼šå®ç°JWTç­‰è®¤è¯æœºåˆ¶

**ä¸‹ä¸€æ­¥**ï¼šå­¦ä¹ [ç¬¬4è¯¾ï¼šæ•°æ®ç»‘å®šä¸éªŒè¯](./4.Ginå®è·µï¼šæ•°æ®ç»‘å®šä¸éªŒè¯.md)ï¼Œäº†è§£å¦‚ä½•å¤„ç†å’ŒéªŒè¯è¯·æ±‚æ•°æ®ã€‚
