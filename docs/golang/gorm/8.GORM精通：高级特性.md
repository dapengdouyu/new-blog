---
title: 8ã€GORMç²¾é€šï¼šé«˜çº§ç‰¹æ€§
date: 2026-01-09
description: æ·±å…¥å­¦ä¹ GORMçš„é«˜çº§ç‰¹æ€§ï¼ŒåŒ…æ‹¬è¿æ¥æ± ã€ä¸Šä¸‹æ–‡ã€è°ƒè¯•ã€è‡ªå®šä¹‰ç±»å‹å’Œæ’ä»¶ç³»ç»Ÿ
---

# 8ã€GORMç²¾é€šï¼šé«˜çº§ç‰¹æ€§

æœ¬æ–‡æ¡£æ·±å…¥è®²è§£GORMçš„é«˜çº§ç‰¹æ€§ï¼ŒåŒ…æ‹¬è¿æ¥æ± é…ç½®ã€ä¸Šä¸‹æ–‡æ”¯æŒã€è°ƒè¯•æŠ€å·§ã€è‡ªå®šä¹‰ç±»å‹å’Œæ’ä»¶å¼€å‘ã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡æ•°æ®åº“è¿æ¥æ± çš„é…ç½®å’Œä¼˜åŒ–
- âœ… å­¦ä¼šä½¿ç”¨Contextè¿›è¡Œè¶…æ—¶å’Œå–æ¶ˆæ§åˆ¶
- âœ… æŒæ¡è°ƒè¯•å’Œæ—¥å¿—é…ç½®æŠ€å·§
- âœ… ç†è§£è‡ªå®šä¹‰ç±»å‹å’Œåºåˆ—åŒ–
- âœ… å­¦ä¼šå¼€å‘GORMæ’ä»¶
- âœ… æŒæ¡æ€§èƒ½ä¼˜åŒ–æŠ€å·§

---

## å‰ç½®çŸ¥è¯†

- **ç¬¬1-7è¯¾**ï¼šæŒæ¡GORMçš„æ‰€æœ‰åŸºç¡€åŠŸèƒ½

---

## ä¸€ã€è¿æ¥æ± é…ç½®

### 1.1 è¿æ¥æ± å‚æ•°

```go
package main

import (
    "time"
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

func main() {
    dsn := "user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        panic(err)
    }

    // è·å–åº•å±‚çš„sql.DBå¯¹è±¡
    sqlDB, err := db.DB()
    if err != nil {
        panic(err)
    }

    // è®¾ç½®è¿æ¥æ± å‚æ•°
    sqlDB.SetMaxIdleConns(10)                  // æœ€å¤§ç©ºé—²è¿æ¥æ•°
    sqlDB.SetMaxOpenConns(100)                 // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    sqlDB.SetConnMaxLifetime(time.Hour)        // è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´
    sqlDB.SetConnMaxIdleTime(10 * time.Minute) // è¿æ¥æœ€å¤§ç©ºé—²æ—¶é—´
}
```

### 1.2 è¿æ¥æ± å‚æ•°è¯´æ˜

| å‚æ•° | è¯´æ˜ | æ¨èå€¼ |
|------|------|--------|
| `MaxIdleConns` | æœ€å¤§ç©ºé—²è¿æ¥æ•° | 10-20 |
| `MaxOpenConns` | æœ€å¤§æ‰“å¼€è¿æ¥æ•° | 100-200 |
| `ConnMaxLifetime` | è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´ | 1å°æ—¶ |
| `ConnMaxIdleTime` | è¿æ¥æœ€å¤§ç©ºé—²æ—¶é—´ | 10åˆ†é’Ÿ |

### 1.3 è¿æ¥æ± ç›‘æ§

```go
import (
    "time"
    "database/sql"
)

func MonitorConnectionPool(db *gorm.DB) {
    sqlDB, _ := db.DB()

    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for range ticker.C {
        stats := sqlDB.Stats()
        fmt.Printf("æ‰“å¼€è¿æ¥: %d, ä½¿ç”¨ä¸­: %d, ç©ºé—²: %d, ç­‰å¾…: %d\n",
            stats.OpenConnections,
            stats.InUse,
            stats.Idle,
            stats.WaitCount,
        )
    }
}
```

---

## äºŒã€ä¸Šä¸‹æ–‡ï¼ˆContextï¼‰æ”¯æŒ

### 2.1 ä½¿ç”¨Context

GORMæ”¯æŒContextï¼Œå¯ä»¥ç”¨äºè¶…æ—¶æ§åˆ¶å’Œå–æ¶ˆæ“ä½œï¼š

```go
package main

import (
    "context"
    "time"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

func main() {
    db, _ := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})

    // åˆ›å»ºå¸¦è¶…æ—¶çš„Context
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // ä½¿ç”¨Contextæ‰§è¡ŒæŸ¥è¯¢
    var user User
    db.WithContext(ctx).First(&user, 1)

    // å¦‚æœè¶…æ—¶ï¼Œä¼šè¿”å›context.DeadlineExceededé”™è¯¯
    if ctx.Err() == context.DeadlineExceeded {
        fmt.Println("æŸ¥è¯¢è¶…æ—¶")
    }
}
```

### 2.2 è¶…æ—¶æ§åˆ¶

```go
func QueryWithTimeout(db *gorm.DB, timeout time.Duration) (*User, error) {
    ctx, cancel := context.WithTimeout(context.Background(), timeout)
    defer cancel()

    var user User
    result := db.WithContext(ctx).First(&user, 1)

    if result.Error != nil {
        if ctx.Err() == context.DeadlineExceeded {
            return nil, fmt.Errorf("æŸ¥è¯¢è¶…æ—¶")
        }
        return nil, result.Error
    }

    return &user, nil
}
```

### 2.3 å–æ¶ˆæ“ä½œ

```go
func CancelableQuery(db *gorm.DB) {
    ctx, cancel := context.WithCancel(context.Background())

    // åœ¨goroutineä¸­æ‰§è¡ŒæŸ¥è¯¢
    go func() {
        var users []User
        db.WithContext(ctx).Find(&users)
    }()

    // 3ç§’åå–æ¶ˆ
    time.Sleep(3 * time.Second)
    cancel()
}
```

### 2.4 ä¼ é€’å€¼

```go
// åœ¨Contextä¸­ä¼ é€’å€¼
type userIDKey struct{}

func SetUserID(ctx context.Context, userID uint) context.Context {
    return context.WithValue(ctx, userIDKey{}, userID)
}

func GetUserID(ctx context.Context) (uint, bool) {
    userID, ok := ctx.Value(userIDKey{}).(uint)
    return userID, ok
}

// åœ¨é’©å­ä¸­ä½¿ç”¨
func (u *User) BeforeCreate(tx *gorm.DB) error {
    if userID, ok := GetUserID(tx.Statement.Context); ok {
        u.CreatedBy = userID
    }
    return nil
}
```

---

## ä¸‰ã€è°ƒè¯•å’Œæ—¥å¿—

### 3.1 æ—¥å¿—çº§åˆ«

```go
import "gorm.io/gorm/logger"

db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
    Logger: logger.Default.LogMode(logger.Info),  // æ˜¾ç¤ºæ‰€æœ‰SQL
    // Logger: logger.Default.LogMode(logger.Warn),  // åªæ˜¾ç¤ºè­¦å‘Šå’Œé”™è¯¯
    // Logger: logger.Default.LogMode(logger.Error), // åªæ˜¾ç¤ºé”™è¯¯
    // Logger: logger.Default.LogMode(logger.Silent), // ä¸æ˜¾ç¤ºæ—¥å¿—
})
```

### 3.2 è‡ªå®šä¹‰æ—¥å¿—

```go
import (
    "log"
    "os"
    "time"
    "gorm.io/gorm/logger"
)

newLogger := logger.New(
    log.New(os.Stdout, "\r\n", log.LstdFlags),
    logger.Config{
        SlowThreshold:             time.Second,   // æ…¢SQLé˜ˆå€¼
        LogLevel:                  logger.Info,   // æ—¥å¿—çº§åˆ«
        IgnoreRecordNotFoundError: true,         // å¿½ç•¥ErrRecordNotFoundé”™è¯¯
        Colorful:                  false,        // ç¦ç”¨å½©è‰²æ‰“å°
    },
)

db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
    Logger: newLogger,
})
```

### 3.3 æ…¢æŸ¥è¯¢æ—¥å¿—

```go
newLogger := logger.New(
    log.New(os.Stdout, "\r\n", log.LstdFlags),
    logger.Config{
        SlowThreshold: 200 * time.Millisecond,  // è¶…è¿‡200msçš„æŸ¥è¯¢è®°å½•ä¸ºæ…¢æŸ¥è¯¢
        LogLevel:      logger.Warn,
    },
)
```

### 3.4 è°ƒè¯•æ¨¡å¼

```go
// å¼€å‘ç¯å¢ƒï¼šæ˜¾ç¤ºè¯¦ç»†æ—¥å¿—
db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
    Logger: logger.Default.LogMode(logger.Info),
})

// ç”Ÿäº§ç¯å¢ƒï¼šåªæ˜¾ç¤ºé”™è¯¯
db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
    Logger: logger.Default.LogMode(logger.Error),
})
```

---

## å››ã€è‡ªå®šä¹‰ç±»å‹

### 4.1 å®ç°Valuerå’ŒScanneræ¥å£

```go
package main

import (
    "database/sql/driver"
    "encoding/json"
    "errors"
    "gorm.io/gorm"
)

// JSONç±»å‹
type JSON json.RawMessage

// Value å®ç°driver.Valueræ¥å£
func (j JSON) Value() (driver.Value, error) {
    if len(j) == 0 {
        return nil, nil
    }
    return json.RawMessage(j).MarshalJSON()
}

// Scan å®ç°sql.Scanneræ¥å£
func (j *JSON) Scan(value interface{}) error {
    if value == nil {
        *j = nil
        return nil
    }
    bytes, ok := value.([]byte)
    if !ok {
        return errors.New("æ— æ³•æ‰«æJSONç±»å‹")
    }
    return json.Unmarshal(bytes, j)
}

// User ç”¨æˆ·æ¨¡å‹
type User struct {
    ID      uint   `gorm:"primaryKey"`
    Name    string
    Profile JSON   `gorm:"type:json"`
}

func main() {
    db, _ := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
    db.AutoMigrate(&User{})

    // ä½¿ç”¨è‡ªå®šä¹‰JSONç±»å‹
    profile := JSON(`{"age": 25, "city": "åŒ—äº¬"}`)
    user := User{
        Name:    "å¼ ä¸‰",
        Profile: profile,
    }
    db.Create(&user)

    // æŸ¥è¯¢
    var foundUser User
    db.First(&foundUser, user.ID)
    fmt.Printf("Profile: %s\n", string(foundUser.Profile))
}
```

### 4.2 è‡ªå®šä¹‰æ—¶é—´ç±»å‹

```go
import "time"

// Date æ—¥æœŸç±»å‹ï¼ˆåªåŒ…å«æ—¥æœŸï¼Œä¸åŒ…å«æ—¶é—´ï¼‰
type Date struct {
    time.Time
}

func (d Date) Value() (driver.Value, error) {
    return d.Time.Format("2006-01-02"), nil
}

func (d *Date) Scan(value interface{}) error {
    if value == nil {
        d.Time = time.Time{}
        return nil
    }

    str, ok := value.(string)
    if !ok {
        return errors.New("æ— æ³•æ‰«æDateç±»å‹")
    }

    t, err := time.Parse("2006-01-02", str)
    if err != nil {
        return err
    }

    d.Time = t
    return nil
}

type User struct {
    ID        uint   `gorm:"primaryKey"`
    Name      string
    BirthDate Date   `gorm:"type:date"`
}
```

---

## äº”ã€æ’ä»¶ç³»ç»Ÿ

### 5.1 åˆ›å»ºæ’ä»¶

```go
import "gorm.io/gorm"

// MyPlugin è‡ªå®šä¹‰æ’ä»¶
type MyPlugin struct{}

func (p *MyPlugin) Name() string {
    return "my-plugin"
}

func (p *MyPlugin) Initialize(db *gorm.DB) error {
    // æ³¨å†Œå›è°ƒ
    db.Callback().Create().Before("gorm:create").Register("my-plugin:before_create", p.beforeCreate)
    db.Callback().Create().After("gorm:create").Register("my-plugin:after_create", p.afterCreate)
    return nil
}

func (p *MyPlugin) beforeCreate(db *gorm.DB) {
    // åˆ›å»ºå‰çš„é€»è¾‘
    fmt.Println("æ’ä»¶ï¼šåˆ›å»ºå‰")
}

func (p *MyPlugin) afterCreate(db *gorm.DB) {
    // åˆ›å»ºåçš„é€»è¾‘
    fmt.Println("æ’ä»¶ï¼šåˆ›å»ºå")
}

// ä½¿ç”¨æ’ä»¶
db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
    Plugins: map[string]gorm.Plugin{
        "my-plugin": &MyPlugin{},
    },
})
```

### 5.2 å®¡è®¡æ’ä»¶ç¤ºä¾‹

```go
type AuditPlugin struct{}

func (p *AuditPlugin) Name() string {
    return "audit"
}

func (p *AuditPlugin) Initialize(db *gorm.DB) error {
    db.Callback().Create().Before("gorm:create").Register("audit:before_create", p.beforeCreate)
    db.Callback().Update().Before("gorm:update").Register("audit:before_update", p.beforeUpdate)
    db.Callback().Delete().Before("gorm:delete").Register("audit:before_delete", p.beforeDelete)
    return nil
}

func (p *AuditPlugin) beforeCreate(db *gorm.DB) {
    if userID, ok := db.Statement.Context.Value("user_id").(uint); ok {
        if db.Statement.Schema != nil {
            if field := db.Statement.Schema.LookUpField("CreatedBy"); field != nil {
                db.Statement.SetColumn("CreatedBy", userID)
            }
        }
    }
}

func (p *AuditPlugin) beforeUpdate(db *gorm.DB) {
    if userID, ok := db.Statement.Context.Value("user_id").(uint); ok {
        if db.Statement.Schema != nil {
            if field := db.Statement.Schema.LookUpField("UpdatedBy"); field != nil {
                db.Statement.SetColumn("UpdatedBy", userID)
            }
        }
    }
}

func (p *AuditPlugin) beforeDelete(db *gorm.DB) {
    // è®°å½•åˆ é™¤æ“ä½œ
    log.Printf("åˆ é™¤æ“ä½œ: %s", db.Statement.Table)
}
```

---

## å…­ã€æ€§èƒ½ä¼˜åŒ–

### 6.1 æ‰¹é‡æ“ä½œ

```go
// æ‰¹é‡åˆ›å»º
users := make([]User, 1000)
for i := 0; i < 1000; i++ {
    users[i] = User{Name: fmt.Sprintf("ç”¨æˆ·%d", i)}
}

// åˆ†æ‰¹åˆ›å»ºï¼ˆæ¯æ‰¹100æ¡ï¼‰
db.CreateInBatches(users, 100)

// æ‰¹é‡æ›´æ–°
db.Model(&User{}).Where("age < ?", 18).Update("status", "minor")
```

### 6.2 ç´¢å¼•ä¼˜åŒ–

```go
type User struct {
    ID    uint   `gorm:"primaryKey"`
    Email string `gorm:"uniqueIndex"`  // å”¯ä¸€ç´¢å¼•
    Age   int    `gorm:"index"`         // æ™®é€šç´¢å¼•
    Name  string `gorm:"index:idx_name"` // å‘½åç´¢å¼•
}

// å¤åˆç´¢å¼•
db.Model(&User{}).AddIndex("idx_age_name", "age", "name")
```

### 6.3 æŸ¥è¯¢ä¼˜åŒ–

```go
// åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
db.Select("id", "name", "email").Find(&users)

// ä½¿ç”¨é¢„åŠ è½½é¿å…N+1æŸ¥è¯¢
db.Preload("Orders").Find(&users)

// ä½¿ç”¨Limité¿å…æŸ¥è¯¢å¤§é‡æ•°æ®
db.Limit(100).Find(&users)
```

### 6.4 è¿æ¥æ± ä¼˜åŒ–

```go
sqlDB, _ := db.DB()

// æ ¹æ®åº”ç”¨è´Ÿè½½è°ƒæ•´è¿æ¥æ± 
sqlDB.SetMaxIdleConns(20)                  // å¢åŠ ç©ºé—²è¿æ¥
sqlDB.SetMaxOpenConns(200)                 // å¢åŠ æœ€å¤§è¿æ¥æ•°
sqlDB.SetConnMaxLifetime(time.Hour)        // è®¾ç½®è¿æ¥ç”Ÿå­˜æ—¶é—´
sqlDB.SetConnMaxIdleTime(10 * time.Minute) // è®¾ç½®ç©ºé—²æ—¶é—´
```

---

## ä¸ƒã€è°ƒè¯•æŠ€å·§

### 7.1 æŸ¥çœ‹ç”Ÿæˆçš„SQL

```go
// ä½¿ç”¨DryRunæŸ¥çœ‹SQLä½†ä¸æ‰§è¡Œ
stmt := db.Session(&gorm.Session{DryRun: true}).First(&user, 1).Statement
fmt.Println(stmt.SQL.String())  // è¾“å‡ºSQLè¯­å¥
fmt.Println(stmt.Vars)          // è¾“å‡ºå‚æ•°
```

### 7.2 æ€§èƒ½åˆ†æ

```go
import "time"

func ProfileQuery(db *gorm.DB) {
    start := time.Now()
    
    var users []User
    db.Find(&users)
    
    elapsed := time.Since(start)
    fmt.Printf("æŸ¥è¯¢è€—æ—¶: %v\n", elapsed)
    fmt.Printf("æŸ¥è¯¢è®°å½•æ•°: %d\n", len(users))
}
```

### 7.3 è°ƒè¯•æ¨¡å¼

```go
// å¯ç”¨è°ƒè¯•æ¨¡å¼
db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
    Logger: logger.Default.LogMode(logger.Info),
})

// å•æ¬¡æŸ¥è¯¢å¯ç”¨è°ƒè¯•
db.Debug().First(&user, 1)
```

---

## å…«ã€å®Œæ•´ç¤ºä¾‹

### 8.1 ç”Ÿäº§ç¯å¢ƒé…ç½®

```go
package main

import (
    "context"
    "log"
    "os"
    "time"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

func NewDB(dsn string) (*gorm.DB, error) {
    // è‡ªå®šä¹‰æ—¥å¿—
    newLogger := logger.New(
        log.New(os.Stdout, "\r\n", log.LstdFlags),
        logger.Config{
            SlowThreshold:             200 * time.Millisecond,
            LogLevel:                  logger.Warn,  // ç”Ÿäº§ç¯å¢ƒåªè®°å½•è­¦å‘Šå’Œé”™è¯¯
            IgnoreRecordNotFoundError: true,
            Colorful:                  false,
        },
    )

    // æ‰“å¼€æ•°æ®åº“è¿æ¥
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger:      newLogger,
        PrepareStmt: true,  // å¯ç”¨é¢„ç¼–è¯‘è¯­å¥
    })
    if err != nil {
        return nil, err
    }

    // é…ç½®è¿æ¥æ± 
    sqlDB, err := db.DB()
    if err != nil {
        return nil, err
    }

    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetMaxOpenConns(100)
    sqlDB.SetConnMaxLifetime(time.Hour)
    sqlDB.SetConnMaxIdleTime(10 * time.Minute)

    return db, nil
}

func main() {
    dsn := "user:password@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
    
    db, err := NewDB(dsn)
    if err != nil {
        log.Fatal(err)
    }

    // ä½¿ç”¨Context
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    var user User
    db.WithContext(ctx).First(&user, 1)
}
```

---

## æ€»ç»“

### é«˜çº§ç‰¹æ€§è¦ç‚¹

1. **è¿æ¥æ± é…ç½®**ï¼š
   - åˆç†è®¾ç½®è¿æ¥æ± å‚æ•°
   - ç›‘æ§è¿æ¥æ± çŠ¶æ€
   - æ ¹æ®è´Ÿè½½è°ƒæ•´å‚æ•°

2. **Contextæ”¯æŒ**ï¼š
   - ä½¿ç”¨Contextæ§åˆ¶è¶…æ—¶
   - æ”¯æŒå–æ¶ˆæ“ä½œ
   - ä¼ é€’ä¸Šä¸‹æ–‡å€¼

3. **è°ƒè¯•å’Œæ—¥å¿—**ï¼š
   - é…ç½®é€‚å½“çš„æ—¥å¿—çº§åˆ«
   - ç›‘æ§æ…¢æŸ¥è¯¢
   - ä½¿ç”¨DryRunè°ƒè¯•SQL

4. **è‡ªå®šä¹‰ç±»å‹**ï¼š
   - å®ç°Valuerå’ŒScanneræ¥å£
   - æ”¯æŒå¤æ‚æ•°æ®ç±»å‹
   - å¤„ç†åºåˆ—åŒ–å’Œååºåˆ—åŒ–

5. **æ’ä»¶ç³»ç»Ÿ**ï¼š
   - åˆ›å»ºè‡ªå®šä¹‰æ’ä»¶
   - æ³¨å†Œå›è°ƒå‡½æ•°
   - æ‰©å±•GORMåŠŸèƒ½

### æ€§èƒ½ä¼˜åŒ–

1. **æ‰¹é‡æ“ä½œ**ï¼šä½¿ç”¨æ‰¹é‡æ“ä½œå‡å°‘æ•°æ®åº“äº¤äº’
2. **ç´¢å¼•ä¼˜åŒ–**ï¼šä¸ºå¸¸ç”¨æŸ¥è¯¢å­—æ®µæ·»åŠ ç´¢å¼•
3. **æŸ¥è¯¢ä¼˜åŒ–**ï¼šåªæŸ¥è¯¢éœ€è¦çš„å­—æ®µï¼Œä½¿ç”¨é¢„åŠ è½½
4. **è¿æ¥æ± **ï¼šåˆç†é…ç½®è¿æ¥æ± å‚æ•°

æŒæ¡è¿™äº›é«˜çº§ç‰¹æ€§åï¼Œä½ å°†èƒ½å¤Ÿæ„å»ºé«˜æ€§èƒ½ã€å¯ç»´æŠ¤çš„GORMåº”ç”¨ã€‚åœ¨ä¸‹ä¸€è¯¾ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ é¡¹ç›®ç»“æ„å’Œæœ€ä½³å®è·µã€‚