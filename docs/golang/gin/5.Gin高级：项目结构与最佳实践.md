---
title: 5ã€Giné«˜çº§ï¼šé¡¹ç›®ç»“æ„ä¸æœ€ä½³å®è·µ
date: 2026-01-06
description: Ginæ¡†æ¶é¡¹ç›®ç»„ç»‡ã€é”™è¯¯å¤„ç†ã€æµ‹è¯•å’Œéƒ¨ç½²çš„æœ€ä½³å®è·µ
---

# 5ã€Giné«˜çº§ï¼šé¡¹ç›®ç»“æ„ä¸æœ€ä½³å®è·µ

æœ¬æ–‡æ¡£æ·±å…¥è®²è§£å¦‚ä½•ç»„ç»‡å¤§å‹Giné¡¹ç›®ï¼Œä»¥åŠé”™è¯¯å¤„ç†ã€æµ‹è¯•å’Œéƒ¨ç½²çš„æœ€ä½³å®è·µã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… å­¦ä¼šç»„ç»‡å¤§å‹Giné¡¹ç›®çš„ç›®å½•ç»“æ„
- âœ… æŒæ¡GORMæ•°æ®åº“é›†æˆ
- âœ… æŒæ¡æ§åˆ¶å™¨ï¼ˆControllerï¼‰æ¨¡å¼
- âœ… ç†è§£æœåŠ¡å±‚ï¼ˆServiceï¼‰è®¾è®¡
- âœ… å®ç°ç»Ÿä¸€çš„é”™è¯¯å¤„ç†
- âœ… å­¦ä¼šç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- âœ… äº†è§£æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- âœ… æŒæ¡éƒ¨ç½²å®è·µ

---

## ä¸€ã€é¡¹ç›®ç›®å½•ç»“æ„

### 1.1 æ ‡å‡†é¡¹ç›®ç»“æ„

```
my-gin-project/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go          # åº”ç”¨å…¥å£
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ config/              # é…ç½®ç®¡ç†
â”‚   â”‚   â””â”€â”€ config.go
â”‚   â”œâ”€â”€ controller/          # æ§åˆ¶å™¨å±‚
â”‚   â”‚   â”œâ”€â”€ user_controller.go
â”‚   â”‚   â””â”€â”€ auth_controller.go
â”‚   â”œâ”€â”€ service/             # ä¸šåŠ¡é€»è¾‘å±‚
â”‚   â”‚   â”œâ”€â”€ user_service.go
â”‚   â”‚   â””â”€â”€ auth_service.go
â”‚   â”œâ”€â”€ repository/          # æ•°æ®è®¿é—®å±‚
â”‚   â”‚   â”œâ”€â”€ user_repository.go
â”‚   â”‚   â””â”€â”€ database.go
â”‚   â”œâ”€â”€ model/               # æ•°æ®æ¨¡å‹
â”‚   â”‚   â””â”€â”€ user.go
â”‚   â”œâ”€â”€ middleware/          # ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ auth.go
â”‚   â”‚   â””â”€â”€ logger.go
â”‚   â”œâ”€â”€ router/              # è·¯ç”±é…ç½®
â”‚   â”‚   â””â”€â”€ router.go
â”‚   â””â”€â”€ utils/               # å·¥å…·å‡½æ•°
â”‚       â”œâ”€â”€ response.go
â”‚       â””â”€â”€ validator.go
â”œâ”€â”€ pkg/                     # å¯å¤ç”¨çš„åŒ…
â”‚   â””â”€â”€ logger/
â”œâ”€â”€ api/                     # APIæ–‡æ¡£
â”‚   â””â”€â”€ swagger.yaml
â”œâ”€â”€ configs/                 # é…ç½®æ–‡ä»¶
â”‚   â””â”€â”€ config.yaml
â”œâ”€â”€ tests/                   # æµ‹è¯•æ–‡ä»¶
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ unit/
â”œâ”€â”€ scripts/                 # è„šæœ¬æ–‡ä»¶
â”‚   â””â”€â”€ build.sh
â”œâ”€â”€ go.mod
â”œâ”€â”€ go.sum
â””â”€â”€ README.md
```

### 1.2 ç›®å½•è¯´æ˜

- **cmd/**: åº”ç”¨å…¥å£ç‚¹
- **internal/**: ç§æœ‰åº”ç”¨ä»£ç ï¼Œå¤–éƒ¨æ— æ³•å¯¼å…¥
- **pkg/**: å¯è¢«å¤–éƒ¨åº”ç”¨ä½¿ç”¨çš„åº“ä»£ç 
- **api/**: APIå®šä¹‰å’Œæ–‡æ¡£
- **configs/**: é…ç½®æ–‡ä»¶
- **tests/**: æµ‹è¯•ä»£ç 

---

## äºŒã€é…ç½®ç®¡ç†

### 2.1 é…ç½®æ–‡ä»¶ç»“æ„

**configs/config.yaml**:

```yaml
server:
  port: 8080
  mode: release  # debug, release, test

database:
  host: localhost
  port: 5432
  user: postgres
  password: password
  dbname: mydb

redis:
  host: localhost
  port: 6379
  password: ""

jwt:
  secret: your-secret-key
  expire: 24h
```

### 2.2 é…ç½®åŠ è½½

**internal/config/config.go**:

```go
package config

import (
    "fmt"
    "os"
    "gopkg.in/yaml.v3"
)

type Config struct {
    Server   ServerConfig   `yaml:"server"`
    Database DatabaseConfig `yaml:"database"`
    Redis    RedisConfig    `yaml:"redis"`
    JWT      JWTConfig      `yaml:"jwt"`
}

type ServerConfig struct {
    Port int    `yaml:"port"`
    Mode string `yaml:"mode"`
}

type DatabaseConfig struct {
    Host     string `yaml:"host"`
    Port     int    `yaml:"port"`
    User     string `yaml:"user"`
    Password string `yaml:"password"`
    DBName   string `yaml:"dbname"`
}

type RedisConfig struct {
    Host     string `yaml:"host"`
    Port     int    `yaml:"port"`
    Password string `yaml:"password"`
}

type JWTConfig struct {
    Secret string `yaml:"secret"`
    Expire string `yaml:"expire"`
}

var AppConfig *Config

func LoadConfig(path string) error {
    data, err := os.ReadFile(path)
    if err != nil {
        return fmt.Errorf("failed to read config file: %w", err)
    }
    
    AppConfig = &Config{}
    if err := yaml.Unmarshal(data, AppConfig); err != nil {
        return fmt.Errorf("failed to parse config: %w", err)
    }
    
    // ä»ç¯å¢ƒå˜é‡è¦†ç›–é…ç½®
    if port := os.Getenv("SERVER_PORT"); port != "" {
        // è§£æç«¯å£...
    }
    
    return nil
}
```

---

## ä¸‰ã€GORMæ•°æ®åº“é›†æˆ

### 3.1 å®‰è£…GORM

GORMæ˜¯Goè¯­è¨€æœ€æµè¡Œçš„ORMåº“ï¼Œæ”¯æŒå¤šç§æ•°æ®åº“ï¼š

```bash
# å®‰è£…GORMæ ¸å¿ƒåŒ…
go get -u gorm.io/gorm

# å®‰è£…æ•°æ®åº“é©±åŠ¨ï¼ˆä»¥PostgreSQLä¸ºä¾‹ï¼‰
go get -u gorm.io/driver/postgres

# æˆ–è€…MySQL
go get -u gorm.io/driver/mysql

# æˆ–è€…SQLite
go get -u gorm.io/driver/sqlite
```

### 3.2 æ•°æ®åº“è¿æ¥

**internal/repository/database.go**:

```go
package repository

import (
    "fmt"
    "log"
    "time"
    
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
    "my-gin-project/internal/config"
)

var DB *gorm.DB

// InitDB åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
func InitDB() error {
    cfg := config.AppConfig.Database
    
    // æ„å»ºDSNï¼ˆæ•°æ®æºåç§°ï¼‰
    dsn := fmt.Sprintf(
        "host=%s user=%s password=%s dbname=%s port=%d sslmode=disable TimeZone=Asia/Shanghai",
        cfg.Host, cfg.User, cfg.Password, cfg.DBName, cfg.Port,
    )
    
    var err error
    DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    
    if err != nil {
        return fmt.Errorf("failed to connect database: %w", err)
    }
    
    // è·å–åº•å±‚çš„sql.DBä»¥è®¾ç½®è¿æ¥æ± 
    sqlDB, err := DB.DB()
    if err != nil {
        return fmt.Errorf("failed to get database instance: %w", err)
    }
    
    // è®¾ç½®è¿æ¥æ± å‚æ•°
    sqlDB.SetMaxOpenConns(100)                 // æœ€å¤§æ‰“å¼€è¿æ¥æ•°
    sqlDB.SetMaxIdleConns(10)                  // æœ€å¤§ç©ºé—²è¿æ¥æ•°
    sqlDB.SetConnMaxLifetime(time.Hour)        // è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´
    
    // æµ‹è¯•è¿æ¥
    if err := sqlDB.Ping(); err != nil {
        return fmt.Errorf("failed to ping database: %w", err)
    }
    
    log.Println("Database connected successfully")
    return nil
}

// CloseDB å…³é—­æ•°æ®åº“è¿æ¥
func CloseDB() error {
    if DB != nil {
        sqlDB, err := DB.DB()
        if err != nil {
            return err
        }
        return sqlDB.Close()
    }
    return nil
}
```

### 3.3 å®šä¹‰æ¨¡å‹

**internal/model/user.go**:

```go
package model

import (
    "time"
    "gorm.io/gorm"
)

type User struct {
    ID        uint           `gorm:"primarykey" json:"id"`
    CreatedAt time.Time      `json:"created_at"`
    UpdatedAt time.Time      `json:"updated_at"`
    DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
    
    Name     string `gorm:"type:varchar(100);not null" json:"name"`
    Email    string `gorm:"type:varchar(100);uniqueIndex;not null" json:"email"`
    Password string `gorm:"type:varchar(255);not null" json:"-"`
    Age      int    `gorm:"type:int" json:"age"`
    Status   string `gorm:"type:varchar(20);default:'active'" json:"status"`
}

// TableName æŒ‡å®šè¡¨å
func (User) TableName() string {
    return "users"
}

// BeforeCreate åˆ›å»ºå‰çš„é’©å­
func (u *User) BeforeCreate(tx *gorm.DB) error {
    // å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œæ•°æ®éªŒè¯æˆ–å¤„ç†
    if u.Status == "" {
        u.Status = "active"
    }
    return nil
}
```

### 3.4 Repositoryå±‚å®ç°

**internal/repository/user_repository.go**:

```go
package repository

import (
    "errors"
    "my-gin-project/internal/model"
    "gorm.io/gorm"
)

type UserRepository struct {
    db *gorm.DB
}

func NewUserRepository() *UserRepository {
    return &UserRepository{
        db: DB,
    }
}

// Create åˆ›å»ºç”¨æˆ·
func (r *UserRepository) Create(user *model.User) (*model.User, error) {
    if err := r.db.Create(user).Error; err != nil {
        return nil, err
    }
    return user, nil
}

// FindByID æ ¹æ®IDæŸ¥æ‰¾ç”¨æˆ·
func (r *UserRepository) FindByID(id uint) (*model.User, error) {
    var user model.User
    if err := r.db.First(&user, id).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("user not found")
        }
        return nil, err
    }
    return &user, nil
}

// FindByEmail æ ¹æ®é‚®ç®±æŸ¥æ‰¾ç”¨æˆ·
func (r *UserRepository) FindByEmail(email string) (*model.User, error) {
    var user model.User
    if err := r.db.Where("email = ?", email).First(&user).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, nil // è¿”å›nilè¡¨ç¤ºæœªæ‰¾åˆ°ï¼Œä½†ä¸æŠ¥é”™
        }
        return nil, err
    }
    return &user, nil
}

// Update æ›´æ–°ç”¨æˆ·
func (r *UserRepository) Update(user *model.User) (*model.User, error) {
    if err := r.db.Save(user).Error; err != nil {
        return nil, err
    }
    return user, nil
}

// Delete åˆ é™¤ç”¨æˆ·ï¼ˆè½¯åˆ é™¤ï¼‰
func (r *UserRepository) Delete(id uint) error {
    if err := r.db.Delete(&model.User{}, id).Error; err != nil {
        return err
    }
    return nil
}

// List è·å–ç”¨æˆ·åˆ—è¡¨ï¼ˆåˆ†é¡µï¼‰
func (r *UserRepository) List(page, limit int) ([]*model.User, int64, error) {
    var users []*model.User
    var total int64
    
    // è·å–æ€»æ•°
    if err := r.db.Model(&model.User{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // åˆ†é¡µæŸ¥è¯¢
    offset := (page - 1) * limit
    if err := r.db.Offset(offset).Limit(limit).Find(&users).Error; err != nil {
        return nil, 0, err
    }
    
    return users, total, nil
}

// FindByConditions æ ¹æ®æ¡ä»¶æŸ¥è¯¢
func (r *UserRepository) FindByConditions(conditions map[string]interface{}) ([]*model.User, error) {
    var users []*model.User
    query := r.db.Model(&model.User{})
    
    // åŠ¨æ€æ„å»ºæŸ¥è¯¢æ¡ä»¶
    if name, ok := conditions["name"]; ok {
        query = query.Where("name LIKE ?", "%"+name.(string)+"%")
    }
    if status, ok := conditions["status"]; ok {
        query = query.Where("status = ?", status)
    }
    if ageMin, ok := conditions["age_min"]; ok {
        query = query.Where("age >= ?", ageMin)
    }
    if ageMax, ok := conditions["age_max"]; ok {
        query = query.Where("age <= ?", ageMax)
    }
    
    if err := query.Find(&users).Error; err != nil {
        return nil, err
    }
    
    return users, nil
}
```

### 3.5 æ•°æ®åº“è¿ç§»

**internal/repository/migrate.go**:

```go
package repository

import (
    "log"
    "my-gin-project/internal/model"
)

// AutoMigrate è‡ªåŠ¨è¿ç§»æ•°æ®åº“è¡¨ç»“æ„
func AutoMigrate() error {
    err := DB.AutoMigrate(
        &model.User{},
        // æ·»åŠ å…¶ä»–æ¨¡å‹...
    )
    
    if err != nil {
        return err
    }
    
    log.Println("Database migration completed")
    return nil
}
```

### 3.6 äº‹åŠ¡å¤„ç†

```go
// åœ¨Repositoryä¸­ä½¿ç”¨äº‹åŠ¡
func (r *UserRepository) CreateWithTransaction(user *model.User) error {
    return r.db.Transaction(func(tx *gorm.DB) error {
        // åˆ›å»ºç”¨æˆ·
        if err := tx.Create(user).Error; err != nil {
            return err
        }
        
        // åˆ›å»ºç”¨æˆ·é…ç½®ï¼ˆç¤ºä¾‹ï¼‰
        // config := &model.UserConfig{UserID: user.ID}
        // if err := tx.Create(config).Error; err != nil {
        //     return err
        // }
        
        return nil
    })
}
```

### 3.7 å…³è”æŸ¥è¯¢

**å®šä¹‰å…³è”æ¨¡å‹**:

```go
// internal/model/user.go
type User struct {
    // ... å…¶ä»–å­—æ®µ
    Posts []Post `gorm:"foreignKey:UserID" json:"posts,omitempty"`
}

type Post struct {
    ID        uint      `gorm:"primarykey" json:"id"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    
    Title   string `json:"title"`
    Content string `json:"content"`
    UserID  uint   `json:"user_id"`
    User    User   `gorm:"foreignKey:UserID" json:"user,omitempty"`
}
```

**é¢„åŠ è½½å…³è”**:

```go
// é¢„åŠ è½½ç”¨æˆ·çš„æ–‡ç« 
func (r *UserRepository) FindByIDWithPosts(id uint) (*model.User, error) {
    var user model.User
    if err := r.db.Preload("Posts").First(&user, id).Error; err != nil {
        return nil, err
    }
    return &user, nil
}

// æ¡ä»¶é¢„åŠ è½½
func (r *UserRepository) FindByIDWithActivePosts(id uint) (*model.User, error) {
    var user model.User
    if err := r.db.Preload("Posts", "status = ?", "active").First(&user, id).Error; err != nil {
        return nil, err
    }
    return &user, nil
}
```

### 3.8 æŸ¥è¯¢ä¼˜åŒ–

```go
// ä½¿ç”¨SelectæŒ‡å®šå­—æ®µ
func (r *UserRepository) FindByIDSelect(id uint) (*model.User, error) {
    var user model.User
    if err := r.db.Select("id", "name", "email").First(&user, id).Error; err != nil {
        return nil, err
    }
    return &user, nil
}

// ä½¿ç”¨ç´¢å¼•æç¤º
func (r *UserRepository) FindByEmailOptimized(email string) (*model.User, error) {
    var user model.User
    if err := r.db.Where("email = ?", email).
        Set("gorm:query_option", "FOR UPDATE"). // è¡Œé”
        First(&user).Error; err != nil {
        return nil, err
    }
    return &user, nil
}

// æ‰¹é‡æ“ä½œ
func (r *UserRepository) BatchCreate(users []*model.User) error {
    return r.db.CreateInBatches(users, 100).Error
}
```

### 3.9 åŸç”ŸSQLæŸ¥è¯¢

```go
// æ‰§è¡ŒåŸç”ŸSQL
func (r *UserRepository) FindByRawSQL(query string, args ...interface{}) ([]*model.User, error) {
    var users []*model.User
    if err := r.db.Raw(query, args...).Scan(&users).Error; err != nil {
        return nil, err
    }
    return users, nil
}

// æ‰§è¡ŒåŸç”ŸSQLï¼ˆæ›´æ–°/åˆ é™¤ï¼‰
func (r *UserRepository) ExecuteRawSQL(sql string, args ...interface{}) error {
    return r.db.Exec(sql, args...).Error
}
```

### 3.10 åœ¨main.goä¸­åˆå§‹åŒ–

**cmd/server/main.go**:

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "my-gin-project/internal/config"
    "my-gin-project/internal/repository"
    "my-gin-project/internal/router"
)

func main() {
    // åŠ è½½é…ç½®
    if err := config.LoadConfig("configs/config.yaml"); err != nil {
        log.Fatal("Failed to load config:", err)
    }
    
    // åˆå§‹åŒ–æ•°æ®åº“
    if err := repository.InitDB(); err != nil {
        log.Fatal("Failed to initialize database:", err)
    }
    defer repository.CloseDB()
    
    // è‡ªåŠ¨è¿ç§»
    if err := repository.AutoMigrate(); err != nil {
        log.Fatal("Failed to migrate database:", err)
    }
    
    // è®¾ç½®è·¯ç”±
    r := router.SetupRouter()
    
    // åˆ›å»ºHTTPæœåŠ¡å™¨
    srv := &http.Server{
        Addr:    fmt.Sprintf(":%d", config.AppConfig.Server.Port),
        Handler: r,
    }
    
    // åœ¨goroutineä¸­å¯åŠ¨æœåŠ¡å™¨
    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server failed to start: %v", err)
        }
    }()
    
    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // ä¼˜é›…å…³é—­
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

---

## å››ã€æ§åˆ¶å™¨æ¨¡å¼

### 3.1 æ§åˆ¶å™¨ç»“æ„

**internal/controller/user_controller.go**:

```go
package controller

import (
    "github.com/gin-gonic/gin"
    "my-gin-project/internal/service"
    "my-gin-project/internal/utils"
    "net/http"
)

type UserController struct {
    userService *service.UserService
}

func NewUserController(userService *service.UserService) *UserController {
    return &UserController{
        userService: userService,
    }
}

// GetUser è·å–ç”¨æˆ·ä¿¡æ¯
func (uc *UserController) GetUser(c *gin.Context) {
    id := c.Param("id")
    
    user, err := uc.userService.GetUserByID(id)
    if err != nil {
        utils.ErrorResponse(c, http.StatusNotFound, err.Error())
        return
    }
    
    utils.SuccessResponse(c, http.StatusOK, user)
}

// CreateUser åˆ›å»ºç”¨æˆ·
func (uc *UserController) CreateUser(c *gin.Context) {
    var req struct {
        Name  string `json:"name" binding:"required"`
        Email string `json:"email" binding:"required,email"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        utils.ErrorResponse(c, http.StatusBadRequest, err.Error())
        return
    }
    
    user, err := uc.userService.CreateUser(req.Name, req.Email)
    if err != nil {
        utils.ErrorResponse(c, http.StatusInternalServerError, err.Error())
        return
    }
    
    utils.SuccessResponse(c, http.StatusCreated, user)
}

// UpdateUser æ›´æ–°ç”¨æˆ·
func (uc *UserController) UpdateUser(c *gin.Context) {
    id := c.Param("id")
    
    var req struct {
        Name  string `json:"name"`
        Email string `json:"email" binding:"omitempty,email"`
    }
    
    if err := c.ShouldBindJSON(&req); err != nil {
        utils.ErrorResponse(c, http.StatusBadRequest, err.Error())
        return
    }
    
    user, err := uc.userService.UpdateUser(id, req.Name, req.Email)
    if err != nil {
        utils.ErrorResponse(c, http.StatusInternalServerError, err.Error())
        return
    }
    
    utils.SuccessResponse(c, http.StatusOK, user)
}

// DeleteUser åˆ é™¤ç”¨æˆ·
func (uc *UserController) DeleteUser(c *gin.Context) {
    id := c.Param("id")
    
    if err := uc.userService.DeleteUser(id); err != nil {
        utils.ErrorResponse(c, http.StatusInternalServerError, err.Error())
        return
    }
    
    utils.SuccessResponse(c, http.StatusOK, gin.H{"message": "User deleted"})
}
```

---

## äº”ã€æœåŠ¡å±‚è®¾è®¡

### 4.1 æœåŠ¡æ¥å£

**internal/service/user_service.go**:

```go
package service

import (
    "errors"
    "my-gin-project/internal/model"
    "my-gin-project/internal/repository"
)

type UserService struct {
    userRepo *repository.UserRepository
}

func NewUserService(userRepo *repository.UserRepository) *UserService {
    return &UserService{
        userRepo: userRepo,
    }
}

func (s *UserService) GetUserByID(id string) (*model.User, error) {
    if id == "" {
        return nil, errors.New("user ID is required")
    }
    
    user, err := s.userRepo.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    return user, nil
}

func (s *UserService) CreateUser(name, email string) (*model.User, error) {
    // ä¸šåŠ¡é€»è¾‘éªŒè¯
    if name == "" {
        return nil, errors.New("name is required")
    }
    
    if email == "" {
        return nil, errors.New("email is required")
    }
    
    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    existing, _ := s.userRepo.FindByEmail(email)
    if existing != nil {
        return nil, errors.New("email already exists")
    }
    
    // åˆ›å»ºç”¨æˆ·
    user := &model.User{
        Name:  name,
        Email: email,
    }
    
    return s.userRepo.Create(user)
}

func (s *UserService) UpdateUser(id, name, email string) (*model.User, error) {
    user, err := s.userRepo.FindByID(id)
    if err != nil {
        return nil, err
    }
    
    if name != "" {
        user.Name = name
    }
    
    if email != "" {
        // æ£€æŸ¥é‚®ç®±æ˜¯å¦è¢«å…¶ä»–ç”¨æˆ·ä½¿ç”¨
        existing, _ := s.userRepo.FindByEmail(email)
        if existing != nil && existing.ID != id {
            return nil, errors.New("email already exists")
        }
        user.Email = email
    }
    
    return s.userRepo.Update(user)
}

func (s *UserService) DeleteUser(id string) error {
    user, err := s.userRepo.FindByID(id)
    if err != nil {
        return err
    }
    
    return s.userRepo.Delete(user.ID)
}
```

---

## å…­ã€ç»Ÿä¸€å“åº”æ ¼å¼

### 5.1 å“åº”å·¥å…·

**internal/utils/response.go**:

```go
package utils

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

type Response struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
}

func SuccessResponse(c *gin.Context, code int, data interface{}) {
    c.JSON(code, Response{
        Code:    code,
        Message: "success",
        Data:    data,
    })
}

func ErrorResponse(c *gin.Context, code int, message string) {
    c.JSON(code, Response{
        Code:    code,
        Message: "error",
        Error:   message,
    })
}

func PaginatedResponse(c *gin.Context, code int, data interface{}, total int, page, limit int) {
    c.JSON(code, Response{
        Code:    code,
        Message: "success",
        Data: gin.H{
            "items": data,
            "pagination": gin.H{
                "total": total,
                "page":  page,
                "limit": limit,
            },
        },
    })
}
```

---

## ä¸ƒã€ç»Ÿä¸€é”™è¯¯å¤„ç†

### 6.1 è‡ªå®šä¹‰é”™è¯¯ç±»å‹

**internal/utils/errors.go**:

```go
package utils

import "fmt"

type AppError struct {
    Code    int
    Message string
    Err     error
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

func NewError(code int, message string) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
    }
}

func WrapError(code int, message string, err error) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
        Err:     err,
    }
}

// é¢„å®šä¹‰é”™è¯¯
var (
    ErrNotFound     = NewError(404, "Resource not found")
    ErrUnauthorized = NewError(401, "Unauthorized")
    ErrForbidden    = NewError(403, "Forbidden")
    ErrBadRequest   = NewError(400, "Bad request")
    ErrInternal     = NewError(500, "Internal server error")
)
```

### 6.2 é”™è¯¯å¤„ç†ä¸­é—´ä»¶

**internal/middleware/error_handler.go**:

```go
package middleware

import (
    "github.com/gin-gonic/gin"
    "my-gin-project/internal/utils"
    "net/http"
)

func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()
        
        // æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
        if len(c.Errors) > 0 {
            err := c.Errors.Last()
            
            // å¤„ç†è‡ªå®šä¹‰é”™è¯¯
            if appErr, ok := err.Err.(*utils.AppError); ok {
                utils.ErrorResponse(c, appErr.Code, appErr.Message)
                return
            }
            
            // å¤„ç†å…¶ä»–é”™è¯¯
            utils.ErrorResponse(c, http.StatusInternalServerError, err.Error())
        }
    }
}
```

---

## å…«ã€è·¯ç”±ç»„ç»‡

### 7.1 è·¯ç”±é…ç½®

**internal/router/router.go**:

```go
package router

import (
    "github.com/gin-gonic/gin"
    "my-gin-project/internal/controller"
    "my-gin-project/internal/middleware"
    "my-gin-project/internal/service"
    "my-gin-project/internal/repository"
)

func SetupRouter() *gin.Engine {
    // æ ¹æ®é…ç½®è®¾ç½®æ¨¡å¼
    // gin.SetMode(config.AppConfig.Server.Mode)
    
    r := gin.New()
    
    // å…¨å±€ä¸­é—´ä»¶
    r.Use(middleware.Logger())
    r.Use(middleware.Recovery())
    r.Use(middleware.ErrorHandler())
    r.Use(middleware.CORS())
    
    // å¥åº·æ£€æŸ¥
    r.GET("/health", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })
    
    // åˆå§‹åŒ–ä¾èµ–
    userRepo := repository.NewUserRepository()
    userService := service.NewUserService(userRepo)
    userController := controller.NewUserController(userService)
    
    authService := service.NewAuthService()
    authController := controller.NewAuthController(authService)
    
    // APIè·¯ç”±ç»„
    api := r.Group("/api/v1")
    {
        // è®¤è¯è·¯ç”±
        auth := api.Group("/auth")
        {
            auth.POST("/login", authController.Login)
            auth.POST("/register", authController.Register)
        }
        
        // éœ€è¦è®¤è¯çš„è·¯ç”±
        protected := api.Group("")
        protected.Use(middleware.JWTAuth())
        {
            // ç”¨æˆ·è·¯ç”±
            users := protected.Group("/users")
            {
                users.GET("", userController.GetUsers)
                users.GET("/:id", userController.GetUser)
                users.POST("", userController.CreateUser)
                users.PUT("/:id", userController.UpdateUser)
                users.DELETE("/:id", userController.DeleteUser)
            }
        }
    }
    
    return r
}
```

---

## ä¹ã€æ—¥å¿—è®°å½•

### 8.1 æ—¥å¿—ä¸­é—´ä»¶

**internal/middleware/logger.go**:

```go
package middleware

import (
    "github.com/gin-gonic/gin"
    "time"
    "go.uber.org/zap"
)

var logger *zap.Logger

func init() {
    var err error
    logger, err = zap.NewProduction()
    if err != nil {
        panic(err)
    }
}

func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path
        query := c.Request.URL.RawQuery
        
        c.Next()
        
        latency := time.Since(start)
        
        logger.Info("HTTP Request",
            zap.String("method", c.Request.Method),
            zap.String("path", path),
            zap.String("query", query),
            zap.Int("status", c.Writer.Status()),
            zap.Duration("latency", latency),
            zap.String("ip", c.ClientIP()),
            zap.String("user-agent", c.Request.UserAgent()),
        )
    }
}
```

---

## åã€å•å…ƒæµ‹è¯•

### 9.1 æ§åˆ¶å™¨æµ‹è¯•

**tests/unit/user_controller_test.go**:

```go
package unit

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "my-gin-project/internal/controller"
    "my-gin-project/internal/service"
)

func TestUserController_CreateUser(t *testing.T) {
    gin.SetMode(gin.TestMode)
    
    // Mock service
    userService := &service.MockUserService{}
    userController := controller.NewUserController(userService)
    
    // è®¾ç½®è·¯ç”±
    r := gin.New()
    r.POST("/users", userController.CreateUser)
    
    // åˆ›å»ºè¯·æ±‚
    body := map[string]interface{}{
        "name":  "Alice",
        "email": "alice@example.com",
    }
    jsonBody, _ := json.Marshal(body)
    
    req, _ := http.NewRequest("POST", "/users", bytes.NewBuffer(jsonBody))
    req.Header.Set("Content-Type", "application/json")
    
    // æ‰§è¡Œè¯·æ±‚
    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)
    
    // æ–­è¨€
    assert.Equal(t, http.StatusCreated, w.Code)
    
    var response map[string]interface{}
    json.Unmarshal(w.Body.Bytes(), &response)
    assert.Equal(t, "success", response["message"])
}
```

### 9.2 é›†æˆæµ‹è¯•

**tests/integration/user_api_test.go**:

```go
package integration

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    
    "github.com/stretchr/testify/assert"
    "my-gin-project/internal/router"
)

func TestUserAPI(t *testing.T) {
    r := router.SetupRouter()
    
    // åˆ›å»ºç”¨æˆ·
    body := map[string]interface{}{
        "name":  "Test User",
        "email": "test@example.com",
    }
    jsonBody, _ := json.Marshal(body)
    
    req := httptest.NewRequest("POST", "/api/v1/users", bytes.NewBuffer(jsonBody))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer test-token")
    
    w := httptest.NewRecorder()
    r.ServeHTTP(w, req)
    
    assert.Equal(t, http.StatusCreated, w.Code)
}
```

---

## åä¸€ã€æ€§èƒ½ä¼˜åŒ–

### 10.1 è¿æ¥æ± é…ç½®

```go
// æ•°æ®åº“è¿æ¥æ± 
db.SetMaxOpenConns(100)
db.SetMaxIdleConns(10)
db.SetConnMaxLifetime(time.Hour)

// HTTPå®¢æˆ·ç«¯è¿æ¥æ± 
transport := &http.Transport{
    MaxIdleConns:        100,
    MaxIdleConnsPerHost: 10,
    IdleConnTimeout:     90 * time.Second,
}
```

### 10.2 å“åº”å‹ç¼©

```go
import "github.com/gin-contrib/gzip"

r.Use(gzip.Gzip(gzip.DefaultCompression))
```

### 10.3 é™æ€èµ„æºç¼“å­˜

```go
r.Static("/static", "./static")
r.Use(func(c *gin.Context) {
    if strings.HasPrefix(c.Request.URL.Path, "/static") {
        c.Header("Cache-Control", "public, max-age=31536000")
    }
    c.Next()
})
```

---

## åäºŒã€éƒ¨ç½²å®è·µ

### 11.1 Dockerfile

```dockerfile
# æ„å»ºé˜¶æ®µ
FROM golang:1.21-alpine AS builder

WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY go.mod go.sum ./
RUN go mod download

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o server ./cmd/server

# è¿è¡Œé˜¶æ®µ
FROM alpine:latest

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# ä»æ„å»ºé˜¶æ®µå¤åˆ¶äºŒè¿›åˆ¶æ–‡ä»¶
COPY --from=builder /app/server .

# æš´éœ²ç«¯å£
EXPOSE 8080

# è¿è¡Œåº”ç”¨
CMD ["./server"]
```

### 11.2 docker-compose.yml

```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SERVER_PORT=8080
      - DB_HOST=db
    depends_on:
      - db
      - redis

  db:
    image: postgres:15
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

### 11.3 ä¼˜é›…å…³é—­

**cmd/server/main.go**:

```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "my-gin-project/internal/config"
    "my-gin-project/internal/router"
)

func main() {
    // åŠ è½½é…ç½®
    if err := config.LoadConfig("configs/config.yaml"); err != nil {
        log.Fatal("Failed to load config:", err)
    }
    
    // è®¾ç½®è·¯ç”±
    r := router.SetupRouter()
    
    // åˆ›å»ºHTTPæœåŠ¡å™¨
    srv := &http.Server{
        Addr:    fmt.Sprintf(":%d", config.AppConfig.Server.Port),
        Handler: r,
    }
    
    // åœ¨goroutineä¸­å¯åŠ¨æœåŠ¡å™¨
    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("Server failed to start: %v", err)
        }
    }()
    
    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("Shutting down server...")
    
    // ä¼˜é›…å…³é—­ï¼Œç­‰å¾…5ç§’
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }
    
    log.Println("Server exited")
}
```

---

## åä¸‰ã€ç»¼åˆç¤ºä¾‹

å®Œæ•´çš„é¡¹ç›®ç»“æ„ç¤ºä¾‹ï¼š

```
my-gin-project/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ config.go
â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â”œâ”€â”€ user_controller.go
â”‚   â”‚   â””â”€â”€ auth_controller.go
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”œâ”€â”€ user_service.go
â”‚   â”‚   â””â”€â”€ auth_service.go
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â”œâ”€â”€ user_repository.go
â”‚   â”‚   â””â”€â”€ database.go
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â””â”€â”€ user.go
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ auth.go
â”‚   â”‚   â”œâ”€â”€ logger.go
â”‚   â”‚   â””â”€â”€ error_handler.go
â”‚   â”œâ”€â”€ router/
â”‚   â”‚   â””â”€â”€ router.go
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ response.go
â”‚       â””â”€â”€ errors.go
â”œâ”€â”€ configs/
â”‚   â””â”€â”€ config.yaml
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ integration/
â”‚   â””â”€â”€ unit/
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ go.mod
â””â”€â”€ README.md
```

---

## æ€»ç»“

1. **é¡¹ç›®ç»“æ„**ï¼šä½¿ç”¨æ ‡å‡†Goé¡¹ç›®å¸ƒå±€ï¼Œåˆ†ç¦»å…³æ³¨ç‚¹
2. **GORMé›†æˆ**ï¼šä½¿ç”¨GORMè¿›è¡Œæ•°æ®åº“æ“ä½œï¼Œæ”¯æŒæ¨¡å‹å®šä¹‰ã€è¿ç§»ã€å…³è”æŸ¥è¯¢ç­‰
3. **åˆ†å±‚æ¶æ„**ï¼šController â†’ Service â†’ Repository
4. **é…ç½®ç®¡ç†**ï¼šä½¿ç”¨é…ç½®æ–‡ä»¶å’Œç¯å¢ƒå˜é‡
5. **é”™è¯¯å¤„ç†**ï¼šç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œå“åº”æ ¼å¼
6. **æµ‹è¯•**ï¼šç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
7. **æ€§èƒ½ä¼˜åŒ–**ï¼šè¿æ¥æ± ã€å‹ç¼©ã€ç¼“å­˜ç­‰
8. **éƒ¨ç½²**ï¼šä½¿ç”¨Dockerå®¹å™¨åŒ–éƒ¨ç½²

**å®Œæˆæ ‡å¿—**ï¼šä½ å·²ç»æŒæ¡äº†Ginæ¡†æ¶çš„å®Œæ•´å¼€å‘æµç¨‹ï¼Œèƒ½å¤Ÿæ„å»ºç”Ÿäº§çº§çš„Webåº”ç”¨ï¼

---

## ğŸ“š æ‰©å±•å­¦ä¹ 

- [Ginå®˜æ–¹æ–‡æ¡£](https://gin-gonic.com/docs/)
- [GORMå®˜æ–¹æ–‡æ¡£](https://gorm.io/docs/)
- [Goé¡¹ç›®å¸ƒå±€æ ‡å‡†](https://github.com/golang-standards/project-layout)
- [Effective Go](https://go.dev/doc/effective_go)
- [Goæµ‹è¯•æœ€ä½³å®è·µ](https://golang.org/doc/effective_go#testing)

ç¥ä½ å¼€å‘é¡ºåˆ©ï¼ğŸš€
