---
title: 13、Go语言高级：并发基础
date: 2026-01-06
description: 深入理解并发与并行的区别，掌握Goroutine的基础使用
---

# 12、Go语言高级：并发基础

本文档从并发与并行的基本概念开始，逐步介绍Go语言的并发编程基础。理解这些基础概念是掌握Go并发编程的关键。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 理解并发与并行的区别
- ✅ 掌握goroutine的创建和使用
- ✅ 了解Go的并发模型
- ✅ 认识CPU密集型 vs IO密集型的区别

---

## 二、并发（Concurrency）

### 2.0 并发与并行的区别

在深入理解Go的并发模型之前，我们需要先理解两个重要概念：**并发（Concurrency）**和**并行（Parallelism）**。

#### 并发 vs 并行

**并发（Concurrency）**：
- 指**同时处理多个任务**的能力
- 多个任务可以在**时间上重叠**执行
- 不要求同时执行，可以在单核CPU上通过**时间片轮转**实现
- 关注的是**程序的设计结构**，如何组织代码以处理多个任务

**并行（Parallelism）**：
- 指**同时执行多个任务**
- 多个任务**真正同时**运行
- 需要**多核CPU**或多台机器
- 关注的是**执行效率**，如何同时执行多个任务

#### 形象比喻

想象你在做两件事：**煮咖啡**和**烤面包**。

- **并发**：你可以在等水开的时候去准备面包，然后回来继续煮咖啡。虽然你一次只做一件事，但通过合理安排，两件事在时间上重叠了。
- **并行**：如果你有两只手，可以一只手煮咖啡，另一只手烤面包，真正同时进行。

#### 代码示例

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

// 并发示例：多个goroutine在单核上通过时间片轮转执行
func concurrentExample() {
    fmt.Println("=== 并发示例 ===")

    for i := 0; i < 3; i++ {
        go func(id int) {
            for j := 0; j < 3; j++ {
                fmt.Printf("Goroutine %d: 执行 %d\n", id, j)
                time.Sleep(10 * time.Millisecond)
            }
        }(i)
    }

    time.Sleep(100 * time.Millisecond)
}

// 并行示例：利用多核CPU真正同时执行
func parallelExample() {
    fmt.Println("\n=== 并行示例 ===")
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())

    var wg sync.WaitGroup
    numWorkers := runtime.NumCPU()

    // 创建与CPU核心数相同的goroutine，充分利用多核
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            // CPU密集型任务
            sum := 0
            for j := 0; j < 1000000; j++ {
                sum += j
            }
            fmt.Printf("Worker %d 完成计算，结果: %d\n", id, sum)
        }(i)
    }

    wg.Wait()
}

func main() {
    concurrentExample()
    parallelExample()
}
```

#### Go的并发模型

Go语言通过**Goroutine**实现了轻量级的并发：

1. **Goroutine是并发单位**：可以创建成千上万个goroutine
2. **Go运行时调度**：Go的调度器（Scheduler）负责在多个goroutine之间分配CPU时间
3. **M:N模型**：M个goroutine映射到N个OS线程（通常N等于CPU核心数）

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    // 查看当前goroutine数量
    fmt.Printf("当前goroutine数: %d\n", runtime.NumGoroutine())

    // 查看CPU核心数
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())

    // 设置最大可同时执行的goroutine数（默认等于CPU核心数）
    // runtime.GOMAXPROCS(4)  // 可以手动设置
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
}
```

#### Go的并行问题

虽然Go提供了强大的并发能力，但在实际使用中需要注意以下问题：

##### 1. GOMAXPROCS的限制

`GOMAXPROCS` 决定了可以**并行执行**的goroutine数量（通常等于CPU核心数）。

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func cpuIntensiveTask(id int) {
    sum := 0
    for i := 0; i < 10000000; i++ {
        sum += i
    }
    fmt.Printf("任务 %d 完成\n", id)
}

func main() {
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))

    // 创建100个goroutine
    var wg sync.WaitGroup
    start := time.Now()

    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            cpuIntensiveTask(id)
        }(i)
    }

    wg.Wait()
    elapsed := time.Since(start)

    fmt.Printf("创建 %d 个goroutine\n", 100)
    fmt.Printf("总耗时: %v\n", elapsed)

    // 注意：虽然创建了100个goroutine，但真正并行执行的只有GOMAXPROCS个
    // 其他goroutine需要等待CPU时间片
}
```

##### 2. CPU密集型 vs IO密集型

- **CPU密集型任务**：受限于CPU核心数，增加goroutine数量不会提升性能
- **IO密集型任务**：可以创建大量goroutine，因为大部分时间在等待IO

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// CPU密集型：受限于CPU核心数
func cpuBound() {
    sum := 0
    for i := 0; i < 100000000; i++ {
        sum += i
    }
}

// IO密集型：可以创建大量goroutine
func ioBound() {
    time.Sleep(100 * time.Millisecond)  // 模拟IO操作
}

func main() {
    // CPU密集型：goroutine数量应该接近CPU核心数
    fmt.Println("=== CPU密集型任务 ===")
    var wg1 sync.WaitGroup
    start1 := time.Now()

    for i := 0; i < 4; i++ {  // 假设4核CPU
        wg1.Add(1)
        go func() {
            defer wg1.Done()
            cpuBound()
        }()
    }
    wg1.Wait()
    fmt.Printf("耗时: %v\n", time.Since(start1))

    // IO密集型：可以创建大量goroutine
    fmt.Println("\n=== IO密集型任务 ===")
    var wg2 sync.WaitGroup
    start2 := time.Now()

    for i := 0; i < 100; i++ {  // 可以创建很多
        wg2.Add(1)
        go func() {
            defer wg2.Done()
            ioBound()
        }()
    }
    wg2.Wait()
    fmt.Printf("耗时: %v\n", time.Since(start2))
}
```

##### 3. False Sharing（伪共享）

当多个goroutine访问同一CPU缓存行的不同数据时，会导致性能下降：

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "sync/atomic"
)

// 不好的设计：可能导致false sharing
type BadCounter struct {
    counters [8]int64  // 8个计数器，可能在同一缓存行
}

// 好的设计：使用padding避免false sharing
type GoodCounter struct {
    counters [8]int64
    _        [56]byte  // padding，确保每个计数器在不同缓存行
}

func main() {
    fmt.Printf("CPU缓存行大小通常是64字节\n")
    fmt.Printf("int64是8字节，所以8个int64可能在同一缓存行\n")

    // 在实际开发中，如果遇到性能问题，可以考虑：
    // 1. 使用sync/atomic包
    // 2. 使用channel代替共享内存
    // 3. 合理设计数据结构，避免false sharing
}
```

##### 4. 调度延迟

虽然goroutine很轻量，但大量goroutine仍可能导致调度延迟：

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func main() {
    // 创建大量goroutine
    var wg sync.WaitGroup
    numGoroutines := 10000

    start := time.Now()
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            time.Sleep(1 * time.Millisecond)  // 短暂任务
        }(i)
    }

    wg.Wait()
    elapsed := time.Since(start)

    fmt.Printf("创建 %d 个goroutine\n", numGoroutines)
    fmt.Printf("总耗时: %v\n", elapsed)
    fmt.Printf("平均每个goroutine: %v\n", elapsed/time.Duration(numGoroutines))

    // 对于大量短任务，考虑使用worker pool模式
}
```

##### 5. 最佳实践

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

// 1. CPU密集型：goroutine数量 = CPU核心数
func cpuIntensiveWork() {
    numCPU := runtime.NumCPU()
    var wg sync.WaitGroup

    for i := 0; i < numCPU; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // CPU密集型任务
        }()
    }
    wg.Wait()
}

// 2. IO密集型：可以使用更多goroutine
func ioIntensiveWork() {
    var wg sync.WaitGroup

    // 可以根据实际情况调整，比如100-1000个
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // IO操作（网络请求、文件读写等）
        }()
    }
    wg.Wait()
}

// 3. 混合型：使用worker pool
type WorkerPool struct {
    workers  int
    tasks    chan func()
    wg       sync.WaitGroup
}

func NewWorkerPool(workers int) *WorkerPool {
    if workers <= 0 {
        workers = runtime.NumCPU()
    }

    wp := &WorkerPool{
        workers: workers,
        tasks:   make(chan func()),
    }

    // 启动worker
    for i := 0; i < workers; i++ {
        wp.wg.Add(1)
        go func() {
            defer wp.wg.Done()
            for task := range wp.tasks {
                task()
            }
        }()
    }

    return wp
}

func (wp *WorkerPool) Submit(task func()) {
    wp.tasks <- task
}

func (wp *WorkerPool) Close() {
    close(wp.tasks)
    wp.wg.Wait()
}

func main() {
    fmt.Println("根据任务类型选择合适的并发策略：")
    fmt.Println("1. CPU密集型：goroutine数 = CPU核心数")
    fmt.Println("2. IO密集型：可以使用更多goroutine")
    fmt.Println("3. 混合型：使用worker pool模式")
}
```

#### 总结

- **并发**是程序结构的设计方式，关注如何组织代码处理多个任务
- **并行**是执行方式，关注如何同时执行多个任务
- Go通过goroutine实现并发，通过GOMAXPROCS控制并行度
- 根据任务类型（CPU密集型 vs IO密集型）选择合适的并发策略
- 注意避免false sharing、调度延迟等问题
- 使用worker pool等模式优化性能

---

### 2.1 Goroutine

Goroutine是Go语言的轻量级线程，由Go运行时管理。创建goroutine非常简单，只需在函数调用前加上 `go` 关键字。

#### 基本使用

```go
package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    // 启动goroutine
    go sayHello()

    // 主goroutine继续执行
    fmt.Println("Hello from main!")

    // 等待一下，让goroutine有时间执行
    time.Sleep(100 * time.Millisecond)
}
```

#### 多个Goroutine

```go
package main

import (
    "fmt"
    "time"
)

func printNumbers(id int) {
    for i := 1; i <= 5; i++ {
        fmt.Printf("Goroutine %d: %d\n", id, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // 启动多个goroutine
    for i := 1; i <= 3; i++ {
        go printNumbers(i)
    }

    // 等待所有goroutine完成
    time.Sleep(2 * time.Second)
}
```

#### Goroutine的特点

1. **轻量级**：创建成本低，可以创建成千上万个
2. **并发执行**：多个goroutine可以并发执行
3. **非阻塞**：启动goroutine不会阻塞当前执行

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 可以创建大量goroutine
    for i := 0; i < 1000; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d\n", id)
        }(i)
    }

    time.Sleep(1 * time.Second)
}
```

---

### 2.2 sync.WaitGroup

`sync.WaitGroup` 是Go语言中用于等待一组goroutine完成的同步原语。它解决了主goroutine需要等待所有子goroutine完成的问题。

#### 为什么需要WaitGroup？

在使用goroutine时，我们经常遇到这样的问题：

```go
package main

import (
    "fmt"
    "time"
)

func worker(id int) {
    fmt.Printf("Worker %d 开始工作\n", id)
    time.Sleep(1 * time.Second)  // 模拟工作
    fmt.Printf("Worker %d 完成工作\n", id)
}

func main() {
    // 启动多个goroutine
    for i := 1; i <= 3; i++ {
        go worker(i)
    }
    
    // 问题：主goroutine如何知道所有worker都完成了？
    // 如果直接结束，worker可能还没执行完
    fmt.Println("主goroutine结束")
    // 输出可能只有"主goroutine结束"，worker的输出可能看不到
}
```

**问题**：主goroutine不知道子goroutine何时完成，可能提前退出。

#### WaitGroup的作用

`sync.WaitGroup` 提供了三个核心方法：

1. **`Add(delta int)`**：增加等待的goroutine数量
2. **`Done()`**：减少等待的goroutine数量（相当于 `Add(-1)`）
3. **`Wait()`**：阻塞直到计数器归零

#### 基本使用

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // 完成时调用Done，减少计数器
    
    fmt.Printf("Worker %d 开始工作\n", id)
    time.Sleep(1 * time.Second)  // 模拟工作
    fmt.Printf("Worker %d 完成工作\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    // 启动3个goroutine
    for i := 1; i <= 3; i++ {
        wg.Add(1)  // 增加计数器
        go worker(i, &wg)
    }
    
    wg.Wait()  // 等待所有goroutine完成
    fmt.Println("所有worker都完成了！")
}
```

**输出**：
```
Worker 1 开始工作
Worker 2 开始工作
Worker 3 开始工作
Worker 1 完成工作
Worker 2 完成工作
Worker 3 完成工作
所有worker都完成了！
```

#### 工作原理

WaitGroup内部维护一个计数器：
- `Add(n)`：计数器 +n
- `Done()`：计数器 -1
- `Wait()`：当计数器为0时返回，否则阻塞

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    
    fmt.Println("初始状态：计数器 = 0")
    
    // 启动5个goroutine
    for i := 1; i <= 5; i++ {
        wg.Add(1)  // 每次Add(1)，计数器+1
        fmt.Printf("启动goroutine %d，计数器 = %d\n", i, i)
        
        go func(id int) {
            defer wg.Done()  // 完成时计数器-1
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("Goroutine %d 完成\n", id)
        }(i)
    }
    
    fmt.Println("等待所有goroutine完成...")
    wg.Wait()  // 阻塞直到计数器归零
    fmt.Println("所有goroutine都完成了！")
}
```

#### 常见使用模式

##### 1. 使用defer确保Done被调用

```go
func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // 使用defer确保即使panic也会调用Done
    
    // 可能panic的代码
    if id == 0 {
        panic("invalid id")
    }
    
    // 工作代码...
}
```

##### 2. 批量Add

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func main() {
    var wg sync.WaitGroup
    numWorkers := 10
    
    // 一次性Add所有goroutine数量
    wg.Add(numWorkers)
    
    for i := 0; i < numWorkers; i++ {
        go func(id int) {
            defer wg.Done()
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("Worker %d 完成\n", id)
        }(i)
    }
    
    wg.Wait()
    fmt.Println("所有worker完成")
}
```

##### 3. 嵌套使用

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func taskGroup(groupID int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    var innerWg sync.WaitGroup
    numTasks := 3
    
    innerWg.Add(numTasks)
    for i := 0; i < numTasks; i++ {
        go func(taskID int) {
            defer innerWg.Done()
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("Group %d, Task %d 完成\n", groupID, taskID)
        }(i)
    }
    
    innerWg.Wait()
    fmt.Printf("Group %d 所有任务完成\n", groupID)
}

func main() {
    var wg sync.WaitGroup
    numGroups := 2
    
    wg.Add(numGroups)
    for i := 0; i < numGroups; i++ {
        go taskGroup(i, &wg)
    }
    
    wg.Wait()
    fmt.Println("所有组都完成了")
}
```

#### 常见错误和注意事项

##### 1. ❌ 错误：传递值而非指针

```go
// 错误：传递值
func worker(wg sync.WaitGroup) {
    defer wg.Done()
    // ...
}

func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go worker(wg)  // 错误！传递了副本
    wg.Wait()  // 可能永远等待
}

// 正确：传递指针
func worker(wg *sync.WaitGroup) {
    defer wg.Done()
    // ...
}

func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go worker(&wg)  // 正确！传递指针
    wg.Wait()
}
```

##### 2. ❌ 错误：Add和Done不匹配

```go
// 错误：Add了3次，但只Done了2次
var wg sync.WaitGroup
wg.Add(3)
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
// 忘记第三个Done
wg.Wait()  // 永远等待

// 正确：确保Add和Done匹配
var wg sync.WaitGroup
wg.Add(3)
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
wg.Wait()
```

##### 3. ❌ 错误：在goroutine启动前调用Wait

```go
// 错误：Wait在goroutine启动之前
var wg sync.WaitGroup
wg.Add(1)
wg.Wait()  // 立即返回，因为计数器已经是0（Add后立即Wait）
go func() {
    defer wg.Done()
    // ...
}()

// 正确：Wait在goroutine启动之后
var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    // ...
}()
wg.Wait()  // 等待goroutine完成
```

##### 4. ❌ 错误：重复使用WaitGroup

```go
// 错误：WaitGroup不能重复使用
var wg sync.WaitGroup

// 第一轮
wg.Add(2)
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
wg.Wait()

// 第二轮：不能重复使用同一个WaitGroup
wg.Add(2)  // 可能有问题
go func() { defer wg.Done(); /* ... */ }()
go func() { defer wg.Done(); /* ... */ }()
wg.Wait()

// 正确：每次使用新的WaitGroup或确保计数器归零后再使用
```

#### 实际应用示例

##### 示例1：并发下载

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func download(url string, wg *sync.WaitGroup) {
    defer wg.Done()
    
    fmt.Printf("开始下载: %s\n", url)
    time.Sleep(1 * time.Second)  // 模拟下载
    fmt.Printf("完成下载: %s\n", url)
}

func main() {
    urls := []string{
        "https://example.com/file1",
        "https://example.com/file2",
        "https://example.com/file3",
    }
    
    var wg sync.WaitGroup
    wg.Add(len(urls))
    
    for _, url := range urls {
        go download(url, &wg)
    }
    
    wg.Wait()
    fmt.Println("所有文件下载完成！")
}
```

##### 示例2：并发处理数据

```go
package main

import (
    "fmt"
    "sync"
)

func processData(data []int, wg *sync.WaitGroup, results chan<- int) {
    defer wg.Done()
    
    sum := 0
    for _, v := range data {
        sum += v
    }
    results <- sum
}

func main() {
    dataChunks := [][]int{
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15},
    }
    
    var wg sync.WaitGroup
    results := make(chan int, len(dataChunks))
    
    wg.Add(len(dataChunks))
    for _, chunk := range dataChunks {
        go processData(chunk, &wg, results)
    }
    
    // 等待所有goroutine完成
    wg.Wait()
    close(results)
    
    // 收集结果
    total := 0
    for sum := range results {
        total += sum
    }
    
    fmt.Printf("总和: %d\n", total)
}
```

##### 示例3：带超时的WaitGroup

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    fmt.Printf("Worker %d 开始\n", id)
    time.Sleep(2 * time.Second)  // 模拟长时间任务
    fmt.Printf("Worker %d 完成\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    wg.Add(3)
    for i := 1; i <= 3; i++ {
        go worker(i, &wg)
    }
    
    // 使用channel实现超时
    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()
    
    select {
    case <-done:
        fmt.Println("所有worker完成")
    case <-time.After(1 * time.Second):
        fmt.Println("超时！部分worker可能还在运行")
    }
}
```

#### WaitGroup vs 其他同步方式

| 特性 | WaitGroup | Channel | Mutex |
|------|-----------|---------|-------|
| **用途** | 等待goroutine完成 | 通信和同步 | 保护共享资源 |
| **阻塞** | Wait()阻塞直到完成 | 发送/接收阻塞 | Lock()阻塞 |
| **适用场景** | 等待一组任务完成 | 数据传递和同步 | 互斥访问 |

#### 最佳实践

1. **总是使用defer调用Done**：确保即使发生panic也会调用Done
2. **传递指针而非值**：WaitGroup必须传递指针
3. **确保Add和Done匹配**：Add的数量必须等于Done的调用次数
4. **在goroutine启动后再Wait**：确保goroutine有机会执行
5. **不要重复使用**：WaitGroup计数器归零后，如果需要再次使用，应该创建新的WaitGroup

```go
// ✅ 推荐模式
func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // 使用defer确保调用
    
    // 工作代码...
}

func main() {
    var wg sync.WaitGroup
    
    // 批量Add
    wg.Add(numWorkers)
    
    for i := 0; i < numWorkers; i++ {
        go worker(i, &wg)  // 传递指针
    }
    
    wg.Wait()  // 等待所有完成
}
```

---

## 总结

### 并发基础

1. **并发 vs 并行**：
   - **并发**：同时处理多个任务，关注程序结构设计
   - **并行**：同时执行多个任务，关注执行效率
   - Go通过goroutine实现并发，通过GOMAXPROCS控制并行度

2. **Goroutine**：
   - Go语言的轻量级线程实现
   - 通过`go`关键字启动
   - 可以创建大量goroutine（成千上万）
   - 由Go运行时调度器管理

3. **并发策略**：
   - **CPU密集型**：goroutine数量 ≈ CPU核心数
   - **IO密集型**：可以使用更多goroutine
   - 注意false sharing和调度延迟问题

4. **sync.WaitGroup**：
   - 用于等待一组goroutine完成的同步原语
   - 三个核心方法：`Add()`、`Done()`、`Wait()`
   - 必须传递指针而非值
   - 使用`defer wg.Done()`确保即使panic也会调用
   - 确保Add和Done的调用次数匹配

掌握并发基础概念、goroutine的使用和WaitGroup的同步机制是学习Go并发编程的第一步。在接下来的课程中，我们将学习goroutine之间的通信机制——Channel。