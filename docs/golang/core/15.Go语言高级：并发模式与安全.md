---
title: 15、Go语言高级：并发模式与安全
date: 2026-01-06
description: 掌握常见的并发编程模式和并发安全的最佳实践
---

# 15、Go语言高级：并发模式与安全

本文档介绍Go语言中常见的并发编程模式，以及如何编写并发安全的代码。理解这些模式和安全原则对于编写高质量的并发程序至关重要。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 掌握Worker Pool工作池模式
- ✅ 理解扇入扇出模式
- ✅ 学会使用管道模式
- ✅ 理解竞态条件的危害
- ✅ 掌握并发安全的最佳实践
- ✅ 使用工具检测并发问题

---

## 前置知识

- **第6课：并发基础** - 理解goroutine的基本概念
- **第7课：Channel通信** - 掌握channel的基本使用
- **第8课：并发控制** - 掌握Select和同步原语

---

## 六、并发编程模式

### 6.1 Worker Pool（工作池）

工作池模式是最常见的并发模式之一，通过固定数量的worker goroutine来处理任务队列。

#### 基本工作池

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Printf("Worker %d 开始处理任务 %d\n", id, job)
        time.Sleep(500 * time.Millisecond)  // 模拟工作时间
        results <- job * 2
        fmt.Printf("Worker %d 完成任务 %d\n", id, job)
    }
}

func main() {
    const numWorkers = 3
    const numJobs = 5

    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)

    // 启动worker池
    var wg sync.WaitGroup
    for w := 1; w <= numWorkers; w++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            worker(id, jobs, results)
        }(w)
    }

    // 发送任务
    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    close(jobs)

    // 等待所有worker完成
    go func() {
        wg.Wait()
        close(results)
    }()

    // 收集结果
    for result := range results {
        fmt.Printf("结果: %d\n", result)
    }
}
```

#### 动态工作池

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

// Task 代表一个任务
type Task struct {
    ID   int
    Work func() interface{}
}

// WorkerPool 动态工作池
type WorkerPool struct {
    workers   int
    taskQueue chan Task
    results   chan Result
    quit      chan bool
}

// Result 任务结果
type Result struct {
    TaskID int
    Value  interface{}
}

func NewWorkerPool(workers int) *WorkerPool {
    if workers <= 0 {
        workers = runtime.NumCPU()
    }

    wp := &WorkerPool{
        workers:   workers,
        taskQueue: make(chan Task, workers*2),
        results:   make(chan Result, workers*2),
        quit:      make(chan bool),
    }

    wp.start()
    return wp
}

func (wp *WorkerPool) start() {
    for i := 0; i < wp.workers; i++ {
        go func(id int) {
            for {
                select {
                case task := <-wp.taskQueue:
                    // 执行任务
                    result := task.Work()
                    wp.results <- Result{TaskID: task.ID, Value: result}
                case <-wp.quit:
                    return
                }
            }
        }(i)
    }
}

func (wp *WorkerPool) Submit(task Task) {
    wp.taskQueue <- task
}

func (wp *WorkerPool) GetResult() (Result, bool) {
    result, ok := <-wp.results
    return result, ok
}

func (wp *WorkerPool) Shutdown() {
    close(wp.quit)
    close(wp.taskQueue)
}

func main() {
    wp := NewWorkerPool(3)

    // 提交任务
    for i := 1; i <= 10; i++ {
        taskID := i
        wp.Submit(Task{
            ID: taskID,
            Work: func() interface{} {
                time.Sleep(200 * time.Millisecond)
                return taskID * taskID
            },
        })
    }

    // 收集结果
    resultsReceived := 0
    for resultsReceived < 10 {
        if result, ok := wp.GetResult(); ok {
            fmt.Printf("任务 %d 结果: %v\n", result.TaskID, result.Value)
            resultsReceived++
        }
    }

    wp.Shutdown()
}
```

---

### 6.2 扇入扇出（Fan-in/Fan-out）

扇入扇出是一种数据流模式：扇出将一个channel的数据分发到多个channel，扇入将多个channel的数据合并到一个channel。

#### 扇出模式

```go
package main

import (
    "fmt"
    "sync"
)

// 扇出：1对多，将一个输入分发到多个输出
func fanOut(input <-chan int, outputs []chan int) {
    defer func() {
        // 关闭所有输出channel
        for _, ch := range outputs {
            close(ch)
        }
    }()

    for value := range input {
        // 广播到所有输出channel
        for _, ch := range outputs {
            // 使用goroutine避免阻塞
            go func(ch chan int, val int) {
                ch <- val
            }(ch, value)
        }
    }
}

func main() {
    input := make(chan int, 5)
    outputs := []chan int{
        make(chan int, 3),
        make(chan int, 3),
        make(chan int, 3),
    }

    // 启动扇出
    go fanOut(input, outputs)

    // 发送数据
    go func() {
        for i := 1; i <= 5; i++ {
            input <- i
        }
        close(input)
    }()

    // 从多个输出收集数据
    var wg sync.WaitGroup
    for i, ch := range outputs {
        wg.Add(1)
        go func(id int, ch <-chan int) {
            defer wg.Done()
            for value := range ch {
                fmt.Printf("输出%d 收到: %d\n", id+1, value)
            }
        }(i, ch)
    }

    wg.Wait()
}
```

#### 扇入模式

```go
package main

import (
    "fmt"
    "sync"
)

// 扇入：多对1，将多个输入合并到一个输出
func fanIn(inputs []<-chan int, output chan<- int) {
    var wg sync.WaitGroup

    // 为每个输入启动一个goroutine
    for _, ch := range inputs {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for value := range c {
                output <- value
            }
        }(ch)
    }

    // 等待所有输入处理完毕后关闭输出
    go func() {
        wg.Wait()
        close(output)
    }()
}

func main() {
    inputs := []chan int{
        make(chan int, 3),
        make(chan int, 3),
        make(chan int, 3),
    }
    output := make(chan int, 9)

    // 启动扇入
    fanIn(inputs, output)

    // 向输入channel发送数据
    go func() {
        for i, ch := range inputs {
            go func(ch chan int, base int) {
                for j := 0; j < 3; j++ {
                    ch <- base + j
                }
                close(ch)
            }(ch, i*10)
        }
    }()

    // 收集输出
    for value := range output {
        fmt.Printf("合并结果: %d\n", value)
    }
}
```

#### 扇入扇出结合

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 生产者
func producer(id int, output chan<- int) {
    for i := 1; i <= 3; i++ {
        value := id*10 + i
        fmt.Printf("生产者 %d 生成: %d\n", id, value)
        output <- value
        time.Sleep(100 * time.Millisecond)
    }
    close(output)
}

// 处理器
func processor(id int, input <-chan int, output chan<- string) {
    for value := range input {
        result := fmt.Sprintf("处理器%d处理%d=%s", id, value, process(value))
        output <- result
    }
}

func process(value int) string {
    // 模拟处理
    time.Sleep(200 * time.Millisecond)
    return fmt.Sprintf("[%d]", value*2)
}

// 消费者
func consumer(input <-chan string) {
    for result := range input {
        fmt.Printf("消费者收到: %s\n", result)
    }
}

func main() {
    // 创建channel
    producerChans := []chan int{
        make(chan int, 3),
        make(chan int, 3),
    }
    processorChans := []chan string{
        make(chan string, 5),
        make(chan string, 5),
    }
    consumerChan := make(chan string, 10)

    // 启动生产者
    for i, ch := range producerChans {
        go producer(i+1, ch)
    }

    // 扇入：将生产者输出合并到处理器输入
    fanIn(producerChans, processorChans[0])

    // 启动处理器
    for i, ch := range processorChans {
        go processor(i+1, ch, consumerChan)
    }

    // 启动消费者
    go consumer(consumerChan)

    // 等待一段时间
    time.Sleep(3 * time.Second)
}

// 辅助函数：将多个输入channel扇入到一个输出channel
func fanIn(inputs []<-chan int, output chan<- int) {
    var wg sync.WaitGroup
    for _, ch := range inputs {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for value := range c {
                output <- value
            }
        }(ch)
    }
    go func() {
        wg.Wait()
        close(output)
    }()
}
```

---

### 6.3 管道（Pipeline）

管道模式将数据处理分解为一系列阶段，每个阶段由一个goroutine处理，形成数据处理流水线。

#### 基本管道

```go
package main

import (
    "fmt"
    "strings"
)

// 阶段1：生成数字
func generate(nums ...int) <-chan int {
    out := make(chan int, len(nums))
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

// 阶段2：平方
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// 阶段3：过滤偶数
func filterEven(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            if n%2 == 0 {
                out <- n
            }
        }
        close(out)
    }()
    return out
}

// 阶段4：格式化输出
func format(in <-chan int) <-chan string {
    out := make(chan string)
    go func() {
        for n := range in {
            out <- fmt.Sprintf("结果: %d", n)
        }
        close(out)
    }()
    return out
}

func main() {
    // 构建处理管道
    numbers := generate(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    squared := square(numbers)
    even := filterEven(squared)
    formatted := format(even)

    // 输出结果
    for result := range formatted {
        fmt.Println(result)
    }
}
```

#### 带错误处理的管道

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

// DataWithError 包含数据和可能的错误
type DataWithError struct {
    Data int
    Err  error
}

// 阶段1：生成数据（可能出错）
func generateWithError(nums ...int) <-chan DataWithError {
    out := make(chan DataWithError, len(nums))
    go func() {
        for _, n := range nums {
            if n < 0 {
                out <- DataWithError{Err: errors.New("负数无效")}
                continue
            }
            out <- DataWithError{Data: n}
            time.Sleep(50 * time.Millisecond)
        }
        close(out)
    }()
    return out
}

// 阶段2：处理数据（可能出错）
func processWithError(in <-chan DataWithError) <-chan DataWithError {
    out := make(chan DataWithError)
    go func() {
        for item := range in {
            if item.Err != nil {
                out <- DataWithError{Err: item.Err}
                continue
            }

            // 模拟处理可能出错
            if item.Data > 10 {
                out <- DataWithError{Err: errors.New("数据过大")}
                continue
            }

            result := item.Data * 2
            out <- DataWithError{Data: result}
        }
        close(out)
    }()
    return out
}

// 阶段3：格式化输出
func formatWithError(in <-chan DataWithError) <-chan string {
    out := make(chan string)
    go func() {
        for item := range in {
            if item.Err != nil {
                out <- fmt.Sprintf("错误: %v", item.Err)
            } else {
                out <- fmt.Sprintf("结果: %d", item.Data)
            }
        }
        close(out)
    }()
    return out
}

func main() {
    // 构建带错误处理的管道
    data := generateWithError(1, 2, 3, -1, 5, 15, 7)  // -1和15会出错
    processed := processWithError(data)
    formatted := formatWithError(processed)

    // 输出结果（包含错误信息）
    for result := range formatted {
        fmt.Println(result)
    }
}
```

---

### 6.4 生产者-消费者模式

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// 任务
type Task struct {
    ID      int
    Payload string
    Process func(string) string
}

// 生产者
func producer(tasks chan<- Task, numTasks int) {
    for i := 1; i <= numTasks; i++ {
        task := Task{
            ID:      i,
            Payload: fmt.Sprintf("数据%d", i),
            Process: func(data string) string {
                time.Sleep(200 * time.Millisecond)
                return fmt.Sprintf("[%s已处理]", data)
            },
        }
        fmt.Printf("生产任务: %d\n", task.ID)
        tasks <- task
    }
    close(tasks)
}

// 消费者
func consumer(id int, tasks <-chan Task, results chan<- string) {
    for task := range tasks {
        fmt.Printf("消费者 %d 处理任务 %d\n", id, task.ID)
        result := task.Process(task.Payload)
        results <- result
    }
}

// 结果收集器
func collector(results <-chan string, numTasks int) {
    for i := 0; i < numTasks; i++ {
        result := <-results
        fmt.Printf("收集结果: %s\n", result)
    }
}

func main() {
    const numTasks = 10
    const numConsumers = 3

    tasks := make(chan Task, numTasks)
    results := make(chan string, numTasks)

    // 启动生产者
    go producer(tasks, numTasks)

    // 启动消费者
    var wg sync.WaitGroup
    for i := 1; i <= numConsumers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            consumer(id, tasks, results)
        }(i)
    }

    // 启动结果收集器
    go collector(results, numTasks)

    wg.Wait()
    close(results)

    fmt.Println("所有任务完成")
}
```

---

## 七、并发安全

### 7.1 竞态条件（Race Condition）

竞态条件是指多个goroutine并发访问共享资源时，由于执行顺序不确定导致的结果不一致。

#### 竞态条件示例

```go
package main

import (
    "fmt"
    "sync"
)

// 不安全的计数器
type UnsafeCounter struct {
    value int
}

func (c *UnsafeCounter) Increment() {
    c.value++  // 这不是原子操作！
}

func main() {
    counter := UnsafeCounter{}
    var wg sync.WaitGroup

    // 启动多个goroutine并发访问
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }

    wg.Wait()
    fmt.Printf("期望值: 1000, 实际值: %d\n", counter.value)
    // 结果可能不是1000，这就是竞态条件！
}
```

#### 安全的实现

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

// 方法1：使用Mutex
type SafeCounter struct {
    mu    sync.Mutex
    value int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *SafeCounter) GetValue() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

// 方法2：使用原子操作
type AtomicCounter struct {
    value int64
}

func (c *AtomicCounter) Increment() {
    atomic.AddInt64(&c.value, 1)
}

func (c *AtomicCounter) GetValue() int64 {
    return atomic.LoadInt64(&c.value)
}

func main() {
    // 测试Mutex版本
    counter1 := SafeCounter{}
    var wg1 sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg1.Add(1)
        go func() {
            defer wg1.Done()
            counter1.Increment()
        }()
    }
    wg1.Wait()
    fmt.Printf("Mutex计数器: %d\n", counter1.GetValue())

    // 测试原子操作版本
    counter2 := AtomicCounter{}
    var wg2 sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg2.Add(1)
        go func() {
            defer wg2.Done()
            counter2.Increment()
        }()
    }
    wg2.Wait()
    fmt.Printf("原子计数器: %d\n", counter2.GetValue())
}
```

---

### 7.2 使用Channel避免竞态

通过Channel可以在不使用锁的情况下实现并发安全。

```go
package main

import (
    "fmt"
    "sync"
)

// 使用channel实现的线程安全计数器
type ChannelCounter struct {
    value int
    ch    chan func()
}

func NewChannelCounter() *ChannelCounter {
    c := &ChannelCounter{
        ch: make(chan func(), 100),  // 缓冲channel
    }

    // 启动处理goroutine
    go func() {
        for op := range c.ch {
            op()
        }
    }()

    return c
}

func (c *ChannelCounter) Increment() {
    done := make(chan bool)
    c.ch <- func() {
        c.value++
        done <- true
    }
    <-done
}

func (c *ChannelCounter) GetValue() int {
    done := make(chan int)
    c.ch <- func() {
        done <- c.value
    }
    return <-done
}

func (c *ChannelCounter) Close() {
    close(c.ch)
}

func main() {
    counter := NewChannelCounter()
    defer counter.Close()

    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }

    wg.Wait()
    fmt.Printf("Channel计数器: %d\n", counter.GetValue())
}
```

---

### 7.3 并发安全的数据结构

#### 线程安全的Map

```go
package main

import (
    "fmt"
    "sync"
)

// 线程安全的Map
type SafeMap struct {
    mu   sync.RWMutex
    data map[string]interface{}
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]interface{}),
    }
}

func (m *SafeMap) Set(key string, value interface{}) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.data[key] = value
}

func (m *SafeMap) Get(key string) (interface{}, bool) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    value, exists := m.data[key]
    return value, exists
}

func (m *SafeMap) Delete(key string) {
    m.mu.Lock()
    defer m.mu.Unlock()
    delete(m.data, key)
}

func (m *SafeMap) Keys() []string {
    m.mu.RLock()
    defer m.mu.RUnlock()

    keys := make([]string, 0, len(m.data))
    for k := range m.data {
        keys = append(keys, k)
    }
    return keys
}

func main() {
    sm := NewSafeMap()

    // 并发读写测试
    var wg sync.WaitGroup

    // 写入goroutine
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            sm.Set(fmt.Sprintf("key%d", id), id*10)
        }(i)
    }

    // 读取goroutine
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", id%10)
            if value, exists := sm.Get(key); exists {
                fmt.Printf("读取 %s: %v\n", key, value)
            }
        }(i)
    }

    wg.Wait()

    fmt.Println("所有键:", sm.Keys())
}
```

---

### 7.4 检测竞态条件

Go提供了竞态检测工具来帮助发现并发问题。

#### 使用go run -race

```go
package main

import (
    "fmt"
    "sync"
)

// 这个程序有竞态条件
func main() {
    var counter int
    var wg sync.WaitGroup

    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++  // 竞态条件！
        }()
    }

    wg.Wait()
    fmt.Printf("最终值: %d\n", counter)
}

// 运行方式：
// go run -race main.go
//
// 输出示例：
// ==================
// WARNING: DATA RACE
// Read at 0x00c0000a0010 by goroutine 7:
//   main.main.func1()
//       /path/to/main.go:14 +0x3a
//
// Previous write at 0x00c0000a0010 by goroutine 6:
//   main.main.func1()
//       /path/to/main.go:14 +0x3a
//
// Goroutine 7 (running) created at:
//   main.main()
//       /path/to/main.go:11 +0x7c
//
// Goroutine 6 (finished) created at:
//   main.main()
//       /path/to/main.go:11 +0x7c
// ==================
// Found 1 data race(s)
// 最终值: 100
```

#### 修复竞态条件

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

// 修复版本1：使用Mutex
func withMutex() {
    var counter int
    var mu sync.Mutex
    var wg sync.WaitGroup

    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }

    wg.Wait()
    fmt.Printf("Mutex版本: %d\n", counter)
}

// 修复版本2：使用原子操作
func withAtomic() {
    var counter int64
    var wg sync.WaitGroup

    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }

    wg.Wait()
    fmt.Printf("原子操作版本: %d\n", counter)
}

// 修复版本3：使用Channel
func withChannel() {
    ch := make(chan int, 100)
    var wg sync.WaitGroup

    // 计数器goroutine
    go func() {
        counter := 0
        for range ch {
            counter++
        }
        fmt.Printf("Channel版本: %d\n", counter)
    }()

    // 发送增量信号
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            ch <- 1
        }()
    }

    wg.Wait()
    close(ch)
}

func main() {
    fmt.Println("=== 修复竞态条件的不同方法 ===")
    withMutex()
    withAtomic()
    withChannel()

    // 运行: go run -race main.go
    // 应该不会报告任何竞态条件
}
```

---

## 总结

### 并发编程模式

1. **Worker Pool（工作池）**：
   - 固定数量的worker处理任务队列
   - 适用于CPU密集型和IO密集型任务
   - 可以控制并发度，避免资源耗尽

2. **扇入扇出（Fan-in/Fan-out）**：
   - 扇出：1对多数据分发
   - 扇入：多对1数据合并
   - 适用于数据流处理和负载均衡

3. **管道（Pipeline）**：
   - 将处理分解为多个阶段
   - 每个阶段由goroutine处理
   - 提高数据处理效率和代码组织

4. **生产者-消费者**：
   - 解耦生产者和消费者
   - 通过channel通信
   - 适用于异步处理场景

### 并发安全原则

1. **避免竞态条件**：
   - 使用互斥锁（Mutex）
   - 使用读写锁（RWMutex）
   - 使用原子操作
   - 通过channel通信

2. **选择合适的同步原语**：
   - **共享内存**：使用锁保护
   - **消息传递**：使用channel
   - **单次执行**：使用Once
   - **条件等待**：使用Cond

3. **检测并发问题**：
   - 使用 `go run -race` 检测竞态条件
   - 使用 `go build -race` 构建竞态检测版本
   - 定期运行测试检查并发安全

4. **最佳实践**：
   - 优先使用channel而非锁
   - 保持临界区最小化
   - 避免死锁：固定锁顺序，及时释放锁
   - 使用defer确保资源释放

掌握这些并发模式和安全原则后，你就可以编写出高质量、可靠的并发程序了。在下一课中，我们将学习Context包和综合的并发示例。