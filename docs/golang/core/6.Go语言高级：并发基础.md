---
title: 6、Go语言高级：并发基础
date: 2026-01-06
description: 深入理解并发与并行的区别，掌握Goroutine的基础使用
---

# 6、Go语言高级：并发基础

本文档从并发与并行的基本概念开始，逐步介绍Go语言的并发编程基础。理解这些基础概念是掌握Go并发编程的关键。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 理解并发与并行的区别
- ✅ 掌握goroutine的创建和使用
- ✅ 了解Go的并发模型
- ✅ 认识CPU密集型 vs IO密集型的区别

---

## 二、并发（Concurrency）

### 2.0 并发与并行的区别

在深入理解Go的并发模型之前，我们需要先理解两个重要概念：**并发（Concurrency）**和**并行（Parallelism）**。

#### 并发 vs 并行

**并发（Concurrency）**：
- 指**同时处理多个任务**的能力
- 多个任务可以在**时间上重叠**执行
- 不要求同时执行，可以在单核CPU上通过**时间片轮转**实现
- 关注的是**程序的设计结构**，如何组织代码以处理多个任务

**并行（Parallelism）**：
- 指**同时执行多个任务**
- 多个任务**真正同时**运行
- 需要**多核CPU**或多台机器
- 关注的是**执行效率**，如何同时执行多个任务

#### 形象比喻

想象你在做两件事：**煮咖啡**和**烤面包**。

- **并发**：你可以在等水开的时候去准备面包，然后回来继续煮咖啡。虽然你一次只做一件事，但通过合理安排，两件事在时间上重叠了。
- **并行**：如果你有两只手，可以一只手煮咖啡，另一只手烤面包，真正同时进行。

#### 代码示例

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

// 并发示例：多个goroutine在单核上通过时间片轮转执行
func concurrentExample() {
    fmt.Println("=== 并发示例 ===")

    for i := 0; i < 3; i++ {
        go func(id int) {
            for j := 0; j < 3; j++ {
                fmt.Printf("Goroutine %d: 执行 %d\n", id, j)
                time.Sleep(10 * time.Millisecond)
            }
        }(i)
    }

    time.Sleep(100 * time.Millisecond)
}

// 并行示例：利用多核CPU真正同时执行
func parallelExample() {
    fmt.Println("\n=== 并行示例 ===")
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())

    var wg sync.WaitGroup
    numWorkers := runtime.NumCPU()

    // 创建与CPU核心数相同的goroutine，充分利用多核
    for i := 0; i < numWorkers; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            // CPU密集型任务
            sum := 0
            for j := 0; j < 1000000; j++ {
                sum += j
            }
            fmt.Printf("Worker %d 完成计算，结果: %d\n", id, sum)
        }(i)
    }

    wg.Wait()
}

func main() {
    concurrentExample()
    parallelExample()
}
```

#### Go的并发模型

Go语言通过**Goroutine**实现了轻量级的并发：

1. **Goroutine是并发单位**：可以创建成千上万个goroutine
2. **Go运行时调度**：Go的调度器（Scheduler）负责在多个goroutine之间分配CPU时间
3. **M:N模型**：M个goroutine映射到N个OS线程（通常N等于CPU核心数）

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    // 查看当前goroutine数量
    fmt.Printf("当前goroutine数: %d\n", runtime.NumGoroutine())

    // 查看CPU核心数
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())

    // 设置最大可同时执行的goroutine数（默认等于CPU核心数）
    // runtime.GOMAXPROCS(4)  // 可以手动设置
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
}
```

#### Go的并行问题

虽然Go提供了强大的并发能力，但在实际使用中需要注意以下问题：

##### 1. GOMAXPROCS的限制

`GOMAXPROCS` 决定了可以**并行执行**的goroutine数量（通常等于CPU核心数）。

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func cpuIntensiveTask(id int) {
    sum := 0
    for i := 0; i < 10000000; i++ {
        sum += i
    }
    fmt.Printf("任务 %d 完成\n", id)
}

func main() {
    fmt.Printf("CPU核心数: %d\n", runtime.NumCPU())
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))

    // 创建100个goroutine
    var wg sync.WaitGroup
    start := time.Now()

    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            cpuIntensiveTask(id)
        }(i)
    }

    wg.Wait()
    elapsed := time.Since(start)

    fmt.Printf("创建 %d 个goroutine\n", 100)
    fmt.Printf("总耗时: %v\n", elapsed)

    // 注意：虽然创建了100个goroutine，但真正并行执行的只有GOMAXPROCS个
    // 其他goroutine需要等待CPU时间片
}
```

##### 2. CPU密集型 vs IO密集型

- **CPU密集型任务**：受限于CPU核心数，增加goroutine数量不会提升性能
- **IO密集型任务**：可以创建大量goroutine，因为大部分时间在等待IO

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// CPU密集型：受限于CPU核心数
func cpuBound() {
    sum := 0
    for i := 0; i < 100000000; i++ {
        sum += i
    }
}

// IO密集型：可以创建大量goroutine
func ioBound() {
    time.Sleep(100 * time.Millisecond)  // 模拟IO操作
}

func main() {
    // CPU密集型：goroutine数量应该接近CPU核心数
    fmt.Println("=== CPU密集型任务 ===")
    var wg1 sync.WaitGroup
    start1 := time.Now()

    for i := 0; i < 4; i++ {  // 假设4核CPU
        wg1.Add(1)
        go func() {
            defer wg1.Done()
            cpuBound()
        }()
    }
    wg1.Wait()
    fmt.Printf("耗时: %v\n", time.Since(start1))

    // IO密集型：可以创建大量goroutine
    fmt.Println("\n=== IO密集型任务 ===")
    var wg2 sync.WaitGroup
    start2 := time.Now()

    for i := 0; i < 100; i++ {  // 可以创建很多
        wg2.Add(1)
        go func() {
            defer wg2.Done()
            ioBound()
        }()
    }
    wg2.Wait()
    fmt.Printf("耗时: %v\n", time.Since(start2))
}
```

##### 3. False Sharing（伪共享）

当多个goroutine访问同一CPU缓存行的不同数据时，会导致性能下降：

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "sync/atomic"
)

// 不好的设计：可能导致false sharing
type BadCounter struct {
    counters [8]int64  // 8个计数器，可能在同一缓存行
}

// 好的设计：使用padding避免false sharing
type GoodCounter struct {
    counters [8]int64
    _        [56]byte  // padding，确保每个计数器在不同缓存行
}

func main() {
    fmt.Printf("CPU缓存行大小通常是64字节\n")
    fmt.Printf("int64是8字节，所以8个int64可能在同一缓存行\n")

    // 在实际开发中，如果遇到性能问题，可以考虑：
    // 1. 使用sync/atomic包
    // 2. 使用channel代替共享内存
    // 3. 合理设计数据结构，避免false sharing
}
```

##### 4. 调度延迟

虽然goroutine很轻量，但大量goroutine仍可能导致调度延迟：

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
    "time"
)

func main() {
    // 创建大量goroutine
    var wg sync.WaitGroup
    numGoroutines := 10000

    start := time.Now()
    for i := 0; i < numGoroutines; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            time.Sleep(1 * time.Millisecond)  // 短暂任务
        }(i)
    }

    wg.Wait()
    elapsed := time.Since(start)

    fmt.Printf("创建 %d 个goroutine\n", numGoroutines)
    fmt.Printf("总耗时: %v\n", elapsed)
    fmt.Printf("平均每个goroutine: %v\n", elapsed/time.Duration(numGoroutines))

    // 对于大量短任务，考虑使用worker pool模式
}
```

##### 5. 最佳实践

```go
package main

import (
    "fmt"
    "runtime"
    "sync"
)

// 1. CPU密集型：goroutine数量 = CPU核心数
func cpuIntensiveWork() {
    numCPU := runtime.NumCPU()
    var wg sync.WaitGroup

    for i := 0; i < numCPU; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // CPU密集型任务
        }()
    }
    wg.Wait()
}

// 2. IO密集型：可以使用更多goroutine
func ioIntensiveWork() {
    var wg sync.WaitGroup

    // 可以根据实际情况调整，比如100-1000个
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // IO操作（网络请求、文件读写等）
        }()
    }
    wg.Wait()
}

// 3. 混合型：使用worker pool
type WorkerPool struct {
    workers  int
    tasks    chan func()
    wg       sync.WaitGroup
}

func NewWorkerPool(workers int) *WorkerPool {
    if workers <= 0 {
        workers = runtime.NumCPU()
    }

    wp := &WorkerPool{
        workers: workers,
        tasks:   make(chan func()),
    }

    // 启动worker
    for i := 0; i < workers; i++ {
        wp.wg.Add(1)
        go func() {
            defer wp.wg.Done()
            for task := range wp.tasks {
                task()
            }
        }()
    }

    return wp
}

func (wp *WorkerPool) Submit(task func()) {
    wp.tasks <- task
}

func (wp *WorkerPool) Close() {
    close(wp.tasks)
    wp.wg.Wait()
}

func main() {
    fmt.Println("根据任务类型选择合适的并发策略：")
    fmt.Println("1. CPU密集型：goroutine数 = CPU核心数")
    fmt.Println("2. IO密集型：可以使用更多goroutine")
    fmt.Println("3. 混合型：使用worker pool模式")
}
```

#### 总结

- **并发**是程序结构的设计方式，关注如何组织代码处理多个任务
- **并行**是执行方式，关注如何同时执行多个任务
- Go通过goroutine实现并发，通过GOMAXPROCS控制并行度
- 根据任务类型（CPU密集型 vs IO密集型）选择合适的并发策略
- 注意避免false sharing、调度延迟等问题
- 使用worker pool等模式优化性能

---

### 2.1 Goroutine

Goroutine是Go语言的轻量级线程，由Go运行时管理。创建goroutine非常简单，只需在函数调用前加上 `go` 关键字。

#### 基本使用

```go
package main

import (
    "fmt"
    "time"
)

func sayHello() {
    fmt.Println("Hello from goroutine!")
}

func main() {
    // 启动goroutine
    go sayHello()

    // 主goroutine继续执行
    fmt.Println("Hello from main!")

    // 等待一下，让goroutine有时间执行
    time.Sleep(100 * time.Millisecond)
}
```

#### 多个Goroutine

```go
package main

import (
    "fmt"
    "time"
)

func printNumbers(id int) {
    for i := 1; i <= 5; i++ {
        fmt.Printf("Goroutine %d: %d\n", id, i)
        time.Sleep(100 * time.Millisecond)
    }
}

func main() {
    // 启动多个goroutine
    for i := 1; i <= 3; i++ {
        go printNumbers(i)
    }

    // 等待所有goroutine完成
    time.Sleep(2 * time.Second)
}
```

#### Goroutine的特点

1. **轻量级**：创建成本低，可以创建成千上万个
2. **并发执行**：多个goroutine可以并发执行
3. **非阻塞**：启动goroutine不会阻塞当前执行

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 可以创建大量goroutine
    for i := 0; i < 1000; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d\n", id)
        }(i)
    }

    time.Sleep(1 * time.Second)
}
```

---

## 总结

### 并发基础

1. **并发 vs 并行**：
   - **并发**：同时处理多个任务，关注程序结构设计
   - **并行**：同时执行多个任务，关注执行效率
   - Go通过goroutine实现并发，通过GOMAXPROCS控制并行度

2. **Goroutine**：
   - Go语言的轻量级线程实现
   - 通过`go`关键字启动
   - 可以创建大量goroutine（成千上万）
   - 由Go运行时调度器管理

3. **并发策略**：
   - **CPU密集型**：goroutine数量 ≈ CPU核心数
   - **IO密集型**：可以使用更多goroutine
   - 注意false sharing和调度延迟问题

掌握并发基础概念和goroutine的使用是学习Go并发编程的第一步。在接下来的课程中，我们将学习goroutine之间的通信机制——Channel。