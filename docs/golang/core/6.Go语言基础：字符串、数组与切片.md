---
title: 6、Go语言基础：字符串、数组与切片
date: 2026-01-09
description: 深入学习Go语言的字符串、数组、切片以及作用域机制
---

# 6、Go语言基础：字符串、数组与切片

本文档深入讲解Go语言的字符串、数组、切片以及作用域机制。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 理解字符串的特点和操作
- ✅ 掌握数组的定义和使用
- ✅ 深入理解切片的底层机制
- ✅ 理解作用域和变量遮蔽
- ✅ 掌握循环变量的作用域问题

---

## 前置知识

- **第1-4课**：了解变量、数据类型、运算符和指针

---

## 一、作用域机制

### 1.1 作用域的类型

Go语言采用**词法作用域**（静态作用域），变量的可见性由代码结构决定：

| 作用域类型 | 声明位置 | 可见范围 | 示例 |
|-----------|----------|----------|------|
| **包级作用域** | 包级别 | 整个包内可见 | `var pkgVar = "包级"` |
| **函数级作用域** | 函数内部 | 整个函数内可见 | `func f() { var x = 1 }` |
| **代码块作用域** | `if`/`for`/`switch`等 | 仅该代码块内可见 | `if true { var x = 1 }` |

### 1.2 变量遮蔽（Variable Shadowing）

内层作用域可以声明与外层同名的变量，外层变量被遮蔽：

```go
package main

import "fmt"

var x = "包级变量"

func main() {
    x := "函数级变量"  // 遮蔽包级变量x
    
    if true {
        x := "代码块变量"  // 遮蔽函数级变量x
        fmt.Println(x)    // 输出：代码块变量
    }
    
    fmt.Println(x)  // 输出：函数级变量
}
```

### 1.3 for循环变量的作用域

#### 传统for循环

```go
package main

import "fmt"

func main() {
    // i的作用域是整个for循环（包括初始化、条件、迭代、循环体）
    for i := 0; i < 3; i++ {
        fmt.Println(i)  // 0, 1, 2
    }
    // fmt.Println(i)  // 编译错误：i未定义
}
```

**关键点**：
- `i` 的作用域包括：初始化部分（`i := 0`）、条件部分（`i < 3`）、迭代部分（`i++`）和循环体
- 循环结束后，`i` 不可见，不能在循环外部访问

#### for-range循环（Go 1.22+）

Go 1.22修复了for-range循环的变量作用域问题：

```go
package main

import "fmt"

func main() {
    nums := []int{1, 2, 3}
    var funcs []func()
    
    // Go 1.22+：每次循环创建独立的v变量
    for _, v := range nums {
        funcs = append(funcs, func() {
            fmt.Println(v)  // 正确：每个闭包捕获不同的v
        })
    }
    
    for _, f := range funcs {
        f()  // 输出：1, 2, 3（而不是3, 3, 3）
    }
}
```

#### 循环变量的常见陷阱

```go
package main

import "fmt"

func main() {
    // 陷阱：在闭包中使用循环变量
    var funcs []func()
    for i := 0; i < 3; i++ {
        // 错误：所有闭包共享同一个i
        funcs = append(funcs, func() {
            fmt.Println(i)  // 都输出3
        })
    }
    
    // 正确：创建局部变量副本
    var funcs2 []func()
    for i := 0; i < 3; i++ {
        i := i  // 创建局部副本
        funcs2 = append(funcs2, func() {
            fmt.Println(i)  // 输出：0, 1, 2
        })
    }
    
    for _, f := range funcs2 {
        f()
    }
}
```

---

## 二、字符串（String）

### 2.1 字符串的特点

- **不可变**：字符串一旦创建，内容无法修改
- **UTF-8编码**：原生支持Unicode
- **值类型**：赋值时复制内容

### 2.2 字符串的两种表示

```go
package main

import "fmt"

func main() {
    // 双引号：支持转义字符
    s1 := "Hello\nWorld"  // 换行符会被转义
    
    // 反引号：原始字符串，保留所有字符
    s2 := `Hello\nWorld`  // 输出字面量 \n
    
    fmt.Println(s1)
    fmt.Println(s2)
}
```

### 2.3 字符串操作

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    s := "Hello"
    
    // 长度（字节数）
    fmt.Printf("长度: %d\n", len(s))  // 5
    
    // 访问字符（字节）
    fmt.Printf("第一个字符: %c\n", s[0])  // H
    
    // 字符串连接
    s2 := s + " World"
    fmt.Println(s2)  // Hello World
    
    // 使用strings包
    fmt.Println(strings.Contains(s, "ll"))  // true
    fmt.Println(strings.HasPrefix(s, "He"))  // true
    fmt.Println(strings.HasSuffix(s, "lo"))   // true
    fmt.Println(strings.Index(s, "l"))       // 2
    fmt.Println(strings.ToUpper(s))          // HELLO
    fmt.Println(strings.ToLower("HELLO"))    // hello
    fmt.Println(strings.TrimSpace("  hello  "))  // hello
    fmt.Println(strings.Split("a,b,c", ","))     // [a b c]
    fmt.Println(strings.Join([]string{"a", "b", "c"}, ","))  // a,b,c
}
```

### 2.4 字符串与字节

```go
package main

import "fmt"

func main() {
    s := "Hello"
    
    // 字符串转字节切片
    bytes := []byte(s)
    fmt.Printf("字节: %v\n", bytes)  // [72 101 108 108 111]
    
    // 字节切片转字符串
    s2 := string(bytes)
    fmt.Printf("字符串: %s\n", s2)  // Hello
    
    // 字符串转rune切片（Unicode字符）
    runes := []rune("你好")
    fmt.Printf("rune: %v\n", runes)  // [20320 22909]
    
    // rune切片转字符串
    s3 := string(runes)
    fmt.Printf("字符串: %s\n", s3)  // 你好
}
```

### 2.5 字符串的不可变性

```go
package main

import "fmt"

func main() {
    s := "Hello"
    
    // 不能直接修改字符串
    // s[0] = 'h'  // 编译错误：cannot assign to s[0]
    
    // 需要创建新字符串
    s2 := "h" + s[1:]
    fmt.Printf("原字符串: %s\n", s)   // Hello
    fmt.Printf("新字符串: %s\n", s2)  // hello
}
```

---

## 三、数组（Arrays）

### 3.1 数组的特点

- **固定长度**：声明时确定，不可改变
- **值类型**：赋值或传参时会**复制整个数组**
- **同类型元素**：所有元素必须是同一类型

### 3.2 数组的声明和初始化

```go
package main

import "fmt"

func main() {
    // 方式1：声明后初始化
    var arr1 [3]int              // [0 0 0]
    arr1[0] = 1
    arr1[1] = 2
    arr1[2] = 3
    
    // 方式2：声明时初始化
    arr2 := [3]int{1, 2, 3}      // [1 2 3]
    
    // 方式3：编译器推断长度
    arr3 := [...]int{1, 2, 3, 4}  // [1 2 3 4]
    
    // 方式4：指定索引初始化
    arr4 := [5]int{1: 10, 3: 30}  // [0 10 0 30 0]
    
    fmt.Println(arr1, arr2, arr3, arr4)
}
```

### 3.3 数组的值类型特性

```go
package main

import "fmt"

func main() {
    arr1 := [3]int{1, 2, 3}
    arr2 := arr1  // 复制整个数组
    
    arr2[0] = 100
    
    fmt.Println(arr1)  // [1 2 3]（原数组不变）
    fmt.Println(arr2)  // [100 2 3]
}
```

### 3.4 数组的遍历

```go
package main

import "fmt"

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    
    // 方式1：传统for循环
    for i := 0; i < len(arr); i++ {
        fmt.Printf("arr[%d] = %d\n", i, arr[i])
    }
    
    // 方式2：range循环
    for i, v := range arr {
        fmt.Printf("arr[%d] = %d\n", i, v)
    }
    
    // 方式3：只要值
    for _, v := range arr {
        fmt.Printf("值: %d\n", v)
    }
}
```

### 3.5 数组的局限性

由于数组是值类型且长度固定，在实际开发中很少直接使用，更多使用切片。

---

## 四、切片（Slices）

### 4.1 为什么需要切片？

切片解决了数组的两个问题：
1. **动态长度**：可以动态增长
2. **引用语义**：避免大数组的复制开销

### 4.2 切片的创建

```go
package main

import "fmt"

func main() {
    // 方式1：字面量
    s1 := []int{1, 2, 3}           // [1 2 3]
    
    // 方式2：make创建
    s2 := make([]int, 3)           // [0 0 0]，长度3
    s3 := make([]int, 3, 5)        // [0 0 0]，长度3，容量5
    
    // 方式3：从数组创建
    arr := [5]int{1, 2, 3, 4, 5}
    s4 := arr[1:4]                 // [2 3 4]
    
    // 方式4：从切片创建
    s5 := s1[1:]                   // [2 3]
    
    fmt.Println(s1, s2, s3, s4, s5)
}
```

### 4.3 切片的底层结构

切片是对底层数组的引用，包含三个字段：
- **指针**：指向底层数组的某个元素
- **长度（len）**：切片中元素个数
- **容量（cap）**：从切片起始位置到底层数组末尾的元素个数

```go
package main

import "fmt"

func main() {
    s := []int{1, 2, 3, 4, 5}
    fmt.Printf("长度: %d, 容量: %d\n", len(s), cap(s))  // 5, 5
    
    s2 := s[1:3]  // [2 3]
    fmt.Printf("长度: %d, 容量: %d\n", len(s2), cap(s2))  // 2, 4
    
    // 容量是从起始位置到底层数组末尾
    s3 := s[2:4]  // [3 4]
    fmt.Printf("长度: %d, 容量: %d\n", len(s3), cap(s3))  // 2, 3
}
```

### 4.4 切片的引用特性

```go
package main

import "fmt"

func main() {
    s1 := []int{1, 2, 3}
    s2 := s1          // s2和s1指向同一个底层数组
    
    s2[0] = 100       // 修改s2会影响s1
    fmt.Println(s1)   // [100 2 3]
    fmt.Println(s2)   // [100 2 3]
    
    // 但追加可能触发扩容，创建新数组
    s2 = append(s2, 4)
    s2[0] = 200
    fmt.Println(s1)   // [100 2 3]（s1不变）
    fmt.Println(s2)   // [200 2 3 4]
}
```

### 4.5 切片的操作

#### 追加元素

```go
package main

import "fmt"

func main() {
    s := []int{1, 2, 3}
    
    // 追加单个元素
    s = append(s, 4)
    
    // 追加多个元素
    s = append(s, 5, 6, 7)
    
    // 追加另一个切片
    s2 := []int{8, 9}
    s = append(s, s2...)
    
    fmt.Println(s)  // [1 2 3 4 5 6 7 8 9]
}
```

#### 复制切片

```go
package main

import (
    "fmt"
    "copy"
)

func main() {
    s1 := []int{1, 2, 3, 4, 5}
    s2 := make([]int, len(s1))
    
    // 复制切片
    copy(s2, s1)
    
    s2[0] = 100
    fmt.Println(s1)  // [1 2 3 4 5]
    fmt.Println(s2)  // [100 2 3 4 5]
}
```

#### 删除元素

```go
package main

import "fmt"

func main() {
    s := []int{1, 2, 3, 4, 5}
    
    // 删除索引为2的元素
    index := 2
    s = append(s[:index], s[index+1:]...)
    fmt.Println(s)  // [1 2 4 5]
    
    // 删除第一个元素
    s = s[1:]
    fmt.Println(s)  // [2 4 5]
    
    // 删除最后一个元素
    s = s[:len(s)-1]
    fmt.Println(s)  // [2 4]
}
```

### 4.6 切片的遍历

```go
package main

import "fmt"

func main() {
    s := []int{1, 2, 3, 4, 5}
    
    // 方式1：传统for循环
    for i := 0; i < len(s); i++ {
        fmt.Printf("s[%d] = %d\n", i, s[i])
    }
    
    // 方式2：range循环
    for i, v := range s {
        fmt.Printf("s[%d] = %d\n", i, v)
    }
    
    // 方式3：只要索引
    for i := range s {
        fmt.Printf("索引: %d\n", i)
    }
    
    // 方式4：只要值
    for _, v := range s {
        fmt.Printf("值: %d\n", v)
    }
}
```

---

## 五、最佳实践

### 5.1 作用域最小化

```go
// ❌ 不好的实践：变量作用域过大
var result int
for i := 0; i < 10; i++ {
    result = i * 2
}

// ✅ 好的实践：限制变量作用域
for i := 0; i < 10; i++ {
    result := i * 2  // 仅在循环内可见
    // 使用result...
}
```

### 5.2 避免变量遮蔽

```go
// ❌ 容易混淆
x := 1
if condition {
    x := 2  // 遮蔽外层x，可能不是预期行为
    // ...
}

// ✅ 使用不同的变量名
x := 1
if condition {
    y := 2  // 清晰的命名
    // ...
}
```

### 5.3 字符串操作

```go
// ✅ 使用strings包进行字符串操作
import "strings"

s := "Hello World"
if strings.Contains(s, "World") {
    // ...
}

// ✅ 使用strings.Builder进行大量字符串拼接
var builder strings.Builder
for i := 0; i < 100; i++ {
    builder.WriteString("a")
}
result := builder.String()
```

### 5.4 切片操作

```go
// ✅ 预分配容量（如果知道大概大小）
s := make([]int, 0, 100)  // 长度0，容量100

// ✅ 检查切片是否为空
if len(s) == 0 {
    // 空切片
}

// ✅ 避免共享底层数组的意外修改
func process(s []int) {
    s = append(s, 0)  // 可能触发扩容，创建新数组
    // ...
}
```

---

## 六、综合示例

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    // 1. 字符串操作
    s := "Hello World"
    fmt.Printf("包含'World': %t\n", strings.Contains(s, "World"))
    fmt.Printf("转大写: %s\n", strings.ToUpper(s))
    
    // 2. 数组
    arr := [3]int{1, 2, 3}
    arrCopy := arr
    arrCopy[0] = 100
    fmt.Printf("原数组: %v\n", arr)      // [1 2 3]
    fmt.Printf("副本: %v\n", arrCopy)     // [100 2 3]
    
    // 3. 切片
    slice := []int{1, 2, 3}
    sliceRef := slice
    sliceRef[0] = 100
    fmt.Printf("原切片: %v\n", slice)     // [100 2 3]
    fmt.Printf("引用: %v\n", sliceRef)     // [100 2 3]
    
    // 4. 作用域示例
    x := "外层"
    if true {
        x := "内层"  // 遮蔽外层x
        fmt.Println(x)  // 内层
    }
    fmt.Println(x)  // 外层
    
    // 5. 循环变量作用域
    var funcs []func()
    for i := 0; i < 3; i++ {
        i := i  // 创建局部副本
        funcs = append(funcs, func() {
            fmt.Println(i)  // 0, 1, 2
        })
    }
    for _, f := range funcs {
        f()
    }
}
```

---

## 总结

### 字符串要点

1. **特点**：不可变、UTF-8编码、值类型
2. **操作**：使用strings包进行各种操作
3. **转换**：与字节切片和rune切片互转

### 数组要点

1. **特点**：固定长度、值类型、同类型元素
2. **使用**：实际开发中较少使用，多用切片

### 切片要点

1. **特点**：动态长度、引用类型、底层是数组
2. **操作**：append、copy、删除等
3. **注意**：共享底层数组的问题

### 作用域要点

1. **类型**：包级、函数级、代码块级
2. **遮蔽**：内层可以遮蔽外层变量
3. **循环变量**：注意闭包中的陷阱

### 最佳实践

1. **字符串**：使用strings包，大量拼接用Builder
2. **切片**：预分配容量，注意共享问题
3. **作用域**：最小化作用域，避免遮蔽
4. **循环变量**：在闭包中使用时创建局部副本

掌握字符串、数组、切片和作用域是Go语言编程的基础。在下一课中，我们将学习控制流和函数。