---
title: 8ã€Goè¯­è¨€é«˜çº§ï¼šå¹¶å‘æ§åˆ¶
date: 2026-01-06
description: æŒæ¡Selectè¯­å¥å’ŒåŒæ­¥åŸè¯­ï¼Œå®ç°å¤æ‚çš„å¹¶å‘æ§åˆ¶é€»è¾‘
---

# 8ã€Goè¯­è¨€é«˜çº§ï¼šå¹¶å‘æ§åˆ¶

æœ¬æ–‡æ¡£ä»‹ç»Goè¯­è¨€çš„å¹¶å‘æ§åˆ¶æœºåˆ¶ï¼ŒåŒ…æ‹¬Selectè¯­å¥ç”¨äºå¤šè·¯å¤ç”¨ï¼Œä»¥åŠå„ç§åŒæ­¥åŸè¯­ï¼ˆWaitGroupã€Mutexã€RWMutexã€Onceç­‰ï¼‰ç”¨äºåè°ƒgoroutineé—´çš„æ‰§è¡Œã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡selectè¯­å¥çš„å¤šè·¯å¤ç”¨
- âœ… å­¦ä¼šä½¿ç”¨WaitGroupç­‰å¾…goroutineå®Œæˆ
- âœ… æŒæ¡Mutexå’ŒRWMutexä¿æŠ¤å…±äº«èµ„æº
- âœ… ç†è§£Onceçš„å•æ¬¡æ‰§è¡Œæœºåˆ¶
- âœ… å®ç°å¤æ‚çš„å¹¶å‘æ§åˆ¶é€»è¾‘

---

## å‰ç½®çŸ¥è¯†

- **ç¬¬6è¯¾ï¼šå¹¶å‘åŸºç¡€** - ç†è§£goroutineçš„åŸºæœ¬æ¦‚å¿µ
- **ç¬¬7è¯¾ï¼šChannelé€šä¿¡** - æŒæ¡channelçš„åŸºæœ¬ä½¿ç”¨

---

## å››ã€Selectè¯­å¥

`select` è¯­å¥ç”¨äºåœ¨å¤šä¸ªchannelæ“ä½œä¸­é€‰æ‹©ä¸€ä¸ªå¯æ‰§è¡Œçš„æ“ä½œï¼Œæ˜¯å®ç°å¤æ‚å¹¶å‘é€»è¾‘çš„å…³é”®ã€‚

### 4.1 åŸºæœ¬è¯­æ³•

Selectè¯­å¥ç±»ä¼¼äºswitchï¼Œä½†æ¯ä¸ªcaseéƒ½æ˜¯ä¸€ä¸ªchannelæ“ä½œï¼š

```go
select {
case value := <-ch1:
    // å¤„ç†ch1çš„æ•°æ®
case ch2 <- value:
    // å‘ch2å‘é€æ•°æ®
case <-time.After(timeout):
    // è¶…æ—¶å¤„ç†
default:
    // å½“æ‰€æœ‰channeléƒ½ä¸å¯ç”¨æ—¶çš„é»˜è®¤æ“ä½œ
}
```

---

### 4.2 åŸºæœ¬ä½¿ç”¨

#### ç­‰å¾…ç¬¬ä¸€ä¸ªå¯ç”¨çš„channel

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    // goroutine 1: 1ç§’åå‘é€
    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "æ¥è‡ªch1"
    }()

    // goroutine 2: 2ç§’åå‘é€
    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "æ¥è‡ªch2"
    }()

    // selectä¼šç­‰å¾…ç¬¬ä¸€ä¸ªå¯ç”¨çš„channel
    select {
    case msg1 := <-ch1:
        fmt.Println("æ”¶åˆ°æ¥è‡ªch1:", msg1)
    case msg2 := <-ch2:
        fmt.Println("æ”¶åˆ°æ¥è‡ªch2:", msg2)
    }
}
```

#### éšæœºé€‰æ‹©

å½“å¤šä¸ªcaseåŒæ—¶å°±ç»ªæ—¶ï¼Œselectä¼šéšæœºé€‰æ‹©ä¸€ä¸ªæ‰§è¡Œï¼š

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string, 1)
    ch2 := make(chan string, 1)

    // ä¸¤ä¸ªchannelåŒæ—¶æœ‰æ•°æ®
    ch1 <- "æ¶ˆæ¯A"
    ch2 <- "æ¶ˆæ¯B"

    // å¤šæ¬¡æ‰§è¡Œï¼Œæ¯æ¬¡å¯èƒ½é€‰æ‹©ä¸åŒçš„channel
    for i := 0; i < 5; i++ {
        select {
        case msg1 := <-ch1:
            fmt.Printf("ç¬¬%dæ¬¡: æ”¶åˆ° %s\n", i+1, msg1)
            ch1 <- "æ¶ˆæ¯A"  // é‡æ–°å¡«å……
        case msg2 := <-ch2:
            fmt.Printf("ç¬¬%dæ¬¡: æ”¶åˆ° %s\n", i+1, msg2)
            ch2 <- "æ¶ˆæ¯B"  // é‡æ–°å¡«å……
        }
    }
}
```

---

### 4.3 éé˜»å¡æ“ä½œ

ä½¿ç”¨defaultåˆ†æ”¯å®ç°éé˜»å¡çš„channelæ“ä½œï¼š

```go
package main

import "fmt"

func main() {
    ch := make(chan int)

    // éé˜»å¡æ¥æ”¶
    select {
    case value := <-ch:
        fmt.Println("æ”¶åˆ°:", value)
    default:
        fmt.Println("æ²¡æœ‰æ•°æ®ï¼Œä¸é˜»å¡")
    }

    // éé˜»å¡å‘é€
    select {
    case ch <- 42:
        fmt.Println("å‘é€æˆåŠŸ")
    default:
        fmt.Println("æ— æ³•å‘é€ï¼Œä¸é˜»å¡")
    }
}
```

#### éé˜»å¡channelæ“ä½œå‡½æ•°

```go
package main

import "fmt"

// éé˜»å¡æ¥æ”¶
func tryReceive(ch <-chan int) (int, bool) {
    select {
    case value := <-ch:
        return value, true
    default:
        return 0, false
    }
}

// éé˜»å¡å‘é€
func trySend(ch chan<- int, value int) bool {
    select {
    case ch <- value:
        return true
    default:
        return false
    }
}

func main() {
    ch := make(chan int, 1)

    // æµ‹è¯•æ¥æ”¶
    if value, ok := tryReceive(ch); ok {
        fmt.Println("æ”¶åˆ°:", value)
    } else {
        fmt.Println("æ²¡æœ‰æ•°æ®")
    }

    // å‘é€æ•°æ®
    ch <- 42

    // å†æ¬¡æµ‹è¯•æ¥æ”¶
    if value, ok := tryReceive(ch); ok {
        fmt.Println("æ”¶åˆ°:", value)
    } else {
        fmt.Println("æ²¡æœ‰æ•°æ®")
    }
}
```

---

### 4.4 è¶…æ—¶å¤„ç†

ä½¿ç”¨selectå’Œtime.Afterå®ç°è¶…æ—¶ï¼š

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan string)

    // å¯åŠ¨goroutineå‘é€æ•°æ®
    go func() {
        time.Sleep(3 * time.Second)
        ch <- "æ•°æ®"
    }()

    // ç­‰å¾…æ•°æ®æˆ–è¶…æ—¶
    select {
    case msg := <-ch:
        fmt.Println("æ”¶åˆ°:", msg)
    case <-time.After(2 * time.Second):
        fmt.Println("è¶…æ—¶äº†ï¼")
    }
}
```

#### å¸¦è¶…æ—¶çš„HTTPè¯·æ±‚

```go
package main

import (
    "fmt"
    "net/http"
    "time"
)

func fetchWithTimeout(url string, timeout time.Duration) (*http.Response, error) {
    ch := make(chan *http.Response)
    errCh := make(chan error)

    go func() {
        resp, err := http.Get(url)
        if err != nil {
            errCh <- err
            return
        }
        ch <- resp
    }()

    select {
    case resp := <-ch:
        return resp, nil
    case err := <-errCh:
        return nil, err
    case <-time.After(timeout):
        return nil, fmt.Errorf("è¯·æ±‚è¶…æ—¶")
    }
}

func main() {
    url := "https://httpbin.org/delay/1"
    timeout := 2 * time.Second

    resp, err := fetchWithTimeout(url, timeout)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        return
    }
    defer resp.Body.Close()

    fmt.Println("è¯·æ±‚æˆåŠŸ:", resp.Status)
}
```

---

### 4.5 å¤šè·¯å¤ç”¨

å¤„ç†å¤šä¸ªchannelçš„å¤æ‚é€»è¾‘ï¼š

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)

    // å¯åŠ¨ç”Ÿäº§è€…1
    go func() {
        for i := 0; i < 5; i++ {
            ch1 <- i
            time.Sleep(200 * time.Millisecond)
        }
        close(ch1)
    }()

    // å¯åŠ¨ç”Ÿäº§è€…2
    go func() {
        for i := 10; i < 15; i++ {
            ch2 <- i
            time.Sleep(300 * time.Millisecond)
        }
        close(ch2)
    }()

    // ä½¿ç”¨selectå¤„ç†å¤šä¸ªchannel
    for {
        select {
        case val, ok := <-ch1:
            if !ok {
                ch1 = nil  // è®¾ç½®ä¸ºnilï¼Œåœæ­¢ç›‘å¬
                fmt.Println("ch1 å·²å…³é—­")
            } else {
                fmt.Printf("ch1: %d\n", val)
            }
        case val, ok := <-ch2:
            if !ok {
                ch2 = nil  // è®¾ç½®ä¸ºnilï¼Œåœæ­¢ç›‘å¬
                fmt.Println("ch2 å·²å…³é—­")
            } else {
                fmt.Printf("ch2: %d\n", val)
            }
        }

        // å¦‚æœä¸¤ä¸ªchanneléƒ½å…³é—­äº†ï¼Œé€€å‡º
        if ch1 == nil && ch2 == nil {
            break
        }
    }

    fmt.Println("æ‰€æœ‰channeléƒ½å·²å…³é—­")
}
```

#### åŠ¨æ€channelç®¡ç†

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Printf("Worker %d å¤„ç†ä»»åŠ¡ %d\n", id, job)
        time.Sleep(500 * time.Millisecond)
        results <- job * 2
    }
    fmt.Printf("Worker %d é€€å‡º\n", id)
}

func main() {
    const numJobs = 10
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)

    // å¯åŠ¨3ä¸ªworker
    for w := 1; w <= 3; w++ {
        go worker(w, jobs, results)
    }

    // å‘é€ä»»åŠ¡
    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    close(jobs)

    // æ”¶é›†ç»“æœï¼Œä½¿ç”¨selectå¤„ç†è¶…æ—¶
    timeout := time.After(10 * time.Second)
    jobCount := 0

    for jobCount < numJobs {
        select {
        case result := <-results:
            fmt.Printf("ç»“æœ: %d\n", result)
            jobCount++
        case <-timeout:
            fmt.Println("å¤„ç†è¶…æ—¶")
            return
        }
    }

    fmt.Println("æ‰€æœ‰ä»»åŠ¡å®Œæˆ")
}
```

---

## äº”ã€åŒæ­¥åŸè¯­

Goè¯­è¨€æä¾›äº†å¤šç§åŒæ­¥åŸè¯­æ¥åè°ƒgoroutineé—´çš„æ‰§è¡Œã€‚

### 5.1 WaitGroup

WaitGroupç”¨äºç­‰å¾…ä¸€ç»„goroutineå®Œæˆï¼š

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()  // å®Œæˆæ—¶é€šçŸ¥WaitGroup

    fmt.Printf("Worker %d å¼€å§‹å·¥ä½œ\n", id)
    time.Sleep(1 * time.Second)
    fmt.Printf("Worker %d å®Œæˆå·¥ä½œ\n", id)
}

func main() {
    var wg sync.WaitGroup

    // å¯åŠ¨3ä¸ªgoroutine
    for i := 1; i <= 3; i++ {
        wg.Add(1)  // å¢åŠ è®¡æ•°
        go worker(i, &wg)
    }

    wg.Wait()  // é˜»å¡ç›´åˆ°æ‰€æœ‰goroutineå®Œæˆ
    fmt.Println("æ‰€æœ‰å·¥ä½œå®Œæˆï¼")
}
```

#### WaitGroupçš„å¸¸è§ç”¨æ³•

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type TaskManager struct {
    wg sync.WaitGroup
}

func (tm *TaskManager) AddTask(task func()) {
    tm.wg.Add(1)
    go func() {
        defer tm.wg.Done()
        task()
    }()
}

func (tm *TaskManager) Wait() {
    tm.wg.Wait()
}

func main() {
    tm := &TaskManager{}

    // æ·»åŠ å¤šä¸ªä»»åŠ¡
    for i := 1; i <= 5; i++ {
        id := i
        tm.AddTask(func() {
            fmt.Printf("æ‰§è¡Œä»»åŠ¡ %d\n", id)
            time.Sleep(time.Duration(id) * 100 * time.Millisecond)
        })
    }

    fmt.Println("ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ...")
    tm.Wait()
    fmt.Println("æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆ")
}
```

---

### 5.2 Mutexï¼ˆäº’æ–¥é”ï¼‰

Mutexç”¨äºä¿æŠ¤å…±äº«èµ„æºï¼Œé˜²æ­¢ç«æ€æ¡ä»¶ï¼š

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type SafeCounter struct {
    mu    sync.Mutex
    value int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()  // ä½¿ç”¨deferç¡®ä¿é”ä¼šè¢«é‡Šæ”¾
    c.value++
}

func (c *SafeCounter) GetValue() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func (c *SafeCounter) Reset() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value = 0
}

func main() {
    counter := SafeCounter{}
    var wg sync.WaitGroup

    // å¯åŠ¨å¤šä¸ªgoroutineå¹¶å‘è®¿é—®
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }

    wg.Wait()
    fmt.Println("æœ€ç»ˆå€¼:", counter.GetValue())  // æ€»æ˜¯1000
}
```

#### é¿å…æ­»é”

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

// é”™è¯¯çš„åšæ³•ï¼šå¯èƒ½å¯¼è‡´æ­»é”
func badLockExample() {
    var mu1, mu2 sync.Mutex

    go func() {
        mu1.Lock()
        time.Sleep(10 * time.Millisecond)  // æ¨¡æ‹Ÿå·¥ä½œ
        mu2.Lock()  // è¿™é‡Œå¯èƒ½æ­»é”
        fmt.Println("Goroutine 1 å®Œæˆ")
        mu2.Unlock()
        mu1.Unlock()
    }()

    go func() {
        mu2.Lock()
        time.Sleep(10 * time.Millisecond)  // æ¨¡æ‹Ÿå·¥ä½œ
        mu1.Lock()  // è¿™é‡Œå¯èƒ½æ­»é”
        fmt.Println("Goroutine 2 å®Œæˆ")
        mu1.Unlock()
        mu2.Unlock()
    }()

    time.Sleep(1 * time.Second)
}

// æ­£ç¡®çš„åšæ³•ï¼šå›ºå®šé”çš„è·å–é¡ºåº
func goodLockExample() {
    var mu1, mu2 sync.Mutex

    go func() {
        mu1.Lock()  // å…ˆè·å–mu1
        defer mu1.Unlock()

        time.Sleep(10 * time.Millisecond)

        mu2.Lock()  // å†è·å–mu2
        defer mu2.Unlock()

        fmt.Println("Goroutine 1 å®Œæˆ")
    }()

    go func() {
        mu1.Lock()  // å…ˆè·å–mu1
        defer mu1.Unlock()

        time.Sleep(10 * time.Millisecond)

        mu2.Lock()  // å†è·å–mu2
        defer mu2.Unlock()

        fmt.Println("Goroutine 2 å®Œæˆ")
    }()

    time.Sleep(1 * time.Second)
}

func main() {
    fmt.Println("=== æ¼”ç¤ºæ­»é”é£é™©ï¼ˆæ³¨é‡Šæ‰ä»¥é¿å…æ­»é”ï¼‰===")
    // badLockExample()  // å¯èƒ½æ­»é”

    fmt.Println("=== æ­£ç¡®çš„é”ä½¿ç”¨æ–¹å¼ ===")
    goodLockExample()
}
```

---

### 5.3 RWMutexï¼ˆè¯»å†™é”ï¼‰

RWMutexå…è®¸å¤šä¸ªè¯»æ“ä½œæˆ–ä¸€ä¸ªå†™æ“ä½œï¼Œæé«˜å¹¶å‘æ€§èƒ½ï¼š

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type SafeMap struct {
    mu   sync.RWMutex
    data map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]int),
    }
}

func (m *SafeMap) Read(key string) (int, bool) {
    m.mu.RLock()  // è¯»é”ï¼šå…è®¸å¤šä¸ªgoroutineåŒæ—¶è¯»å–
    defer m.mu.RUnlock()
    value, exists := m.data[key]
    return value, exists
}

func (m *SafeMap) Write(key string, value int) {
    m.mu.Lock()  // å†™é”ï¼šåªå…è®¸ä¸€ä¸ªgoroutineå†™å…¥
    defer m.mu.Unlock()
    m.data[key] = value
}

func (m *SafeMap) Delete(key string) {
    m.mu.Lock()
    defer m.mu.Unlock()
    delete(m.data, key)
}

func main() {
    m := NewSafeMap()
    var wg sync.WaitGroup

    // å¯åŠ¨å¤šä¸ªå†™goroutine
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            m.Write(fmt.Sprintf("key%d", id), id)
            time.Sleep(10 * time.Millisecond)
        }(i)
    }

    // å¯åŠ¨å¤šä¸ªè¯»goroutine
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 5; j++ {
                if value, exists := m.Read(fmt.Sprintf("key%d", j)); exists {
                    fmt.Printf("Reader %d: key%d = %d\n", id, j, value)
                }
                time.Sleep(5 * time.Millisecond)
            }
        }(i)
    }

    wg.Wait()
    fmt.Println("æ‰€æœ‰æ“ä½œå®Œæˆ")
}
```

#### è¯»å†™é”çš„æ€§èƒ½ä¼˜åŠ¿

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Counter struct {
    mu    sync.Mutex
    rwmu  sync.RWMutex
    value int
}

// ä½¿ç”¨æ™®é€šé”
func (c *Counter) ReadWithMutex() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    time.Sleep(1 * time.Millisecond)  // æ¨¡æ‹Ÿè¯»å–æ—¶é—´
    return c.value
}

// ä½¿ç”¨è¯»å†™é”
func (c *Counter) ReadWithRWMutex() int {
    c.rwmu.RLock()
    defer c.rwmu.RUnlock()
    time.Sleep(1 * time.Millisecond)  // æ¨¡æ‹Ÿè¯»å–æ—¶é—´
    return c.value
}

func benchmark(name string, fn func(), iterations int) {
    start := time.Now()
    for i := 0; i < iterations; i++ {
        fn()
    }
    elapsed := time.Since(start)
    fmt.Printf("%s: %v\n", name, elapsed)
}

func main() {
    counter := &Counter{value: 42}
    const numReaders = 100
    const iterations = 50

    fmt.Println("=== æ™®é€šé” vs è¯»å†™é”æ€§èƒ½å¯¹æ¯” ===")

    // æµ‹è¯•æ™®é€šé”
    var wg1 sync.WaitGroup
    start1 := time.Now()
    for i := 0; i < numReaders; i++ {
        wg1.Add(1)
        go func() {
            defer wg1.Done()
            for j := 0; j < iterations; j++ {
                counter.ReadWithMutex()
            }
        }()
    }
    wg1.Wait()
    fmt.Printf("æ™®é€šé”: %v\n", time.Since(start1))

    // æµ‹è¯•è¯»å†™é”
    var wg2 sync.WaitGroup
    start2 := time.Now()
    for i := 0; i < numReaders; i++ {
        wg2.Add(1)
        go func() {
            defer wg2.Done()
            for j := 0; j < iterations; j++ {
                counter.ReadWithRWMutex()
            }
        }()
    }
    wg2.Wait()
    fmt.Printf("è¯»å†™é”: %v\n", time.Since(start2))
}
```

---

### 5.4 Once

Onceç¡®ä¿æŸä¸ªæ“ä½œåªæ‰§è¡Œä¸€æ¬¡ï¼š

```go
package main

import (
    "fmt"
    "sync"
)

var once sync.Once

func initialize() {
    fmt.Println("åˆå§‹åŒ–æ“ä½œï¼ˆåªä¼šæ‰§è¡Œä¸€æ¬¡ï¼‰")
    // è¿™é‡Œå¯ä»¥æ”¾ä¸€äº›åˆå§‹åŒ–é€»è¾‘ï¼Œæ¯”å¦‚ï¼š
    // - è¿æ¥æ•°æ®åº“
    // - åŠ è½½é…ç½®æ–‡ä»¶
    // - åˆå§‹åŒ–å…¨å±€å˜é‡
}

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()

    // å¤šä¸ªgoroutineè°ƒç”¨ï¼Œä½†initializeåªæ‰§è¡Œä¸€æ¬¡
    once.Do(initialize)

    fmt.Printf("Worker %d æ­£åœ¨å·¥ä½œ\n", id)
}

func main() {
    var wg sync.WaitGroup

    // å¯åŠ¨å¤šä¸ªworker
    for i := 1; i <= 10; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }

    wg.Wait()
    fmt.Println("æ‰€æœ‰workerå®Œæˆ")
}
```

#### Onceçš„å®é™…åº”ç”¨

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Database struct {
    once sync.Once
    conn string
}

func (db *Database) Connect() {
    db.once.Do(func() {
        fmt.Println("è¿æ¥æ•°æ®åº“...")
        time.Sleep(100 * time.Millisecond)  // æ¨¡æ‹Ÿè¿æ¥æ—¶é—´
        db.conn = "æ•°æ®åº“è¿æ¥å·²å»ºç«‹"
        fmt.Println("æ•°æ®åº“è¿æ¥æˆåŠŸ")
    })
}

func (db *Database) Query(sql string) string {
    if db.conn == "" {
        db.Connect()
    }
    return fmt.Sprintf("æ‰§è¡ŒæŸ¥è¯¢: %s -> %s", sql, db.conn)
}

func main() {
    db := &Database{}
    var wg sync.WaitGroup

    // å¤šä¸ªgoroutineåŒæ—¶è®¿é—®æ•°æ®åº“
    queries := []string{
        "SELECT * FROM users",
        "SELECT * FROM products",
        "SELECT * FROM orders",
        "INSERT INTO logs VALUES (...)",
        "UPDATE users SET ...",
    }

    for i, query := range queries {
        wg.Add(1)
        go func(id int, q string) {
            defer wg.Done()
            result := db.Query(q)
            fmt.Printf("æŸ¥è¯¢ %d: %s\n", id, result)
        }(i, query)
    }

    wg.Wait()
    fmt.Println("æ‰€æœ‰æŸ¥è¯¢å®Œæˆ")
}
```

---

### 5.5 æ¡ä»¶å˜é‡ï¼ˆCondï¼‰

Condç”¨äºgoroutineé—´çš„æ¡ä»¶ç­‰å¾…ï¼š

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Queue struct {
    mu      sync.Mutex
    cond    *sync.Cond
    items   []int
    maxSize int
}

func NewQueue(maxSize int) *Queue {
    q := &Queue{
        items:   make([]int, 0, maxSize),
        maxSize: maxSize,
    }
    q.cond = sync.NewCond(&q.mu)
    return q
}

func (q *Queue) Put(item int) {
    q.mu.Lock()
    defer q.mu.Unlock()

    // ç­‰å¾…é˜Ÿåˆ—æœ‰ç©ºé—´
    for len(q.items) == q.maxSize {
        q.cond.Wait()  // ç­‰å¾…æ¶ˆè´¹
    }

    q.items = append(q.items, item)
    fmt.Printf("æ”¾å…¥: %d, å½“å‰é˜Ÿåˆ—: %v\n", item, q.items)

    q.cond.Signal()  // é€šçŸ¥ç­‰å¾…çš„æ¶ˆè´¹è€…
}

func (q *Queue) Get() int {
    q.mu.Lock()
    defer q.mu.Unlock()

    // ç­‰å¾…é˜Ÿåˆ—æœ‰å…ƒç´ 
    for len(q.items) == 0 {
        q.cond.Wait()  // ç­‰å¾…ç”Ÿäº§
    }

    item := q.items[0]
    q.items = q.items[1:]
    fmt.Printf("å–å‡º: %d, å½“å‰é˜Ÿåˆ—: %v\n", item, q.items)

    q.cond.Signal()  // é€šçŸ¥ç­‰å¾…çš„ç”Ÿäº§è€…
    return item
}

func main() {
    q := NewQueue(3)

    // å¯åŠ¨æ¶ˆè´¹è€…
    go func() {
        for i := 0; i < 5; i++ {
            item := q.Get()
            time.Sleep(200 * time.Millisecond)
        }
    }()

    // å¯åŠ¨ç”Ÿäº§è€…
    go func() {
        for i := 1; i <= 5; i++ {
            q.Put(i)
            time.Sleep(100 * time.Millisecond)
        }
    }()

    time.Sleep(3 * time.Second)
}
```

---

## æ€»ç»“

### Selectè¯­å¥

1. **åŸºæœ¬è¯­æ³•**ï¼š`select { case ... }`
2. **é˜»å¡ç­‰å¾…**ï¼šç­‰å¾…ç¬¬ä¸€ä¸ªå¯ç”¨çš„channel
3. **éšæœºé€‰æ‹©**ï¼šå¤šä¸ªcaseåŒæ—¶å°±ç»ªæ—¶éšæœºé€‰æ‹©
4. **éé˜»å¡æ“ä½œ**ï¼šä½¿ç”¨`default`åˆ†æ”¯
5. **è¶…æ—¶å¤„ç†**ï¼šé…åˆ`time.After`å®ç°è¶…æ—¶
6. **å¤šè·¯å¤ç”¨**ï¼šåŒæ—¶ç›‘å¬å¤šä¸ªchannel

### åŒæ­¥åŸè¯­

1. **WaitGroup**ï¼š
   - ç­‰å¾…ä¸€ç»„goroutineå®Œæˆ
   - `Add()`å¢åŠ è®¡æ•°ï¼Œ`Done()`å‡å°‘è®¡æ•°ï¼Œ`Wait()`ç­‰å¾…

2. **Mutex**ï¼š
   - äº’æ–¥é”ï¼Œä¿æŠ¤ä¸´ç•ŒåŒº
   - `Lock()`è·å–é”ï¼Œ`Unlock()`é‡Šæ”¾é”
   - ä½¿ç”¨deferç¡®ä¿é”é‡Šæ”¾

3. **RWMutex**ï¼š
   - è¯»å†™é”ï¼Œæé«˜è¯»å¹¶å‘æ€§èƒ½
   - `RLock()`è¯»é”ï¼Œ`RUnlock()`é‡Šæ”¾è¯»é”
   - `Lock()`å†™é”ï¼Œ`Unlock()`é‡Šæ”¾å†™é”

4. **Once**ï¼š
   - ç¡®ä¿æ“ä½œåªæ‰§è¡Œä¸€æ¬¡
   - å¸¸ç”¨äºåˆå§‹åŒ–æ“ä½œ

5. **Cond**ï¼š
   - æ¡ä»¶å˜é‡ï¼Œgoroutineé—´çš„æ¡ä»¶ç­‰å¾…
   - `Wait()`ç­‰å¾…æ¡ä»¶ï¼Œ`Signal()`é€šçŸ¥ä¸€ä¸ªï¼Œ`Broadcast()`é€šçŸ¥æ‰€æœ‰

### æœ€ä½³å®è·µ

1. **é€‰æ‹©åˆé€‚çš„åŒæ­¥åŸè¯­**ï¼š
   - éœ€è¦ç­‰å¾…goroutineå®Œæˆï¼šWaitGroup
   - ä¿æŠ¤å…±äº«èµ„æºï¼šMutex/RWMutex
   - å•æ¬¡åˆå§‹åŒ–ï¼šOnce
   - æ¡ä»¶ç­‰å¾…ï¼šCond
   - goroutineé€šä¿¡ï¼šChannel + Select

2. **é¿å…æ­»é”**ï¼š
   - å›ºå®šé”çš„è·å–é¡ºåº
   - é¿å…é€’å½’é”
   - ä½¿ç”¨deferé‡Šæ”¾é”

3. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - è¯»å¤šå†™å°‘æ—¶ä½¿ç”¨RWMutex
   - é¿å…è¿‡åº¦åŒæ­¥
   - ä½¿ç”¨channelä»£æ›¿é”ï¼ˆCSPæ¨¡å‹ï¼‰

æŒæ¡è¿™äº›å¹¶å‘æ§åˆ¶æœºåˆ¶åï¼Œä½ å°±å¯ä»¥å®ç°å¤æ‚çš„å¹¶å‘é€»è¾‘äº†ã€‚åœ¨ä¸‹ä¸€è¯¾ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ å¸¸è§çš„å¹¶å‘æ¨¡å¼å’Œå¹¶å‘å®‰å…¨çš„æœ€ä½³å®è·µã€‚