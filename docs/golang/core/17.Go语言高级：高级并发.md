---
title: 17、Go语言高级：高级并发
date: 2026-01-06
description: 掌握Context包的高级用法和综合并发编程示例
---

# 16、Go语言高级：高级并发

本文档介绍Go语言并发编程的高级主题，包括Context包的深入使用，以及综合的并发编程示例。掌握这些高级概念后，你将能够构建复杂的并发系统。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 深入理解Context包的使用场景
- ✅ 掌握Context的取消、超时和值传递机制
- ✅ 构建复杂的并发系统
- ✅ 实现带超时的并发操作
- ✅ 处理goroutine的生命周期管理

---

## 前置知识

- **第6课：并发基础** - 理解goroutine的基本概念
- **第7课：Channel通信** - 掌握channel的基本使用
- **第8课：并发控制** - 掌握Select和同步原语
- **第9课：并发模式与安全** - 掌握并发模式和安全原则

---

## 八、Context包详解

Context包是Go语言中用于控制goroutine生命周期的重要工具。它提供了一种优雅的方式来处理取消信号、超时和请求范围的值传递。

### 8.1 Context接口

```go
type Context interface {
    // 返回context被取消的时间，如果没有被取消则返回nil
    Deadline() (deadline time.Time, ok bool)

    // 返回一个channel，当context被取消时该channel会被关闭
    Done() <-chan struct{}

    // 返回context被取消的原因
    Err() error

    // 返回与context关联的key对应的值
    Value(key interface{}) interface{}
}
```

---

### 8.2 创建Context

#### Background() 和 TODO()

```go
package main

import (
    "context"
    "fmt"
)

func main() {
    // Background() 返回一个空的context，通常作为根context
    bg := context.Background()
    fmt.Printf("Background context: %T\n", bg)

    // TODO() 也返回一个空的context，在不确定使用哪个context时使用
    todo := context.TODO()
    fmt.Printf("TODO context: %T\n", todo)

    // 它们在功能上是等价的，主要用于代码文档目的
    fmt.Printf("Background == TODO: %v\n", bg == todo) // false，但功能相同
}
```

#### WithCancel()

创建可取消的context：

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, id int) {
    for {
        select {
        case <-ctx.Done():
            fmt.Printf("Worker %d: 收到取消信号: %v\n", id, ctx.Err())
            return
        default:
            fmt.Printf("Worker %d 正在工作...\n", id)
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    // 创建可取消的context
    ctx, cancel := context.WithCancel(context.Background())

    // 启动多个worker
    for i := 1; i <= 3; i++ {
        go worker(ctx, i)
    }

    // 让worker工作2秒，然后取消
    time.Sleep(2 * time.Second)
    fmt.Println("发送取消信号...")
    cancel()

    // 等待worker退出
    time.Sleep(1 * time.Second)
    fmt.Println("程序结束")
}
```

#### WithTimeout()

创建带超时的context：

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func longRunningTask(ctx context.Context, name string) {
    fmt.Printf("%s: 开始执行任务\n", name)

    select {
    case <-time.After(3 * time.Second):
        fmt.Printf("%s: 任务完成\n", name)
    case <-ctx.Done():
        fmt.Printf("%s: 任务被取消: %v\n", name, ctx.Err())
        return
    }
}

func main() {
    // 创建2秒超时的context
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel() // 确保资源清理

    go longRunningTask(ctx, "任务1")
    go longRunningTask(ctx, "任务2")

    // 等待超时
    <-ctx.Done()
    fmt.Printf("Context取消原因: %v\n", ctx.Err())
}
```

#### WithDeadline()

创建带截止时间的context：

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func taskWithDeadline(ctx context.Context, name string) {
    fmt.Printf("%s: 开始执行\n", name)

    // 检查截止时间
    if deadline, ok := ctx.Deadline(); ok {
        fmt.Printf("%s: 截止时间: %v\n", name, deadline)
        fmt.Printf("%s: 剩余时间: %v\n", name, time.Until(deadline))
    }

    select {
    case <-time.After(5 * time.Second):
        fmt.Printf("%s: 任务完成\n", name)
    case <-ctx.Done():
        fmt.Printf("%s: 被取消: %v\n", name, ctx.Err())
    }
}

func main() {
    // 设置5秒后的截止时间
    deadline := time.Now().Add(3 * time.Second)
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()

    go taskWithDeadline(ctx, "任务")

    // 等待context完成
    <-ctx.Done()
    fmt.Printf("主程序结束: %v\n", ctx.Err())
}
```

#### WithValue()

创建带值的context：

```go
package main

import (
    "context"
    "fmt"
)

type key string

const (
    userIDKey   key = "userID"
    requestIDKey key = "requestID"
    userNameKey  key = "userName"
)

func processRequest(ctx context.Context) {
    // 从context中获取值
    userID := ctx.Value(userIDKey)
    requestID := ctx.Value(requestIDKey)
    userName := ctx.Value(userNameKey)

    fmt.Printf("处理请求 - 用户ID: %v, 请求ID: %v, 用户名: %v\n",
        userID, requestID, userName)
}

func middleware1(ctx context.Context) context.Context {
    // 添加用户信息
    return context.WithValue(ctx, userIDKey, 12345)
}

func middleware2(ctx context.Context) context.Context {
    // 添加请求信息
    return context.WithValue(ctx, requestIDKey, "req-abc-123")
}

func middleware3(ctx context.Context) context.Context {
    // 添加更多信息
    return context.WithValue(ctx, userNameKey, "张三")
}

func main() {
    // 创建基础context
    ctx := context.Background()

    // 通过中间件添加值
    ctx = middleware1(ctx)
    ctx = middleware2(ctx)
    ctx = middleware3(ctx)

    // 处理请求
    processRequest(ctx)

    // 演示值传递的继承性
    childCtx := context.WithValue(ctx, "tempKey", "临时值")
    fmt.Printf("子context中的临时值: %v\n", childCtx.Value("tempKey"))
    fmt.Printf("子context中的用户ID: %v\n", childCtx.Value(userIDKey))
}
```

---

### 8.3 Context的继承关系

Context支持链式继承，后代context会继承祖先的所有特性：

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func demonstrateInheritance() {
    // 根context
    rootCtx := context.Background()

    // 添加值
    ctx1 := context.WithValue(rootCtx, "level", 1)
    ctx1 = context.WithValue(ctx1, "name", "第一层")

    // 添加取消功能
    ctx2, cancel2 := context.WithCancel(ctx1)
    ctx2 = context.WithValue(ctx2, "level", 2)

    // 添加超时
    ctx3, cancel3 := context.WithTimeout(ctx2, 2*time.Second)
    ctx3 = context.WithValue(ctx3, "level", 3)

    // 子context继承所有父context的特性
    fmt.Printf("Level 3 - level: %v, name: %v\n",
        ctx3.Value("level"), ctx3.Value("name"))

    // 测试取消传播
    go func() {
        time.Sleep(1 * time.Second)
        fmt.Println("取消第二层context")
        cancel2() // 取消ctx2会影响所有后代
    }()

    select {
    case <-ctx3.Done():
        fmt.Printf("Context 3 被取消: %v\n", ctx3.Err())
    case <-time.After(3 * time.Second):
        fmt.Println("Context 3 超时")
        cancel3()
    }
}

func main() {
    demonstrateInheritance()
}
```

---

### 8.4 Context在实际开发中的应用

#### HTTP请求处理

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "time"
)

// HTTP处理器
func handler(w http.ResponseWriter, r *http.Request) {
    // 从HTTP请求创建context
    ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
    defer cancel()

    // 处理请求
    result := processRequest(ctx, r.URL.Path)
    fmt.Fprintf(w, "结果: %s\n", result)
}

func processRequest(ctx context.Context, path string) string {
    // 模拟数据库查询
    done := make(chan string)

    go func() {
        // 模拟耗时操作
        time.Sleep(2 * time.Second)
        done <- fmt.Sprintf("处理路径: %s", path)
    }()

    select {
    case result := <-done:
        return result
    case <-ctx.Done():
        return fmt.Sprintf("请求取消: %v", ctx.Err())
    }
}

func main() {
    http.HandleFunc("/", handler)

    fmt.Println("服务器启动在 :8080")
    http.ListenAndServe(":8080", nil)
}
```

#### 数据库连接池

```go
package main

import (
    "context"
    "database/sql"
    "fmt"
    "time"
)

type DBPool struct {
    db *sql.DB
}

func (p *DBPool) Query(ctx context.Context, query string) (*sql.Rows, error) {
    // 使用context控制查询超时
    return p.db.QueryContext(ctx, query)
}

func (p *DBPool) QueryWithRetry(ctx context.Context, query string, maxRetries int) (*sql.Rows, error) {
    for i := 0; i < maxRetries; i++ {
        rows, err := p.Query(ctx, query)
        if err == nil {
            return rows, nil
        }

        // 检查是否是context取消导致的错误
        if ctx.Err() != nil {
            return nil, ctx.Err()
        }

        fmt.Printf("查询失败，重试 %d/%d: %v\n", i+1, maxRetries, err)

        // 等待重试
        select {
        case <-time.After(time.Duration(i+1) * time.Second):
            // 继续重试
        case <-ctx.Done():
            return nil, ctx.Err()
        }
    }

    return nil, fmt.Errorf("查询失败，已重试 %d 次", maxRetries)
}

func main() {
    // 模拟数据库连接池
    pool := &DBPool{}

    // 创建带超时的context
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    // 执行查询
    rows, err := pool.QueryWithRetry(ctx, "SELECT * FROM users", 3)
    if err != nil {
        fmt.Printf("查询失败: %v\n", err)
        return
    }
    defer rows.Close()

    fmt.Println("查询成功")
}
```

---

## 九、综合并发示例

### 9.1 高并发Web服务器

```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "sync"
    "time"
)

type Server struct {
    server *http.Server
    wg     sync.WaitGroup
}

func NewServer(addr string) *Server {
    mux := http.NewServeMux()

    // 注册路由
    mux.HandleFunc("/work", handleWork)
    mux.HandleFunc("/health", handleHealth)
    mux.HandleFunc("/shutdown", handleShutdown)

    return &Server{
        server: &http.Server{
            Addr:    addr,
            Handler: mux,
        },
    }
}

func handleWork(w http.ResponseWriter, r *http.Request) {
    // 从请求创建context
    ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
    defer cancel()

    // 模拟工作
    result := doWork(ctx)
    fmt.Fprintf(w, "工作结果: %s\n", result)
}

func doWork(ctx context.Context) string {
    done := make(chan string)

    go func() {
        // 模拟耗时操作
        time.Sleep(2 * time.Second)
        done <- "工作完成"
    }()

    select {
    case result := <-done:
        return result
    case <-ctx.Done():
        return fmt.Sprintf("工作取消: %v", ctx.Err())
    }
}

func handleHealth(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    fmt.Fprint(w, "OK")
}

var shutdownChan = make(chan struct{})

func handleShutdown(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "正在关闭服务器...\n")
    close(shutdownChan)
}

func (s *Server) Start() error {
    fmt.Printf("服务器启动在 %s\n", s.server.Addr)
    return s.server.ListenAndServe()
}

func (s *Server) Shutdown(ctx context.Context) error {
    return s.server.Shutdown(ctx)
}

func main() {
    server := NewServer(":8080")

    // 启动服务器
    go func() {
        if err := server.Start(); err != http.ErrServerClosed {
            fmt.Printf("服务器错误: %v\n", err)
        }
    }()

    // 等待关闭信号
    <-shutdownChan

    // 优雅关闭
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    fmt.Println("正在关闭服务器...")
    if err := server.Shutdown(ctx); err != nil {
        fmt.Printf("关闭服务器失败: %v\n", err)
    } else {
        fmt.Println("服务器已关闭")
    }
}
```

---

### 9.2 分布式任务调度器

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// 任务定义
type Task struct {
    ID      int
    Payload interface{}
    Timeout time.Duration
}

// 任务结果
type TaskResult struct {
    TaskID int
    Result interface{}
    Error  error
}

// 任务调度器
type TaskScheduler struct {
    workers   int
    taskQueue chan Task
    results   chan TaskResult
    quit      chan struct{}
    wg        sync.WaitGroup
}

func NewTaskScheduler(workers int) *TaskScheduler {
    return &TaskScheduler{
        workers:   workers,
        taskQueue: make(chan Task, 100),
        results:   make(chan TaskResult, 100),
        quit:      make(chan struct{}),
    }
}

func (ts *TaskScheduler) Start() {
    for i := 0; i < ts.workers; i++ {
        ts.wg.Add(1)
        go ts.worker(i + 1)
    }

    // 启动结果处理goroutine
    ts.wg.Add(1)
    go ts.resultHandler()
}

func (ts *TaskScheduler) worker(id int) {
    defer ts.wg.Done()

    for {
        select {
        case task := <-ts.taskQueue:
            ts.processTask(id, task)
        case <-ts.quit:
            fmt.Printf("Worker %d 退出\n", id)
            return
        }
    }
}

func (ts *TaskScheduler) processTask(workerID int, task Task) {
    fmt.Printf("Worker %d 开始处理任务 %d\n", workerID, task.ID)

    // 创建任务专用的context
    ctx, cancel := context.WithTimeout(context.Background(), task.Timeout)
    defer cancel()

    // 执行任务
    done := make(chan TaskResult, 1)

    go func() {
        result := executeTask(task)
        done <- result
    }()

    select {
    case result := <-done:
        ts.results <- result
    case <-ctx.Done():
        ts.results <- TaskResult{
            TaskID: task.ID,
            Error:  ctx.Err(),
        }
    }
}

func executeTask(task Task) TaskResult {
    // 模拟任务执行
    time.Sleep(1 * time.Second)

    return TaskResult{
        TaskID: task.ID,
        Result: fmt.Sprintf("任务%d的结果", task.ID),
    }
}

func (ts *TaskScheduler) resultHandler() {
    defer ts.wg.Done()

    for result := range ts.results {
        if result.Error != nil {
            fmt.Printf("任务 %d 失败: %v\n", result.TaskID, result.Error)
        } else {
            fmt.Printf("任务 %d 成功: %v\n", result.TaskID, result.Result)
        }
    }
}

func (ts *TaskScheduler) Submit(task Task) {
    ts.taskQueue <- task
}

func (ts *TaskScheduler) Stop() {
    close(ts.quit)
    close(ts.taskQueue)
    ts.wg.Wait()
    close(ts.results)
}

func main() {
    // 创建调度器
    scheduler := NewTaskScheduler(3)
    scheduler.Start()

    // 提交任务
    for i := 1; i <= 10; i++ {
        task := Task{
            ID:      i,
            Payload: fmt.Sprintf("数据%d", i),
            Timeout: 2 * time.Second,
        }
        scheduler.Submit(task)
    }

    // 等待一段时间让任务执行
    time.Sleep(5 * time.Second)

    // 停止调度器
    scheduler.Stop()
    fmt.Println("调度器已停止")
}
```

---

### 9.3 实时数据处理管道

```go
package main

import (
    "context"
    "fmt"
    "sync"
    "time"
)

// 数据源
type DataSource struct {
    data chan int
    quit chan struct{}
}

func NewDataSource() *DataSource {
    return &DataSource{
        data: make(chan int, 10),
        quit: make(chan struct{}),
    }
}

func (ds *DataSource) Start(ctx context.Context) {
    go func() {
        ticker := time.NewTicker(500 * time.Millisecond)
        defer ticker.Stop()

        i := 1
        for {
            select {
            case <-ctx.Done():
                close(ds.data)
                return
            case <-ds.quit:
                close(ds.data)
                return
            case <-ticker.C:
                select {
                case ds.data <- i:
                    fmt.Printf("数据源生成: %d\n", i)
                    i++
                case <-ctx.Done():
                    close(ds.data)
                    return
                }
            }
        }
    }()
}

func (ds *DataSource) Stop() {
    close(ds.quit)
}

// 数据处理器
type Processor struct {
    input  <-chan int
    output chan int
}

func NewProcessor(input <-chan int) *Processor {
    return &Processor{
        input:  input,
        output: make(chan int, 10),
    }
}

func (p *Processor) Start(ctx context.Context) {
    go func() {
        defer close(p.output)

        for {
            select {
            case <-ctx.Done():
                return
            case data, ok := <-p.input:
                if !ok {
                    return
                }

                // 处理数据（这里是平方）
                processed := data * data

                select {
                case p.output <- processed:
                    fmt.Printf("处理器处理: %d -> %d\n", data, processed)
                case <-ctx.Done():
                    return
                }
            }
        }
    }()
}

// 数据消费者
type Consumer struct {
    input <-chan int
    wg    *sync.WaitGroup
}

func NewConsumer(input <-chan int, wg *sync.WaitGroup) *Consumer {
    return &Consumer{
        input: input,
        wg:    wg,
    }
}

func (c *Consumer) Start(ctx context.Context, id int) {
    c.wg.Add(1)
    go func() {
        defer c.wg.Done()

        for {
            select {
            case <-ctx.Done():
                fmt.Printf("消费者 %d 退出\n", id)
                return
            case data, ok := <-c.input:
                if !ok {
                    fmt.Printf("消费者 %d 完成\n", id)
                    return
                }
                fmt.Printf("消费者 %d 消费: %d\n", id, data)
                time.Sleep(200 * time.Millisecond)
            }
        }
    }()
}

func main() {
    // 创建context
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    var wg sync.WaitGroup

    // 创建数据源
    source := NewDataSource()
    source.Start(ctx)

    // 创建处理器
    processor := NewProcessor(source.data)
    processor.Start(ctx)

    // 创建多个消费者
    for i := 1; i <= 3; i++ {
        consumer := NewConsumer(processor.output, &wg)
        consumer.Start(ctx, i)
    }

    // 等待所有消费者完成或超时
    done := make(chan struct{})
    go func() {
        wg.Wait()
        close(done)
    }()

    select {
    case <-done:
        fmt.Println("所有任务完成")
    case <-ctx.Done():
        fmt.Printf("由于超时或取消而结束: %v\n", ctx.Err())
    }

    // 停止数据源
    source.Stop()
}
```

---

## 总结

### Context包

1. **Context接口**：提供Deadline()、Done()、Err()、Value()方法
2. **创建函数**：
   - `context.Background()`：根context
   - `context.TODO()`：不确定用哪个时使用
   - `context.WithCancel()`：可取消的context
   - `context.WithTimeout()`：带超时的context
   - `context.WithDeadline()`：带截止时间的context
   - `context.WithValue()`：带值的context
3. **继承关系**：子context继承父context的所有特性
4. **应用场景**：HTTP请求处理、数据库操作、任务取消等

### 综合并发编程

1. **Context在HTTP服务中的应用**：
   - 请求生命周期管理
   - 超时控制
   - 优雅关闭

2. **分布式任务调度**：
   - 任务队列管理
   - 工作池模式
   - 超时和取消处理

3. **数据流处理**：
   - 生产者-消费者模式
   - 数据处理管道
   - 并发安全的数据流

### 最佳实践

1. **Context使用原则**：
   - Context作为函数的第一个参数
   - 不要将Context存储在结构体中
   - Context是不可变的
   - 及时调用cancel函数

2. **并发系统设计**：
   - 使用Context管理goroutine生命周期
   - 实现优雅关闭机制
   - 处理超时和取消信号
   - 使用合适的并发模式

3. **性能和安全性**：
   - 避免goroutine泄漏
   - 合理设置超时时间
   - 使用select处理多路复用
   - 监控和调试并发程序

掌握Context和综合并发编程后，你已经具备了构建复杂、高性能Go并发系统的能力。这些高级概念将帮助你在实际项目中编写出更加健壮和高效的并发代码。