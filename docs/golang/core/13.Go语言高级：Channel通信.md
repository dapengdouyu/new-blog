---
title: 13、Go语言高级：Channel通信
date: 2026-01-06
description: 掌握Go语言的Channel通信机制，包括无缓冲和带缓冲Channel的使用
---

# 13、Go语言高级：Channel通信

本文档详细介绍Go语言的Channel通信机制。Channel是goroutine之间安全通信的管道，是Go并发编程的核心组件之一。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 理解Channel的基本概念和作用
- ✅ 掌握无缓冲Channel的使用
- ✅ 掌握带缓冲Channel的使用
- ✅ 了解Channel的方向限制
- ✅ 掌握Channel的关闭和遍历
- ✅ 理解Channel的阻塞特性

---

## 前置知识

- **第6课：并发基础** - 理解goroutine的概念和基本使用

---

## 三、Channel（通道）

Channel是goroutine之间通信的管道，用于安全地传递数据。Go的哲学是："不要通过共享内存来通信，而要通过通信来共享内存"。

### 3.1 基本概念

Channel提供了一种机制：
- **类型安全**：只能传递指定类型的数据
- **同步机制**：发送和接收操作都是原子的
- **阻塞特性**：无缓冲channel会阻塞发送/接收操作

#### Channel的类型

```go
// 无缓冲channel（同步）
ch1 := make(chan int)

// 带缓冲channel（异步）
ch2 := make(chan string, 10)

// 只发送channel
sendOnly := make(chan<- int)

// 只接收channel
receiveOnly := make(<-chan int)
```

---

### 3.2 无缓冲Channel

无缓冲channel（unbuffered channel）没有容量，发送操作会阻塞直到有goroutine接收，接收操作会阻塞直到有goroutine发送。

#### 基本使用

```go
package main

import "fmt"

func main() {
    // 创建无缓冲channel
    ch := make(chan string)

    // 在goroutine中发送数据
    go func() {
        ch <- "Hello from channel!"
    }()

    // 主goroutine接收数据（阻塞直到有数据）
    msg := <-ch
    fmt.Println(msg)
}
```

#### 同步特性

无缓冲channel实现了goroutine之间的同步：

```go
package main

import (
    "fmt"
    "time"
)

func worker(id int, ch chan string) {
    fmt.Printf("Worker %d: 等待任务...\n", id)

    // 接收任务（阻塞）
    task := <-ch
    fmt.Printf("Worker %d: 收到任务 %s\n", id, task)

    // 模拟工作
    time.Sleep(500 * time.Millisecond)
    fmt.Printf("Worker %d: 任务完成\n", id)
}

func main() {
    ch := make(chan string)

    // 启动worker
    go worker(1, ch)
    go worker(2, ch)

    // 发送任务
    ch <- "任务A"
    ch <- "任务B"

    time.Sleep(1 * time.Second)
}
```

---

### 3.3 带缓冲Channel

带缓冲channel（buffered channel）有固定容量，可以存储多个值而不阻塞。

#### 基本使用

```go
package main

import "fmt"

func main() {
    // 创建带缓冲的channel（容量为2）
    ch := make(chan int, 2)

    // 可以连续发送2个值而不阻塞
    ch <- 1
    ch <- 2

    // 第三个发送会阻塞（因为缓冲区满了）
    // ch <- 3  // 如果取消注释，会阻塞

    // 接收数据
    fmt.Println(<-ch)  // 1
    fmt.Println(<-ch)  // 2

    // 现在可以再发送一个值
    ch <- 3
    fmt.Println(<-ch)  // 3
}
```

#### 缓冲区的意义

```go
package main

import (
    "fmt"
    "time"
)

func producer(ch chan int) {
    for i := 1; i <= 5; i++ {
        fmt.Printf("生产: %d\n", i)
        ch <- i
        time.Sleep(100 * time.Millisecond)
    }
    close(ch)
}

func consumer(id int, ch chan int) {
    for value := range ch {
        fmt.Printf("消费者 %d 消费: %d\n", id, value)
        time.Sleep(200 * time.Millisecond)
    }
}

func main() {
    // 带缓冲channel可以减少阻塞
    ch := make(chan int, 3)

    go producer(ch)
    go consumer(1, ch)
    go consumer(2, ch)

    time.Sleep(2 * time.Second)
}
```

---

### 3.4 Channel的方向

Channel可以限制为只发送或只接收，提高类型安全性。

#### 只发送和只接收Channel

```go
package main

import "fmt"

// 只发送channel
func sendOnly(ch chan<- int) {
    ch <- 42
    // <-ch  // 错误！不能从只发送channel接收
}

// 只接收channel
func receiveOnly(ch <-chan int) {
    value := <-ch
    fmt.Println("收到:", value)
    // ch <- 1  // 错误！不能向只接收channel发送
}

func main() {
    ch := make(chan int)

    go sendOnly(ch)
    receiveOnly(ch)
}
```

#### 函数参数中的应用

```go
package main

import "fmt"

type Producer struct {
    data []int
}

func (p *Producer) Produce(ch chan<- int) {
    defer close(ch)
    for _, v := range p.data {
        ch <- v
    }
}

type Consumer struct {
    id int
}

func (c *Consumer) Consume(ch <-chan int) {
    for value := range ch {
        fmt.Printf("消费者 %d: %d\n", c.id, value)
    }
}

func main() {
    producer := &Producer{data: []int{1, 2, 3, 4, 5}}
    ch := make(chan int, 3)

    consumer1 := &Consumer{id: 1}
    consumer2 := &Consumer{id: 2}

    go producer.Produce(ch)
    go consumer1.Consume(ch)
    go consumer2.Consume(ch)

    // 等待一段时间
    time.Sleep(1 * time.Second)
}
```

---

### 3.5 Channel的关闭

关闭channel表示不再发送数据，但仍可以接收剩余数据。

#### 基本关闭操作

```go
package main

import "fmt"

func main() {
    ch := make(chan int, 3)

    // 发送数据
    ch <- 1
    ch <- 2
    ch <- 3

    close(ch)  // 关闭channel

    // 关闭后仍可以接收剩余的值
    fmt.Println(<-ch)  // 1
    fmt.Println(<-ch)  // 2
    fmt.Println(<-ch)  // 3

    // 继续接收会得到零值和false
    value, ok := <-ch
    fmt.Println(value, ok)  // 0 false
}
```

#### 检测Channel是否关闭

```go
package main

import "fmt"

func sender(ch chan int) {
    for i := 1; i <= 5; i++ {
        ch <- i
    }
    close(ch)  // 发送完毕后关闭
}

func receiver(ch chan int) {
    for {
        value, ok := <-ch
        if !ok {
            fmt.Println("Channel已关闭")
            break
        }
        fmt.Printf("收到: %d\n", value)
    }
}

func main() {
    ch := make(chan int)
    go sender(ch)
    receiver(ch)
}
```

---

### 3.6 遍历Channel

使用`for range`可以遍历channel，直到channel关闭。

#### 基本遍历

```go
package main

import "fmt"

func main() {
    ch := make(chan int)

    // 发送数据
    go func() {
        for i := 1; i <= 5; i++ {
            ch <- i
        }
        close(ch)  // 必须关闭，否则for range会一直等待
    }()

    // 遍历接收
    for value := range ch {
        fmt.Println(value)
    }
}
```

#### 生产者-消费者模式

```go
package main

import (
    "fmt"
    "sync"
)

func producer(ch chan<- int, wg *sync.WaitGroup) {
    defer wg.Done()
    for i := 1; i <= 10; i++ {
        ch <- i
        fmt.Printf("生产: %d\n", i)
    }
}

func consumer(id int, ch <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    count := 0
    for value := range ch {
        count++
        fmt.Printf("消费者 %d 消费: %d (总计: %d)\n", id, value, count)
    }
    fmt.Printf("消费者 %d 完成，共消费 %d 个值\n", id, count)
}

func main() {
    ch := make(chan int, 5)
    var wg sync.WaitGroup

    // 启动生产者
    wg.Add(1)
    go producer(ch, &wg)

    // 等待生产者完成后再关闭channel
    wg.Wait()
    close(ch)

    // 启动消费者
    wg.Add(2)
    go consumer(1, ch, &wg)
    go consumer(2, ch, &wg)

    wg.Wait()
    fmt.Println("所有任务完成")
}
```

---

### 3.7 Channel的阻塞特性

理解Channel的阻塞行为是掌握并发编程的关键。

#### 发送阻塞

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 无缓冲channel
    ch1 := make(chan int)  // 发送会阻塞直到被接收

    // 带缓冲channel
    ch2 := make(chan int, 2)  // 可以发送2个值而不阻塞

    fmt.Println("=== 无缓冲Channel ===")
    go func() {
        time.Sleep(1 * time.Second)
        fmt.Println("接收:", <-ch1)
    }()

    start := time.Now()
    ch1 <- 42  // 会阻塞1秒，直到goroutine接收
    fmt.Printf("发送耗时: %v\n", time.Since(start))

    fmt.Println("\n=== 带缓冲Channel ===")
    ch2 <- 1  // 不阻塞
    ch2 <- 2  // 不阻塞
    fmt.Println("快速发送完成")

    // 第三个发送会阻塞
    go func() {
        time.Sleep(1 * time.Second)
        <-ch2  // 接收一个值
    }()

    start = time.Now()
    ch2 <- 3  // 会阻塞1秒
    fmt.Printf("第三个发送耗时: %v\n", time.Since(start))
}
```

#### 死锁示例

```go
package main

import "fmt"

func main() {
    ch := make(chan int)

    // 死锁：向无缓冲channel发送，但没有接收者
    // ch <- 1  // 这会导致死锁

    // 正确的做法
    go func() {
        ch <- 1
    }()

    value := <-ch
    fmt.Println("收到:", value)
}
```

---

### 3.8 Channel使用模式

#### 信号Channel

```go
package main

import (
    "fmt"
    "time"
)

func worker(done chan bool) {
    fmt.Println("开始工作...")
    time.Sleep(2 * time.Second)
    fmt.Println("工作完成")
    done <- true  // 发送完成信号
}

func main() {
    done := make(chan bool)

    go worker(done)

    // 等待完成信号
    <-done
    fmt.Println("主程序退出")
}
```

#### 广播模式

```go
package main

import (
    "fmt"
    "sync"
)

func broadcaster(ch chan<- string, message string, numListeners int) {
    // 等待所有监听者准备好
    var wg sync.WaitGroup
    for i := 0; i < numListeners; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            fmt.Printf("监听者 %d 准备就绪\n", id)
        }(i)
    }
    wg.Wait()

    // 广播消息
    for i := 0; i < numListeners; i++ {
        ch <- message
    }
    close(ch)
}

func listener(id int, ch <-chan string) {
    for msg := range ch {
        fmt.Printf("监听者 %d 收到: %s\n", id, msg)
    }
}

func main() {
    ch := make(chan string, 3)

    // 启动监听者
    for i := 1; i <= 3; i++ {
        go listener(i, ch)
    }

    // 广播消息
    broadcaster(ch, "系统广播消息", 3)

    // 等待一下让所有goroutine完成
    time.Sleep(1 * time.Second)
}
```

---

## 总结

### Channel通信

1. **Channel类型**：
   - **无缓冲Channel**：同步通信，发送和接收都会阻塞
   - **带缓冲Channel**：异步通信，可存储多个值
   - **方向限制**：`chan<-` 只发送，`<-chan` 只接收

2. **核心特性**：
   - **类型安全**：只能传递指定类型的数据
   - **阻塞机制**：控制goroutine执行节奏
   - **同步原语**：实现goroutine间的同步

3. **重要操作**：
   - **关闭Channel**：使用`close()`表示不再发送数据
   - **遍历Channel**：使用`for range`接收数据
   - **检测关闭**：`value, ok := <-ch` 检查是否关闭

4. **使用模式**：
   - **信号传递**：使用channel发送完成信号
   - **数据流**：goroutine间传递数据
   - **广播**：一对多的通信模式

Channel是Go并发编程的基础，通过Channel，goroutine可以安全地交换数据，实现复杂的并发逻辑。在下一课中，我们将学习如何使用Select语句在多个Channel操作中进行选择。