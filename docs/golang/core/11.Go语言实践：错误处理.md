---
title: 11ã€Goè¯­è¨€å®è·µï¼šé”™è¯¯å¤„ç†
date: 2026-01-06
description: æ·±å…¥ç†è§£Goè¯­è¨€çš„é”™è¯¯å¤„ç†æœºåˆ¶ä»¥åŠpanicå’Œrecoverçš„ä½¿ç”¨
---

# 10ã€Goè¯­è¨€å®è·µï¼šé”™è¯¯å¤„ç†

æœ¬æ–‡æ¡£æ·±å…¥è®²è§£Goè¯­è¨€çš„é”™è¯¯å¤„ç†æ¨¡å¼ã€‚é”™è¯¯å¤„ç†æ˜¯ç¼–å†™å¥å£®ç¨‹åºçš„å…³é”®ï¼ŒæŒæ¡é”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µæ˜¯Goè¯­è¨€å¼€å‘çš„åŸºç¡€ã€‚

## ğŸ¯ æœ¬è¯¾å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬è¯¾åï¼Œä½ å°†èƒ½å¤Ÿï¼š
- âœ… æŒæ¡é”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µ
- âœ… ç†è§£é”™è¯¯åŒ…è£…å’Œé”™è¯¯é“¾
- âœ… å­¦ä¼šä½¿ç”¨errors.Iså’Œerrors.As
- âœ… ç†è§£panicå’Œrecoverçš„ä½¿ç”¨åœºæ™¯
- âœ… æŒæ¡è‡ªå®šä¹‰é”™è¯¯ç±»å‹çš„å®ç°

---

## ä¸€ã€é”™è¯¯å¤„ç†ï¼ˆError Handlingï¼‰

### 1.1 é”™è¯¯ç±»å‹

Goè¯­è¨€å°†é”™è¯¯è§†ä¸ºå€¼ï¼ˆerror is a valueï¼‰ï¼Œè€Œä¸æ˜¯å¼‚å¸¸ã€‚

#### erroræ¥å£

```go
// erroræ˜¯å†…ç½®æ¥å£
type error interface {
    Error() string
}
```

#### åˆ›å»ºé”™è¯¯

```go
package main

import (
    "errors"
    "fmt"
)

func main() {
    // æ–¹å¼1ï¼šä½¿ç”¨errors.New
    err1 := errors.New("å‘ç”Ÿäº†é”™è¯¯")
    fmt.Println(err1)
    
    // æ–¹å¼2ï¼šä½¿ç”¨fmt.Errorfï¼ˆæ”¯æŒæ ¼å¼åŒ–ï¼‰
    err2 := fmt.Errorf("é”™è¯¯ï¼š%s", "æ–‡ä»¶ä¸å­˜åœ¨")
    fmt.Println(err2)
}
```

---

### 1.2 é”™è¯¯å¤„ç†æ¨¡å¼

#### åŸºæœ¬æ¨¡å¼ï¼šæ£€æŸ¥å¹¶è¿”å›

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

func readFile(filename string) (string, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return "", fmt.Errorf("è¯»å–æ–‡ä»¶å¤±è´¥: %w", err)
    }
    return string(data), nil
}

func main() {
    content, err := readFile("test.txt")
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        return
    }
    fmt.Println("å†…å®¹:", content)
}
```

#### é”™è¯¯åŒ…è£…ï¼ˆError Wrappingï¼‰

Go 1.13+ æ”¯æŒé”™è¯¯åŒ…è£…ï¼Œå¯ä»¥ä¿ç•™é”™è¯¯é“¾ï¼š

```go
package main

import (
    "errors"
    "fmt"
    "os"
)

func readConfig() error {
    data, err := os.ReadFile("config.json")
    if err != nil {
        // ä½¿ç”¨ %w åŒ…è£…é”™è¯¯
        return fmt.Errorf("è¯»å–é…ç½®å¤±è´¥: %w", err)
    }
    // å¤„ç†data...
    return nil
}

func main() {
    err := readConfig()
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        
        // æ£€æŸ¥åº•å±‚é”™è¯¯
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("æ–‡ä»¶ä¸å­˜åœ¨")
        }
        
        // è§£åŒ…é”™è¯¯
        var pathErr *os.PathError
        if errors.As(err, &pathErr) {
            fmt.Printf("è·¯å¾„é”™è¯¯: %s\n", pathErr.Path)
        }
    }
}
```

#### errors.Is å’Œ errors.As

```go
package main

import (
    "errors"
    "fmt"
    "io"
    "os"
)

func processFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return fmt.Errorf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %w", err)
    }
    defer file.Close()
    
    data := make([]byte, 1024)
    _, err = file.Read(data)
    if err != nil && err != io.EOF {
        return fmt.Errorf("è¯»å–æ–‡ä»¶å¤±è´¥: %w", err)
    }
    
    return nil
}

func main() {
    err := processFile("test.txt")
    
    // ä½¿ç”¨ errors.Is æ£€æŸ¥ç‰¹å®šé”™è¯¯
    if errors.Is(err, os.ErrNotExist) {
        fmt.Println("æ–‡ä»¶ä¸å­˜åœ¨")
    }
    
    // ä½¿ç”¨ errors.As æå–é”™è¯¯ç±»å‹
    var pathErr *os.PathError
    if errors.As(err, &pathErr) {
        fmt.Printf("è·¯å¾„: %s, æ“ä½œ: %s\n", pathErr.Path, pathErr.Op)
    }
}
```

---

### 1.3 è‡ªå®šä¹‰é”™è¯¯ç±»å‹

#### å®šä¹‰é”™è¯¯ç±»å‹

```go
package main

import (
    "errors"
    "fmt"
    "time"
)

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type ValidationError struct {
    Field   string
    Message string
    Time    time.Time
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("éªŒè¯å¤±è´¥ [%s]: %s (æ—¶é—´: %v)", e.Field, e.Message, e.Time)
}

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type NotFoundError struct {
    Resource string
    ID       string
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("èµ„æºæœªæ‰¾åˆ°: %s (ID: %s)", e.Resource, e.ID)
}

func validateUser(name string) error {
    if name == "" {
        return &ValidationError{
            Field:   "name",
            Message: "ç”¨æˆ·åä¸èƒ½ä¸ºç©º",
            Time:    time.Now(),
        }
    }
    return nil
}

func findUser(id string) error {
    // æ¨¡æ‹Ÿæœªæ‰¾åˆ°
    return &NotFoundError{
        Resource: "User",
        ID:       id,
    }
}

func main() {
    // å¤„ç†éªŒè¯é”™è¯¯
    if err := validateUser(""); err != nil {
        fmt.Println(err)
        
        // ç±»å‹æ–­è¨€ï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰
        if ve, ok := err.(*ValidationError); ok {
            fmt.Printf("å­—æ®µ: %s, æ¶ˆæ¯: %s\n", ve.Field, ve.Message)
        }
        
        // ä½¿ç”¨ errors.Asï¼ˆæ¨èæ–¹å¼ï¼‰
        var ve *ValidationError
        if errors.As(err, &ve) {
            fmt.Printf("ä½¿ç”¨errors.As - å­—æ®µ: %s, æ¶ˆæ¯: %s\n", ve.Field, ve.Message)
        }
    }
    
    // å¤„ç†æœªæ‰¾åˆ°é”™è¯¯
    if err := findUser("123"); err != nil {
        fmt.Println(err)
        
        // ä½¿ç”¨ errors.As
        var nfe *NotFoundError
        if errors.As(err, &nfe) {
            fmt.Printf("èµ„æº: %s, ID: %s\n", nfe.Resource, nfe.ID)
        }
    }
}
```

---

### 1.4 é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

#### 1. åŠæ—¶å¤„ç†é”™è¯¯

```go
// âŒ ä¸å¥½çš„åšæ³•
func badExample() {
    data, _ := os.ReadFile("file.txt")  // å¿½ç•¥é”™è¯¯
    fmt.Println(string(data))
}

// âœ… å¥½çš„åšæ³•
func goodExample() {
    data, err := os.ReadFile("file.txt")
    if err != nil {
        log.Printf("è¯»å–æ–‡ä»¶å¤±è´¥: %v", err)
        return
    }
    fmt.Println(string(data))
}
```

#### 2. æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯

```go
// âŒ ä¸å¥½çš„åšæ³•
func badExample(id int) error {
    if id < 0 {
        return errors.New("é”™è¯¯")
    }
    return nil
}

// âœ… å¥½çš„åšæ³•
func goodExample(id int) error {
    if id < 0 {
        return fmt.Errorf("æ— æ•ˆçš„ç”¨æˆ·ID: %d (å¿…é¡»å¤§äº0)", id)
    }
    return nil
}
```

#### 3. ä½¿ç”¨é”™è¯¯åŒ…è£…ä¿ç•™ä¸Šä¸‹æ–‡

```go
func processUser(id int) error {
    user, err := getUser(id)
    if err != nil {
        // åŒ…è£…é”™è¯¯ï¼Œä¿ç•™ä¸Šä¸‹æ–‡
        return fmt.Errorf("å¤„ç†ç”¨æˆ·å¤±è´¥ (ID: %d): %w", id, err)
    }
    
    err = validateUser(user)
    if err != nil {
        return fmt.Errorf("éªŒè¯ç”¨æˆ·å¤±è´¥ (ID: %d): %w", id, err)
    }
    
    return nil
}
```

#### 4. ä¸è¦å¿½ç•¥é”™è¯¯

```go
// âŒ ä¸å¥½çš„åšæ³•
func badExample() {
    file, _ := os.Open("file.txt")  // å¿½ç•¥é”™è¯¯
    defer file.Close()  // å¦‚æœfileæ˜¯nilï¼Œè¿™é‡Œä¼španic
    // ç»§ç»­ä½¿ç”¨fileï¼Œå¯èƒ½å¯¼è‡´nilæŒ‡é’ˆè§£å¼•ç”¨
}

// âœ… å¥½çš„åšæ³•
func goodExample() {
    file, err := os.Open("file.txt")
    if err != nil {
        log.Printf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v", err)
        return  // åŠæ—¶è¿”å›ï¼Œé¿å…åç»­é”™è¯¯
    }
    defer file.Close()  // ç¡®ä¿èµ„æºé‡Šæ”¾
    
    // å®‰å…¨ä½¿ç”¨file
    data, err := io.ReadAll(file)
    if err != nil {
        log.Printf("è¯»å–æ–‡ä»¶å¤±è´¥: %v", err)
        return
    }
    fmt.Println(string(data))
}
```

#### 5. é”™è¯¯æ—¥å¿—è®°å½•

```go
import (
    "log"
    "os"
)

// âœ… è®°å½•é”™è¯¯ä¸Šä¸‹æ–‡
func processData(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        // è®°å½•è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
        log.Printf("æ‰“å¼€æ–‡ä»¶å¤±è´¥ [æ–‡ä»¶: %s]: %v", filename, err)
        return fmt.Errorf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %w", err)
    }
    defer file.Close()
    
    // å¤„ç†æ–‡ä»¶...
    return nil
}
```

#### 6. é”™è¯¯åˆ†ç±»å¤„ç†

```go
// æ ¹æ®é”™è¯¯ç±»å‹é‡‡å–ä¸åŒçš„å¤„ç†ç­–ç•¥
func handleError(err error) {
    if err == nil {
        return
    }
    
    // æ ¹æ®é”™è¯¯ç±»å‹åˆ†ç±»å¤„ç†
    if errors.Is(err, os.ErrNotExist) {
        // æ–‡ä»¶ä¸å­˜åœ¨ï¼šåˆ›å»ºé»˜è®¤æ–‡ä»¶
        createDefaultFile()
    } else if errors.Is(err, os.ErrPermission) {
        // æƒé™é”™è¯¯ï¼šè®°å½•å¹¶æç¤ºç”¨æˆ·
        log.Printf("æƒé™ä¸è¶³: %v", err)
        notifyUser("éœ€è¦ç®¡ç†å‘˜æƒé™")
    } else {
        // å…¶ä»–é”™è¯¯ï¼šè®°å½•å¹¶è¿”å›
        log.Printf("æœªçŸ¥é”™è¯¯: %v", err)
    }
}
```

---

## äºŒã€Panic å’Œ Recover

### 2.1 Panic

`panic` ç”¨äºè¡¨ç¤ºç¨‹åºé‡åˆ°äº†æ— æ³•æ¢å¤çš„é”™è¯¯ï¼Œä¼šå¯¼è‡´ç¨‹åºå´©æºƒã€‚

#### åŸºæœ¬ä½¿ç”¨

```go
package main

import "fmt"

func main() {
    fmt.Println("å¼€å§‹")
    panic("å‘ç”Ÿäº†ä¸¥é‡é”™è¯¯ï¼")
    fmt.Println("è¿™è¡Œä¸ä¼šæ‰§è¡Œ")
}

// è¾“å‡ºï¼š
// å¼€å§‹
// panic: å‘ç”Ÿäº†ä¸¥é‡é”™è¯¯ï¼
// goroutine 1 [running]:
// ...
```

#### ä½•æ—¶ä½¿ç”¨Panic

```go
package main

import "fmt"

// 1. ç¨‹åºåˆå§‹åŒ–å¤±è´¥
func init() {
    if !checkConfig() {
        panic("é…ç½®åˆå§‹åŒ–å¤±è´¥ï¼Œç¨‹åºæ— æ³•ç»§ç»­")
    }
}

// 2. ä¸å¯æ¢å¤çš„é”™è¯¯
func divide(a, b int) int {
    if b == 0 {
        panic("é™¤æ•°ä¸èƒ½ä¸º0")
    }
    return a / b
}

// 3. ç¼–ç¨‹é”™è¯¯ï¼ˆåº”è¯¥é¿å…ï¼Œä½¿ç”¨é”™è¯¯å¤„ç†æ›´å¥½ï¼‰
func getElement(arr []int, index int) int {
    if index < 0 || index >= len(arr) {
        panic(fmt.Sprintf("ç´¢å¼•è¶Šç•Œ: %d (é•¿åº¦: %d)", index, len(arr)))
    }
    return arr[index]
}

func main() {
    // é€šå¸¸åº”è¯¥ä½¿ç”¨é”™è¯¯å¤„ç†è€Œä¸æ˜¯panic
    result, err := safeDivide(10, 0)
    if err != nil {
        fmt.Println("é”™è¯¯:", err)
        return
    }
    fmt.Println(result)
}

// æ›´å¥½çš„åšæ³•ï¼šä½¿ç”¨é”™è¯¯å¤„ç†
func safeDivide(a, b int) (int, error) {
    if b == 0 {
        return 0, fmt.Errorf("é™¤æ•°ä¸èƒ½ä¸º0")
    }
    return a / b, nil
}
```

---

### 2.2 Recover

`recover` ç”¨äºæ•è· `panic`ï¼Œé˜²æ­¢ç¨‹åºå´©æºƒã€‚

#### åŸºæœ¬ä½¿ç”¨

```go
package main

import "fmt"

func mayPanic() {
    panic("å‘ç”Ÿäº†panicï¼")
}

func main() {
    // ä½¿ç”¨defer + recoveræ•è·panic
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("æ•è·åˆ°panic: %v\n", r)
        }
    }()
    
    mayPanic()
    fmt.Println("è¿™è¡Œä¸ä¼šæ‰§è¡Œ")
}

// è¾“å‡ºï¼š
// æ•è·åˆ°panic: å‘ç”Ÿäº†panicï¼
```

#### å®é™…åº”ç”¨ï¼šHTTPæœåŠ¡å™¨

```go
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    // æ¯ä¸ªè¯·æ±‚éƒ½æœ‰ç‹¬ç«‹çš„recover
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf("å¤„ç†è¯·æ±‚æ—¶å‘ç”Ÿpanic: %v\n", r)
            http.Error(w, "å†…éƒ¨æœåŠ¡å™¨é”™è¯¯", http.StatusInternalServerError)
        }
    }()
    
    // å¯èƒ½å‘ç”Ÿpanicçš„ä»£ç 
    panic("æ¨¡æ‹Ÿé”™è¯¯")
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

#### Recoverçš„æ³¨æ„äº‹é¡¹

```go
package main

import (
    "fmt"
    "time"
)

func example1() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("æ•è·åˆ°:", r)
        }
    }()
    
    panic("test")
}

func example2() {
    // âŒ recoverå¿…é¡»åœ¨deferå‡½æ•°ä¸­è°ƒç”¨
    // r := recover()  // è¿™æ ·ä¸ä¼šå·¥ä½œ
    
    defer func() {
        r := recover()  // âœ… è¿™æ ·æ‰æœ‰æ•ˆ
        if r != nil {
            fmt.Println("æ•è·åˆ°:", r)
        }
    }()
    
    panic("test")
}

func example3() {
    // recoveråªèƒ½æ•è·å½“å‰goroutineçš„panic
    go func() {
        panic("è¿™ä¸ªpanicæ— æ³•è¢«æ•è·")
    }()
    
    // éœ€è¦ç­‰å¾…ä¸€ä¸‹
    time.Sleep(100 * time.Millisecond)
}

func example4() {
    // æ¯ä¸ªgoroutineéœ€è¦è‡ªå·±çš„recover
    go func() {
        defer func() {
            if r := recover(); r != nil {
                fmt.Println("goroutineä¸­æ•è·:", r)
            }
        }()
        panic("goroutine panic")
    }()
    
    time.Sleep(100 * time.Millisecond)
}
```

---

### 2.3 Panic vs Error

#### ä½•æ—¶ä½¿ç”¨Errorï¼Œä½•æ—¶ä½¿ç”¨Panic

| åœºæ™¯ | ä½¿ç”¨ | åŸå›  |
|------|------|------|
| æ–‡ä»¶ä¸å­˜åœ¨ | Error | å¯é¢„æœŸçš„é”™è¯¯ï¼Œå¯ä»¥å¤„ç† |
| ç½‘ç»œè¶…æ—¶ | Error | å¯é¢„æœŸçš„é”™è¯¯ï¼Œå¯ä»¥é‡è¯• |
| é™¤é›¶æ“ä½œ | Error | å¯ä»¥é€šè¿‡æ£€æŸ¥é¿å… |
| æ•°ç»„è¶Šç•Œ | Panic | ç¼–ç¨‹é”™è¯¯ï¼Œåº”è¯¥ä¿®å¤ä»£ç  |
| ç©ºæŒ‡é’ˆè§£å¼•ç”¨ | Panic | ç¼–ç¨‹é”™è¯¯ï¼Œåº”è¯¥ä¿®å¤ä»£ç  |
| é…ç½®ç¼ºå¤± | Panic | ç¨‹åºæ— æ³•ç»§ç»­è¿è¡Œ |
| å†…å­˜ä¸è¶³ | Panic | ç³»ç»Ÿçº§é”™è¯¯ï¼Œæ— æ³•æ¢å¤ |

#### æœ€ä½³å®è·µ

```go
package main

import (
    "errors"
    "fmt"
)

// âœ… ä½¿ç”¨é”™è¯¯å¤„ç†å¯é¢„æœŸçš„é”™è¯¯
func readConfig(filename string) (string, error) {
    if filename == "" {
        return "", errors.New("æ–‡ä»¶åä¸èƒ½ä¸ºç©º")
    }
    // è¯»å–é…ç½®...
    return "config", nil
}

// âœ… ä½¿ç”¨panicå¤„ç†ä¸å¯æ¢å¤çš„é”™è¯¯
func mustReadConfig(filename string) string {
    config, err := readConfig(filename)
    if err != nil {
        panic(fmt.Sprintf("é…ç½®è¯»å–å¤±è´¥ï¼Œç¨‹åºæ— æ³•ç»§ç»­: %v", err))
    }
    return config
}

// âœ… åœ¨åº“ä¸­è¿”å›é”™è¯¯ï¼Œè®©è°ƒç”¨è€…å†³å®š
func libraryFunction() error {
    // åº“å‡½æ•°åº”è¯¥è¿”å›é”™è¯¯ï¼Œè€Œä¸æ˜¯panic
    return errors.New("åº“å‡½æ•°é”™è¯¯")
}

// âœ… åœ¨mainæˆ–initä¸­ä½¿ç”¨panic
func init() {
    if !checkCriticalConfig() {
        panic("å…³é”®é…ç½®ç¼ºå¤±")
    }
}
```

---

## ä¸‰ã€ç»¼åˆç¤ºä¾‹

### 3.1 å®Œæ•´çš„é”™è¯¯å¤„ç†ç¤ºä¾‹

```go
package main

import (
    "errors"
    "fmt"
    "os"
    "time"
)

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
type FileError struct {
    Op      string
    Path    string
    Err     error
    Time    time.Time
}

func (e *FileError) Error() string {
    return fmt.Sprintf("æ–‡ä»¶æ“ä½œå¤±è´¥ [%s] %s: %v (æ—¶é—´: %v)", 
        e.Op, e.Path, e.Err, e.Time)
}

func (e *FileError) Unwrap() error {
    return e.Err
}

// æ–‡ä»¶æ“ä½œå‡½æ•°
func readFile(path string) ([]byte, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, &FileError{
            Op:   "read",
            Path: path,
            Err:  err,
            Time: time.Now(),
        }
    }
    return data, nil
}

func writeFile(path string, data []byte) error {
    err := os.WriteFile(path, data, 0644)
    if err != nil {
        return &FileError{
            Op:   "write",
            Path: path,
            Err:  err,
            Time: time.Now(),
        }
    }
    return nil
}

// å¤„ç†æ–‡ä»¶
func processFile(inputPath, outputPath string) error {
    // è¯»å–æ–‡ä»¶
    data, err := readFile(inputPath)
    if err != nil {
        return fmt.Errorf("è¯»å–è¾“å…¥æ–‡ä»¶å¤±è´¥: %w", err)
    }
    
    // å¤„ç†æ•°æ®ï¼ˆæ¨¡æ‹Ÿï¼‰
    processedData := append(data, []byte("\nå¤„ç†å®Œæˆ")...)
    
    // å†™å…¥æ–‡ä»¶
    err = writeFile(outputPath, processedData)
    if err != nil {
        return fmt.Errorf("å†™å…¥è¾“å‡ºæ–‡ä»¶å¤±è´¥: %w", err)
    }
    
    return nil
}

func main() {
    err := processFile("input.txt", "output.txt")
    if err != nil {
        fmt.Printf("å¤„ç†æ–‡ä»¶å¤±è´¥: %v\n", err)
        
        // æ£€æŸ¥åº•å±‚é”™è¯¯
        var fileErr *FileError
        if errors.As(err, &fileErr) {
            fmt.Printf("æ“ä½œ: %s, è·¯å¾„: %s\n", fileErr.Op, fileErr.Path)
        }
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯æ–‡ä»¶ä¸å­˜åœ¨
        if errors.Is(err, os.ErrNotExist) {
            fmt.Println("æ–‡ä»¶ä¸å­˜åœ¨")
        }
        
        os.Exit(1)
    }
    
    fmt.Println("å¤„ç†æˆåŠŸ")
}
```

### 3.2 HTTPæœåŠ¡å™¨ä¸­çš„é”™è¯¯å¤„ç†

```go
package main

import (
    "encoding/json"
    "errors"
    "fmt"
    "log"
    "net/http"
    "time"
)

// è‡ªå®šä¹‰HTTPé”™è¯¯
type HTTPError struct {
    StatusCode int
    Message    string
    Time       time.Time
}

func (e *HTTPError) Error() string {
    return fmt.Sprintf("HTTP %d: %s", e.StatusCode, e.Message)
}

// ç”¨æˆ·æœåŠ¡
type UserService struct {
    // æ¨¡æ‹Ÿæ•°æ®åº“
    users map[int]string
}

func NewUserService() *UserService {
    return &UserService{
        users: map[int]string{
            1: "Alice",
            2: "Bob",
        },
    }
}

func (s *UserService) GetUser(id int) (string, error) {
    if id <= 0 {
        return "", &HTTPError{
            StatusCode: http.StatusBadRequest,
            Message:    "æ— æ•ˆçš„ç”¨æˆ·ID",
            Time:       time.Now(),
        }
    }
    
    name, exists := s.users[id]
    if !exists {
        return "", &HTTPError{
            StatusCode: http.StatusNotFound,
            Message:    fmt.Sprintf("ç”¨æˆ·ID %d ä¸å­˜åœ¨", id),
            Time:       time.Now(),
        }
    }
    
    return name, nil
}

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
func errorHandler(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("å‘ç”Ÿpanic: %v", r)
                http.Error(w, "å†…éƒ¨æœåŠ¡å™¨é”™è¯¯", http.StatusInternalServerError)
            }
        }()
        
        next(w, r)
    }
}

// ç”¨æˆ·å¤„ç†å‡½æ•°
func getUserHandler(w http.ResponseWriter, r *http.Request) {
    // è§£æå‚æ•°
    var id int
    if _, err := fmt.Sscanf(r.URL.Query().Get("id"), "%d", &id); err != nil {
        http.Error(w, "æ— æ•ˆçš„ç”¨æˆ·IDå‚æ•°", http.StatusBadRequest)
        return
    }
    
    // è·å–ç”¨æˆ·
    service := NewUserService()
    name, err := service.GetUser(id)
    if err != nil {
        // æ£€æŸ¥æ˜¯å¦æ˜¯HTTPError
        var httpErr *HTTPError
        if errors.As(err, &httpErr) {
            http.Error(w, httpErr.Message, httpErr.StatusCode)
            return
        }
        
        // å…¶ä»–é”™è¯¯
        log.Printf("è·å–ç”¨æˆ·å¤±è´¥: %v", err)
        http.Error(w, "å†…éƒ¨æœåŠ¡å™¨é”™è¯¯", http.StatusInternalServerError)
        return
    }
    
    // è¿”å›æˆåŠŸå“åº”
    response := map[string]interface{}{
        "id":   id,
        "name": name,
    }
    
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}

func main() {
    http.HandleFunc("/user", errorHandler(getUserHandler))
    
    log.Println("æœåŠ¡å™¨å¯åŠ¨åœ¨ :8080")
    if err := http.ListenAndServe(":8080", nil); err != nil {
        log.Fatalf("æœåŠ¡å™¨å¯åŠ¨å¤±è´¥: %v", err)
    }
}
```

---

## æ€»ç»“

### é”™è¯¯å¤„ç†ï¼ˆError Handlingï¼‰

1. **é”™è¯¯æ˜¯å€¼**ï¼šGoå°†é”™è¯¯è§†ä¸ºå€¼ï¼Œè€Œä¸æ˜¯å¼‚å¸¸

2. **é”™è¯¯å¤„ç†æ¨¡å¼**ï¼š
   - æ£€æŸ¥å¹¶è¿”å›é”™è¯¯
   - ä½¿ç”¨é”™è¯¯åŒ…è£…ä¿ç•™ä¸Šä¸‹æ–‡
   - ä½¿ç”¨ `errors.Is` å’Œ `errors.As` æ£€æŸ¥é”™è¯¯

3. **è‡ªå®šä¹‰é”™è¯¯ç±»å‹**ï¼š
   - å®ç° `error` æ¥å£
   - æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
   - æ”¯æŒé”™è¯¯é“¾

4. **æœ€ä½³å®è·µ**ï¼š
   - åŠæ—¶å¤„ç†é”™è¯¯ï¼Œä¸è¦å¿½ç•¥
   - æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
   - ä½¿ç”¨é”™è¯¯åŒ…è£…ä¿ç•™ä¸Šä¸‹æ–‡
   - åº“å‡½æ•°è¿”å›é”™è¯¯ï¼Œè®©è°ƒç”¨è€…å†³å®š

### Panic å’Œ Recover

1. **Panic**ï¼š
   - ç”¨äºä¸å¯æ¢å¤çš„é”™è¯¯
   - ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ
   - åº”è¯¥è°¨æ…ä½¿ç”¨

2. **Recover**ï¼š
   - ç”¨äºæ•è·panic
   - å¿…é¡»åœ¨deferå‡½æ•°ä¸­è°ƒç”¨
   - åªèƒ½æ•è·å½“å‰goroutineçš„panic

3. **ä½¿ç”¨åŸåˆ™**ï¼š
   - å¯é¢„æœŸçš„é”™è¯¯ä½¿ç”¨Error
   - ç¼–ç¨‹é”™è¯¯æˆ–ä¸å¯æ¢å¤çš„é”™è¯¯ä½¿ç”¨Panic
   - åº“å‡½æ•°åº”è¯¥è¿”å›é”™è¯¯ï¼Œè€Œä¸æ˜¯panic

### é”™è¯¯å¤„ç†å®è·µè¦ç‚¹

1. **é”™è¯¯å¤„ç†åŸåˆ™**ï¼š
   - å§‹ç»ˆå¤„ç†é”™è¯¯ï¼Œä¸è¦å¿½ç•¥ï¼ˆé¿å…ä½¿ç”¨ `_`ï¼‰
   - æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
   - ä½¿ç”¨é”™è¯¯åŒ…è£…ä¿ç•™ä¸Šä¸‹æ–‡
   - åŒºåˆ†å¯æ¢å¤å’Œä¸å¯æ¢å¤çš„é”™è¯¯

2. **é”™è¯¯æ£€æŸ¥**ï¼š
   - ä½¿ç”¨ `errors.Is` æ£€æŸ¥ç‰¹å®šé”™è¯¯
   - ä½¿ç”¨ `errors.As` æå–é”™è¯¯ç±»å‹
   - åˆ©ç”¨é”™è¯¯é“¾è¿›è¡Œé”™è¯¯è¿½è¸ª

3. **Panicä½¿ç”¨**ï¼š
   - åªåœ¨çœŸæ­£ä¸å¯æ¢å¤çš„æƒ…å†µä¸‹ä½¿ç”¨panic
   - åº“å‡½æ•°åº”è¯¥è¿”å›é”™è¯¯ï¼Œè€Œä¸æ˜¯panic
   - åœ¨mainæˆ–initä¸­ä½¿ç”¨panicå¤„ç†å…³é”®é…ç½®é”™è¯¯
   - ä½¿ç”¨recoveræ•è·panicï¼Œé˜²æ­¢ç¨‹åºå´©æºƒ

4. **å®é™…åº”ç”¨**ï¼š
   - HTTPæœåŠ¡å™¨ä¸­ä½¿ç”¨é”™è¯¯å¤„ç†ä¸­é—´ä»¶
   - æ•°æ®åº“æ“ä½œä¸­å§‹ç»ˆæ£€æŸ¥é”™è¯¯
   - æ–‡ä»¶æ“ä½œä¸­å¤„ç†å„ç§å¯èƒ½çš„é”™è¯¯
   - ç½‘ç»œè¯·æ±‚ä¸­å¤„ç†è¶…æ—¶å’Œè¿æ¥é”™è¯¯

é€šè¿‡ç³»ç»Ÿå­¦ä¹ é”™è¯¯å¤„ç†ï¼Œä½ å°†èƒ½å¤Ÿç¼–å†™å‡ºæ›´åŠ å¥å£®ã€å¯ç»´æŠ¤çš„Goç¨‹åºã€‚é”™è¯¯å¤„ç†æ˜¯Goè¯­è¨€å¼€å‘çš„åŸºç¡€ï¼Œåœ¨å®é™…é¡¹ç›®ä¸­ä¼šé¢‘ç¹ä½¿ç”¨ã€‚
