---
title: 5、Go语言基础：指针
date: 2026-01-09
description: 深入学习Go语言的指针概念，包括指针的声明、使用场景和最佳实践
---

# 5、Go语言基础：指针

本文档深入讲解Go语言的指针概念，指针是Go语言中的重要特性，用于内存管理和性能优化。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 理解指针的基本概念和原理
- ✅ 掌握指针的声明和初始化方法
- ✅ 理解指针的使用场景
- ✅ 掌握指针与复合类型的关系
- ✅ 理解指针的最佳实践

---

## 前置知识

- **第1-3课**：了解变量、数据类型和运算符

---

## 一、指针基础

### 1.1 什么是指针？

指针是Go语言中的一个重要概念，**指针保存了变量的内存地址**。通过指针，我们可以：

- **间接访问**变量的值
- **修改**原始变量的值
- **避免**大数据量的复制开销

#### 指针的基本概念

```go
package main

import "fmt"

func main() {
    // 声明一个int变量
    var num int = 42

    // 声明一个指向int的指针
    var ptr *int

    // 将num的地址赋值给ptr
    ptr = &num

    fmt.Printf("num的值: %d\n", num)        // 42
    fmt.Printf("ptr指向的值: %d\n", *ptr)   // 42（解引用）
    fmt.Printf("num的地址: %p\n", &num)     // num的内存地址
    fmt.Printf("ptr的值: %p\n", ptr)        // 相同的内存地址
}
```

#### 指针操作符

| 操作符 | 含义 | 示例 |
|--------|------|------|
| `&` | 取地址运算符 | `&x` 获取变量x的地址 |
| `*` | 解引用运算符 | `*p` 获取指针p指向的值 |

### 1.2 指针的声明与初始化

#### 声明方式

```go
package main

import "fmt"

func main() {
    // 方式1：声明后赋值
    var ptr1 *int
    var num1 int = 10
    ptr1 = &num1

    // 方式2：同时声明和初始化
    num2 := 20
    ptr2 := &num2

    // 方式3：使用new函数（返回指向零值的指针）
    ptr3 := new(int)
    *ptr3 = 30  // 必须先解引用再赋值

    fmt.Printf("*ptr1: %d\n", *ptr1)  // 10
    fmt.Printf("*ptr2: %d\n", *ptr2)  // 20
    fmt.Printf("*ptr3: %d\n", *ptr3)  // 30
}
```

#### new()函数

`new()` 函数分配内存并返回指向该类型的指针，指向的内存被初始化为零值：

```go
package main

import "fmt"

func main() {
    // 为不同类型分配内存
    intPtr := new(int)       // *int，值为0
    strPtr := new(string)    // *string，值为""
    boolPtr := new(bool)     // *bool，值为false

    fmt.Printf("intPtr: %d\n", *intPtr)     // 0
    fmt.Printf("strPtr: %q\n", *strPtr)     // ""
    fmt.Printf("boolPtr: %t\n", *boolPtr)   // false

    // 可以直接修改
    *intPtr = 42
    *strPtr = "Hello"
    *boolPtr = true

    fmt.Printf("修改后 - intPtr: %d, strPtr: %s, boolPtr: %t\n",
        *intPtr, *strPtr, *boolPtr)
}
```

---

## 二、指针的使用场景

### 2.1 修改函数外的变量

```go
package main

import "fmt"

// 值传递：无法修改原值
func modifyValue(x int) {
    x = 100  // 只修改了副本
}

// 指针传递：可以修改原值
func modifyPointer(x *int) {
    *x = 100  // 修改了原值
}

func main() {
    num := 42

    modifyValue(num)
    fmt.Printf("调用modifyValue后: %d\n", num)  // 42（未改变）

    modifyPointer(&num)
    fmt.Printf("调用modifyPointer后: %d\n", num) // 100（已改变）
}
```

### 2.2 避免大对象复制

```go
package main

import "fmt"

type BigStruct struct {
    data [1000]int
}

// 值传递：复制整个结构体
func processByValue(s BigStruct) {
    s.data[0] = 999
}

// 指针传递：只传递地址
func processByPointer(s *BigStruct) {
    s.data[0] = 999
}

func main() {
    big := BigStruct{}
    big.data[0] = 42

    fmt.Printf("原始值: %d\n", big.data[0])  // 42

    processByValue(big)
    fmt.Printf("值传递后: %d\n", big.data[0])  // 42（未改变）

    processByPointer(&big)
    fmt.Printf("指针传递后: %d\n", big.data[0]) // 999（已改变）
}
```

### 2.3 表示可选值（nil指针）

```go
package main

import "fmt"

// 返回值可能不存在的情况
func findUser(id int) *string {
    users := map[int]string{
        1: "Alice",
        2: "Bob",
    }

    if user, exists := users[id]; exists {
        return &user  // 返回指向用户的指针
    }
    return nil  // 用户不存在，返回nil
}

func main() {
    user1 := findUser(1)
    user2 := findUser(999)

    if user1 != nil {
        fmt.Printf("找到用户: %s\n", *user1)
    }

    if user2 == nil {
        fmt.Println("用户不存在")
    }
}
```

---

## 三、指针的注意事项

### 3.1 nil指针

```go
package main

import "fmt"

func main() {
    var ptr *int  // 零值是nil

    if ptr == nil {
        fmt.Println("ptr是nil指针")
    }

    // 解引用nil指针会panic
    // fmt.Println(*ptr)  // panic: runtime error: invalid memory address

    // 正确的做法：检查后再解引用
    if ptr != nil {
        fmt.Println(*ptr)
    } else {
        fmt.Println("指针为空，无法访问")
    }
}
```

### 3.2 指针的比较

```go
package main

import "fmt"

func main() {
    num1 := 42
    num2 := 42

    ptr1 := &num1
    ptr2 := &num1  // 指向同一个变量
    ptr3 := &num2  // 指向不同变量

    fmt.Printf("ptr1 == ptr2: %t\n", ptr1 == ptr2)  // true（指向相同地址）
    fmt.Printf("ptr1 == ptr3: %t\n", ptr1 == ptr3)  // false（指向不同地址）

    // 可以与nil比较
    var nilPtr *int
    fmt.Printf("nilPtr == nil: %t\n", nilPtr == nil)  // true
}
```

### 3.3 指针的类型安全性

```go
package main

import "fmt"

func main() {
    var intPtr *int
    var strPtr *string

    num := 42
    text := "hello"

    intPtr = &num
    strPtr = &text

    // 不能将不同类型的指针相互赋值
    // intPtr = strPtr  // 编译错误：cannot use strPtr (type *string) as type *int

    // 只能解引用为对应的类型
    fmt.Printf("int: %d, string: %s\n", *intPtr, *strPtr)
}
```

---

## 四、指针与复合类型

### 4.1 数组指针

```go
package main

import "fmt"

func main() {
    // 数组指针
    arr := [3]int{1, 2, 3}
    arrPtr := &arr

    fmt.Printf("数组: %v\n", arr)
    fmt.Printf("通过指针访问: %v\n", *arrPtr)

    // 修改数组元素
    (*arrPtr)[0] = 999
    fmt.Printf("修改后: %v\n", arr)
}
```

### 4.2 结构体指针

```go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func main() {
    // 结构体指针
    p := &Person{Name: "Alice", Age: 25}

    // 直接通过指针访问字段（Go自动解引用）
    fmt.Printf("姓名: %s, 年龄: %d\n", p.Name, p.Age)

    // 修改结构体字段
    p.Name = "Bob"
    p.Age = 30

    fmt.Printf("修改后: %+v\n", *p)
}
```

### 4.3 切片指针（不常用）

```go
package main

import "fmt"

func main() {
    slice := []int{1, 2, 3}
    slicePtr := &slice

    // 通常不需要指针，直接使用切片即可
    fmt.Printf("切片: %v\n", *slicePtr)

    // 切片本身就是引用类型，通常不需要额外的指针
    fmt.Printf("直接访问: %v\n", slice)
}
```

---

## 五、指针的最佳实践

### 5.1 何时使用指针？

1. **需要修改函数外的变量**时
2. **传递大对象**避免复制开销时
3. **表示可选值**（nil表示不存在）时
4. **实现数据结构**（如链表、树）时

### 5.2 何时不使用指针？

1. **传递小对象**时（Go会自动优化）
2. **不需要修改原值**时
3. **作为Map的key**时（指针不可比较）

### 5.3 代码规范

```go
package main

import "fmt"

// 推荐：使用指针传递大结构体或需要修改的情况
func updateUser(user *User) {
    user.Name = "Updated"
}

// 不推荐：传递小值时使用指针
func printInt(value *int) {
    fmt.Println(*value)
}

// 推荐：直接传递小值
func printIntBetter(value int) {
    fmt.Println(value)
}

type User struct {
    Name  string
    Email string
    // ... 其他字段
}

func main() {
    user := &User{Name: "Alice"}
    updateUser(user)
    fmt.Printf("更新后: %+v\n", *user)
}
```

---

## 六、综合示例

```go
package main

import "fmt"

type Node struct {
    Value int
    Next  *Node
}

// 链表操作示例
func appendNode(head *Node, value int) *Node {
    newNode := &Node{Value: value, Next: nil}
    
    if head == nil {
        return newNode
    }
    
    current := head
    for current.Next != nil {
        current = current.Next
    }
    current.Next = newNode
    
    return head
}

func printList(head *Node) {
    current := head
    for current != nil {
        fmt.Printf("%d -> ", current.Value)
        current = current.Next
    }
    fmt.Println("nil")
}

func main() {
    var head *Node
    
    head = appendNode(head, 1)
    head = appendNode(head, 2)
    head = appendNode(head, 3)
    
    printList(head)  // 1 -> 2 -> 3 -> nil
}
```

---

## 总结

### 指针要点

1. **基本概念**：
   - 指针保存变量的内存地址
   - `&`取地址，`*`解引用
   - 零值是`nil`

2. **使用场景**：
   - 修改函数外的变量
   - 避免大对象复制
   - 表示可选值
   - 实现数据结构

3. **注意事项**：
   - 检查nil指针
   - 指针类型安全
   - 合理使用指针

### 最佳实践

1. **性能优化**：大对象使用指针传递
2. **安全性**：始终检查nil指针
3. **代码清晰**：小对象直接传递值
4. **类型安全**：利用Go的类型系统

掌握指针是理解Go语言内存模型的关键。在下一课中，我们将学习字符串、数组和切片。