---
title: 1、Go语言入门：基础语法与数据类型
date: 2026-01-06
description: 从零开始学习Go语言的基础语法、变量、常量、基本数据类型、字符串、数组和切片
---

# 1、Go语言入门：基础语法与数据类型

本文档从最基础的概念开始，逐步深入，帮助技术人员系统理解Go语言的核心机制。

## 🎯 本课学习目标

完成本课后，你将能够：
- ✅ 理解Go程序的基本结构（package、import、main）
- ✅ 掌握变量和常量的声明与使用
- ✅ 了解基本数据类型和零值概念
- ✅ 理解字符串的基本操作
- ✅ 掌握数组和切片的基础用法
- ✅ 了解作用域的基本概念

---

## 一、基础概念：变量与常量

### 1.1 变量（Variables）

#### 基本声明方式

Go语言提供了三种变量声明方式：

```go
package main

import "fmt"

func main() {
    // 方式1：var 声明（可显式指定类型）
    var name string = "Go"
    
    // 方式2：类型推断（省略类型）
    var age = 18
    
    // 方式3：短变量声明（仅函数内可用）
    city := "Beijing"
    
    fmt.Println(name, age, city)
}
```

#### 零值（Zero Value）

Go语言中，未初始化的变量会有默认值：

```go
var (
    i int       // 0
    f float64   // 0.0
    s string    // ""
    b bool      // false
    p *int      // nil
)
```

#### 多变量声明

```go
// 同一类型
var x, y, z int

// 不同类型
var (
    name string = "Go"
    age  int    = 10
)

// 短变量声明
a, b, c := 1, 2, "hello"
```

---

### 1.2 常量（Constants）

常量在编译期确定，不可修改：

```go
package main

import "fmt"

const Pi = 3.14159
const (
    StatusOK = 200
    StatusNotFound = 404
)

func main() {
    const localConst = "局部常量"
    fmt.Println(Pi, StatusOK, localConst)
}
```

#### iota：常量生成器

`iota` 用于生成连续的整数常量：

```go
const (
    a = iota  // 0
    b         // 1
    c         // 2
)

const (
    _ = iota      // 忽略第一个值
    KB = 1 << (10 * iota)  // 1024
    MB                        // 1048576
    GB                        // 1073741824
)
```

---

### 1.3 枚举（Enums）

Go语言没有`enum`关键字，但可以通过**常量组**和**自定义类型**来实现枚举功能。

#### 基础枚举：使用常量组

最简单的枚举方式，使用常量组定义一组相关常量：

```go
package main

import "fmt"

// HTTP状态码枚举
const (
    StatusOK       = 200
    StatusNotFound = 404
    StatusError    = 500
)

func main() {
    code := StatusOK
    fmt.Println(code)  // 200
}
```

#### 使用iota实现枚举

`iota`可以自动生成递增的枚举值：

```go
package main

import "fmt"

// 星期枚举
const (
    Sunday = iota  // 0
    Monday         // 1
    Tuesday        // 2
    Wednesday      // 3
    Thursday       // 4
    Friday         // 5
    Saturday       // 6
)

func main() {
    day := Monday
    fmt.Println(day)  // 1
}
```

#### 自定义类型枚举（推荐）

使用自定义类型可以增强类型安全性，避免不同枚举之间的混淆：

```go
package main

import "fmt"

// 定义枚举类型
type Status int

// 定义枚举值
const (
    StatusPending Status = iota  // 0
    StatusRunning                // 1
    StatusSuccess                // 2
    StatusFailed                 // 3
)

// 为枚举类型添加方法
func (s Status) String() string {
    switch s {
    case StatusPending:
        return "Pending"
    case StatusRunning:
        return "Running"
    case StatusSuccess:
        return "Success"
    case StatusFailed:
        return "Failed"
    default:
        return "Unknown"
    }
}

func main() {
    var status Status = StatusRunning
    fmt.Println(status)        // Running（调用String方法）
    fmt.Println(int(status))   // 1（获取整数值）
}
```

#### 字符串枚举

对于需要字符串值的枚举，可以使用字符串常量：

```go
package main

import "fmt"

type Color string

const (
    ColorRed    Color = "red"
    ColorGreen  Color = "green"
    ColorBlue   Color = "blue"
)

func main() {
    color := ColorRed
    fmt.Println(color)  // red
}
```

#### 枚举的高级用法

##### 1. 跳过某些值

```go
const (
    _ = iota      // 跳过0
    Red           // 1
    Green         // 2
    _             // 跳过3
    Blue          // 4
)
```

##### 2. 位掩码枚举

使用`iota`和位运算实现标志位枚举：

```go
package main

import "fmt"

type Permission int

const (
    Read   Permission = 1 << iota  // 1 (001)
    Write                          // 2 (010)
    Execute                        // 4 (100)
)

func main() {
    // 组合权限
    rw := Read | Write  // 3 (011)
    fmt.Println(rw)     // 3
    
    // 检查权限
    if rw&Read != 0 {
        fmt.Println("有读权限")
    }
}
```

##### 3. 枚举验证

为枚举添加验证方法，确保值的有效性：

```go
package main

import "fmt"

type Direction int

const (
    North Direction = iota
    East
    South
    West
)

// 验证枚举值是否有效
func (d Direction) IsValid() bool {
    return d >= North && d <= West
}

// 获取所有枚举值
func AllDirections() []Direction {
    return []Direction{North, East, South, West}
}

func main() {
    dir := Direction(5)
    if !dir.IsValid() {
        fmt.Println("无效的方向")
    }
}
```

#### 枚举的最佳实践

1. **使用自定义类型**：提高类型安全性，避免不同枚举混淆
2. **实现String方法**：方便调试和日志输出
3. **从0开始**：使用`iota`时，通常从0开始，除非有特殊需求
4. **添加验证方法**：确保枚举值的有效性
5. **使用有意义的命名**：枚举名和值名都要清晰表达含义

```go
// ✅ 好的实践
type OrderStatus int

const (
    OrderStatusPending OrderStatus = iota
    OrderStatusPaid
    OrderStatusShipped
    OrderStatusDelivered
    OrderStatusCancelled
)

func (s OrderStatus) String() string {
    // 实现String方法
}

// ❌ 不好的实践：直接使用int，容易混淆
const (
    Status1 = 0
    Status2 = 1
    Status3 = 2
)
```

---

## 二、基础数据类型：字符串

### 2.1 字符串的特点

- **不可变**：字符串一旦创建，内容无法修改
- **UTF-8编码**：原生支持Unicode

### 2.2 字符串的两种表示

```go
package main

import "fmt"

func main() {
    // 双引号：支持转义字符
    s1 := "Hello\nWorld"  // 换行符会被转义
    
    // 反引号：原始字符串，保留所有字符
    s2 := `Hello\nWorld`  // 输出字面量 \n
    
    fmt.Println(s1)
    fmt.Println(s2)
}
```

### 2.3 字符串操作

```go
s := "Hello"
len(s)              // 5（字节长度）
s[0]                // 'H'
s + " World"        // "Hello World"
strings.Contains(s, "ll")  // true
```

---

## 三、集合类型：数组与切片

### 3.1 数组（Arrays）

#### 特点

- **固定长度**：声明时确定，不可改变
- **值类型**：赋值或传参时会**复制整个数组**

```go
package main

import "fmt"

func main() {
    // 声明方式
    var arr1 [3]int              // [0 0 0]
    arr2 := [3]int{1, 2, 3}      // [1 2 3]
    arr3 := [...]int{1, 2, 3}    // 编译器推断长度
    
    // 值类型：复制整个数组
    arr4 := arr2
    arr4[0] = 100
    fmt.Println(arr2)  // [1 2 3]（原数组不变）
    fmt.Println(arr4)  // [100 2 3]
}
```

#### 数组的局限性

由于数组是值类型且长度固定，在实际开发中很少直接使用，更多使用切片。

---

### 3.2 切片（Slices）

#### 为什么需要切片？

切片解决了数组的两个问题：
1. **动态长度**：可以动态增长
2. **引用语义**：避免大数组的复制开销

#### 切片的基本操作

```go
package main

import "fmt"

func main() {
    // 创建切片
    s1 := []int{1, 2, 3}           // 字面量
    s2 := make([]int, 3)           // make创建，长度3
    s3 := make([]int, 3, 5)        // 长度3，容量5
    
    // 从数组创建
    arr := [5]int{1, 2, 3, 4, 5}
    s4 := arr[1:4]                 // [2 3 4]
    
    // 追加元素
    s1 = append(s1, 4, 5)          // [1 2 3 4 5]
    
    fmt.Println(s1, s2, s3, s4)
}
```

#### 切片的底层结构

切片是对底层数组的引用，包含三个字段：
- **指针**：指向底层数组的某个元素
- **长度（len）**：切片中元素个数
- **容量（cap）**：从切片起始位置到底层数组末尾的元素个数

```go
s := []int{1, 2, 3, 4, 5}
fmt.Println(len(s))  // 5
fmt.Println(cap(s))  // 5

s2 := s[1:3]         // [2 3]
fmt.Println(len(s2)) // 2
fmt.Println(cap(s2)) // 4（从索引1到末尾）
```

#### 切片的引用特性

```go
package main

import "fmt"

func main() {
    s1 := []int{1, 2, 3}
    s2 := s1          // s2和s1指向同一个底层数组
    
    s2[0] = 100       // 修改s2会影响s1
    fmt.Println(s1)   // [100 2 3]
    fmt.Println(s2)   // [100 2 3]
    
    // 但追加可能触发扩容，创建新数组
    s2 = append(s2, 4)
    s2[0] = 200
    fmt.Println(s1)   // [100 2 3]（s1不变）
    fmt.Println(s2)   // [200 2 3 4]
}
```

---

## 四、深入理解：作用域机制

### 4.1 作用域的类型

Go语言采用**词法作用域**（静态作用域），变量的可见性由代码结构决定：

| 作用域类型 | 声明位置 | 可见范围 | 示例 |
|-----------|----------|----------|------|
| **包级作用域** | 包级别 | 整个包内可见 | `var pkgVar = "包级"` |
| **函数级作用域** | 函数内部 | 整个函数内可见 | `func f() { var x = 1 }` |
| **代码块作用域** | `if`/`for`/`switch`等 | 仅该代码块内可见 | `if true { var x = 1 }` |

### 4.2 变量遮蔽（Variable Shadowing）

内层作用域可以声明与外层同名的变量，外层变量被遮蔽：

```go
package main

import "fmt"

var x = "包级变量"

func main() {
    x := "函数级变量"  // 遮蔽包级变量x
    
    if true {
        x := "代码块变量"  // 遮蔽函数级变量x
        fmt.Println(x)    // 输出：代码块变量
    }
    
    fmt.Println(x)  // 输出：函数级变量
}
```

### 4.3 for循环变量的作用域

#### 传统for循环

```go
package main

import "fmt"

func main() {
    // i的作用域是整个for循环（包括初始化、条件、迭代、循环体）
    for i := 0; i < 3; i++ {
        fmt.Println(i)  // 0, 1, 2
    }
    // fmt.Println(i)  // 编译错误：i未定义
}
```

**关键点**：
- `i` 的作用域包括：初始化部分（`i := 0`）、条件部分（`i < 3`）、迭代部分（`i++`）和循环体
- 循环结束后，`i` 不可见，不能在循环外部访问

#### for-range循环（Go 1.22+）

Go 1.22修复了for-range循环的变量作用域问题：

```go
package main

import "fmt"

func main() {
    nums := []int{1, 2, 3}
    var funcs []func()
    
    // Go 1.22+：每次循环创建独立的v变量
    for _, v := range nums {
        funcs = append(funcs, func() {
            fmt.Println(v)  // 正确：每个闭包捕获不同的v
        })
    }
    
    for _, f := range funcs {
        f()  // 输出：1, 2, 3（而不是3, 3, 3）
    }
}
```

#### 循环变量的常见陷阱

```go
// 陷阱：在闭包中使用循环变量
var funcs []func()
for i := 0; i < 3; i++ {
    // 错误：所有闭包共享同一个i
    funcs = append(funcs, func() {
        fmt.Println(i)  // 都输出3
    })
}

// 正确：创建局部变量副本
for i := 0; i < 3; i++ {
    i := i  // 创建局部副本
    funcs = append(funcs, func() {
        fmt.Println(i)  // 输出：0, 1, 2
    })
}
```

#### 在循环外使用循环变量

如果想在循环外使用循环变量的值，需要将其赋值给循环外的变量：

```go
package main

import "fmt"

func main() {
    var lastValue int
    for i := 0; i < 10; i++ {
        lastValue = i
    }
    fmt.Println(lastValue) // 输出9，循环结束后可见
}
```

---

## 五、类型对比总结

| 特性 | 变量 | 常量 | 字符串 | 数组 | 切片 |
|------|------|------|--------|------|------|
| **可修改** | ✅ | ❌ | ❌ | ✅ | ✅ |
| **长度** | 可变 | 固定 | 可变 | 固定 | 可变 |
| **类型** | 值/引用 | 值类型 | 值类型 | 值类型 | 引用类型 |
| **内存** | 栈/堆 | 编译期 | 栈 | 栈 | 堆（引用底层数组） |
| **复制行为** | 取决于类型 | 编译期 | 复制内容 | 复制整个数组 | 复制切片头（3个字段） |

---

## 六、最佳实践

### 6.1 作用域最小化原则

```go
// ❌ 不好的实践：变量作用域过大
var result int
for i := 0; i < 10; i++ {
    result = i * 2
}

// ✅ 好的实践：限制变量作用域
for i := 0; i < 10; i++ {
    result := i * 2  // 仅在循环内可见
    // 使用result...
}
```

### 6.2 避免不必要的变量遮蔽

```go
// ❌ 容易混淆
x := 1
if condition {
    x := 2  // 遮蔽外层x，可能不是预期行为
    // ...
}

// ✅ 使用不同的变量名
x := 1
if condition {
    y := 2  // 清晰的命名
    // ...
}
```

### 6.3 切片的正确使用

```go
// ✅ 预分配容量（如果知道大概大小）
s := make([]int, 0, 100)  // 长度0，容量100

// ✅ 检查切片是否为空
if len(s) == 0 {
    // 空切片
}

// ✅ 避免共享底层数组的意外修改
func process(s []int) {
    s = append(s, 0)  // 可能触发扩容，创建新数组
    // ...
}
```

### 6.4 导出标识符的命名

```go
// ✅ 大写开头：导出（包外可见）
var ExportedVar = "可导出"

// ✅ 小写开头：包内私有
var privateVar = "私有"
```

---

## 七、综合示例

```go
package main

import "fmt"

// 包级作用域
var (
    PackageVar = "包级变量"
    packageConst = "包级常量"
)

func main() {
    // 1. 变量声明
    var name string = "Go"
    age := 10
    fmt.Println(name, age)
    
    // 2. 字符串操作
    s := "Hello" + " " + "World"
    fmt.Println(s)
    
    // 3. 数组（值类型）
    arr := [3]int{1, 2, 3}
    arrCopy := arr
    arrCopy[0] = 100
    fmt.Println(arr)      // [1 2 3]
    fmt.Println(arrCopy)  // [100 2 3]
    
    // 4. 切片（引用类型）
    slice := []int{1, 2, 3}
    sliceRef := slice
    sliceRef[0] = 100
    fmt.Println(slice)     // [100 2 3]
    fmt.Println(sliceRef)  // [100 2 3]
    
    // 5. 作用域示例
    x := "外层"
    if true {
        x := "内层"  // 遮蔽外层x
        fmt.Println(x)  // 内层
    }
    fmt.Println(x)  // 外层
    
    // 6. for循环变量作用域
    for i := 0; i < 3; i++ {
        fmt.Println(i)  // 0, 1, 2
    }
    // i在这里不可见
}
```

---

## 总结

1. **变量与常量**：理解零值、类型推断和iota的使用
2. **枚举**：通过常量组和自定义类型实现枚举，使用iota自动生成，增强类型安全性
3. **字符串**：不可变特性，两种表示方式的区别
4. **数组与切片**：值类型vs引用类型，切片的底层机制
5. **作用域**：词法作用域规则，变量遮蔽，循环变量的陷阱
6. **实践**：最小化作用域，合理使用切片，避免常见陷阱

掌握这些基础概念，是深入理解Go语言的关键。在实际开发中，要特别注意切片的引用特性和作用域规则，避免常见的陷阱。枚举是Go中常用的设计模式，使用自定义类型可以大大提高代码的类型安全性和可读性。
